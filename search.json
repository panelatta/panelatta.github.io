[{"categories":["Notes"],"content":"最近安装了 Terminator 替换 Ubuntu 的原生终端，美中不足的是按 Ctrl + Alt + T 快捷键时默认启动的还是原生终端。下面介绍一下怎么更改按下 Ctrl + Alt + T 快捷键时唤起的终端。\n命令 使用如下命令即可：\n1 2 gsettings set org.gnome.desktop.default-applications.terminal exec /usr/bin/terminator gsettings set org.gnome.desktop.default-applications.terminal exec-arg \"-x\" 当想换回默认设置时：\n1 gsettings reset org.gnome.desktop.default-applications.terminal 参考资料：Ubuntu用Terminator+ZSH打造好用的终端开发环境\n无效命令 针对这一问题，网上的大部分资料给出的是使用 update-alternatives 的解决方案：\n1 sudo update-alternatives --config x-terminal-emulator 但这一命令在我的电脑上无效。\n参考资料：如何在 Ubuntu 中更改默认终端\n","description":"","tags":["Ubuntu","Tricks"],"title":"更新Ubuntu默认终端为Terminator","uri":"/posts/%E6%9B%B4%E6%96%B0ubuntu%E9%BB%98%E8%AE%A4%E7%BB%88%E7%AB%AF%E4%B8%BAterminator/"},{"categories":["Notes"],"content":"git clone 默认只能拉取 master 分支的代码，但很多时候需要拉取其他分支的代码，本文列出了两种方式。\ngit clone 的同时拉取指定分支 使用命令 git clone -b \u003cbranch\u003e \u003c仓库地址\u003e\n拉取本地已有仓库的指定分支 git fetch origin \u003cbranch\u003e 将远程 \u003cbranch\u003e 分支拉到本地\ngit fetch 命令用于从另一个存储库下载对象和引用：\n要更新所有分支，可将命令简写为 git fetch 要更新指定分支，需指定分支名 git fetch \u003cremote_host\u003e \u003cbranch\u003e git checkout -b dev origin/\u003cbranch\u003e 在本地创建 dev 分支并切换到该分支\norigin/\u003cbranch\u003e 指将本地 Git 的头指针指向 origin 库的 \u003cbranch\u003e 分支\ngit pull origin \u003cbranch\u003e 将远程 \u003cbranch\u003e 分支上的内容全部拉取至本地\n当本地代码是 dev 分支时，需要先 git pull origin \u003cbranch\u003e 更新远程分支代码到本地，之后再 git pull 拉取远程 master 分支到本地，否则会引起冲突\nReferences https://www.jianshu.com/p/d87da5cdd46e https://www.cnblogs.com/woyaobianfei/p/9176062.html ","description":"","tags":["Git","Git 分支","Git 远程"],"title":"git clone拉取指定分支代码到本地","uri":"/posts/git-clone%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%90%8E%E6%8B%89%E5%8F%96%E5%85%B6%E4%BB%96%E5%88%86%E6%94%AF%E4%BB%A3%E7%A0%81%E5%88%B0%E6%9C%AC%E5%9C%B0/"},{"categories":["Algorithm","String"],"content":"introduction\n","description":"","tags":null,"title":"Trie-KMP-AC自动机","uri":"/posts/trie-kmp-ac%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"categories":["Algorithm","Sorting"],"content":"introduction\n","description":"","tags":null,"title":"拓扑排序概述","uri":"/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E6%A6%82%E8%BF%B0/"},{"categories":["Programming Contest","Codeforces","Div. 2"],"content":"这场前 4 题难度不高，后 3 题抽时间看一下。\nMy Status A B C D E F G O O O O Ø Ø Ø A. Replacing Elements Description Time Limit: 2 seconds Memory Limit: 256 megabytes\nYou have an array $a_1, a_2, \\dots, a_n$. All $a_i$ are positive integers.\nIn one step you can choose three distinct indices $i$, $j$, and $k$ ($i \\neq j$; $i \\neq k$; $j \\neq k$) and assign the sum of $a_j$ and $a_k$ to $a_i$, i. e. make $a_i = a_j + a_k$.\nCan you make all $a_i$ lower or equal to $d$ using the operation above any number of times (possibly, zero)?\nInput The first line contains a single integer $t$ ($1 \\le t \\le 2000$) — the number of test cases.\nThe first line of each test case contains two integers $n$ and $d$ ($3 \\le n \\le 100$; $1 \\le d \\le 100$) — the number of elements in the array $a$ and the value $d$.\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 100$) — the array $a$.\nOutput For each test case, print $\\texttt{YES}$, if it’s possible to make all elements $a_i$ less or equal than $d$ using the operation above. Otherwise, print $\\texttt{NO}$.\nYou may print each letter in any case (for example, $\\texttt{YES}$, $\\texttt{Yes}$, $\\texttt{yes}$, $\\texttt{yEs}$ will all be recognized as positive answer).\nExample Input 3 5 3 2 3 2 5 4 3 4 2 4 4 5 4 2 1 5 3 6 Output NO YES YES Note In the first test case, we can prove that we can’t make all $a_i \\le 3$.\nIn the second test case, all $a_i$ are already less or equal than $d = 4$.\nIn the third test case, we can, for example, choose $i = 5$, $j = 1$, $k = 2$ and make $a_5 = a_1 + a_2 = 2 + 1 = 3$. Array $a$ will become $[2, 1, 5, 3, 3]$.\nAfter that we can make $a_3 = a_5 + a_2 = 3 + 1 = 4$. Array will become $[2, 1, 4, 3, 3]$ and all elements are less or equal than $d = 4$.\nSolution 先检查是否有所有 $a_i \\leq d$ 成立。\n若不成立，则将 $a$ 按升序排序，检查是否有 $a_1 + a_2 \\leq d$。若成立，则可用 $a_1 + a_2$ 替换每个大于 $d$ 的值，存在可行方案；否则不存在可行方案。\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 /*************************************************************/ #if __cplusplus \u003c 201103L // For jury which unsupports C++11 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003ccmath\u003e #include \u003ccassert\u003e #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cqueue\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(__typeof__(_end) _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(__typeof__(_rbegin) _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #define cfor(_var, _cbegin, _cend, ...) \\ for(__typeof__(_cend) _var = _cbegin; _var != _cend; __VA_ARGS__) #else #include \u003cbits/stdc++.h\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(decay\u003cdecltype(_end)\u003e::type _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(decay\u003cdecltype(_rbegin)\u003e::type _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #endif typedef long long ll; typedef long double ld; #define ABS(x) ((x) \u003e 0 ? (x) : -(x)) const int INF = 0x3f3f3f3f; // #define __DEBUG__ #ifdef __DEBUG__ #if defined _WIN32 #define _WINDEBUG #include \u003cwindows.h\u003e inline std::ostream\u0026 __YELLOW__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN|FOREGROUND_RED|FOREGROUND_INTENSITY); return s; } inline std::ostream\u0026 __WHITE__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); return s; } inline std::ostream\u0026 __RED__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_RED|FOREGROUND_INTENSITY); return s; } #elif defined __linux__ #define _LINUXDEBUG #define __YELLOW__ \"\\033[33;1m\" #define __WHITE__ \"\\033[0m\" #endif #endif #if defined _WINDEBUG || defined _LINUXDEBUG #define ar2vec(_begin, _end) \\ vector\u003cdecay\u003citerator_traits\u003cdecltype(_begin)\u003e::value_type\u003e::type\u003e(_begin, _end) #define debug(x...) \\ do { cout \u003c\u003c __YELLOW__ \u003c\u003c #x \u003c\u003c \" -\u003e \"; err(x); } while(0) void err() { cout \u003c\u003c __WHITE__ \u003c\u003c endl; } template\u003ctypename T, typename... A\u003e void err(T a, A... x) { cout \u003c\u003c __RED__ \u003c\u003c a \u003c\u003c __YELLOW__ \u003c\u003c ' '; err(x...); } template\u003ctemplate\u003ctypename...\u003e class T, typename t, typename... A\u003e void err(T\u003ct\u003e a, A... x) { for(auto\u0026 v : a) cout \u003c\u003c __RED__ \u003c\u003c v \u003c\u003c __YELLOW__ \u003c\u003c ' '; err(x...); } #else #define ar2vec(...) #define debug(...) #endif /*************************************************************/ const int MAXN = 100; int a[MAXN + 10]; int main() { ios::sync_with_stdio(false); cin.tie(0); // freopen(\"test.in\", \"r\", stdin); // freopen(\"test.out\", \"w\", stdout); int t = 0; cin \u003e\u003e t; while(t--) { int n = 0, d = 0; cin \u003e\u003e n \u003e\u003e d; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; bool flag = true; for(int i = 1; i \u003c= n; i++) if(a[i] \u003e d) { flag = false; break; } if(flag) { cout \u003c\u003c \"YES\" \u003c\u003c endl; continue; } sort(a + 1, a + n + 1); if(a[1] + a[2] \u003e d) cout \u003c\u003c \"NO\" \u003c\u003c endl; else cout \u003c\u003c \"YES\" \u003c\u003c endl; } return 0; } B. String LCM Description Time Limit: 2 seconds Memory Limit: 256 megabytes\nLet’s define a multiplication operation between a string $a$ and a positive integer $x$: $a \\cdot x$ is the string that is a result of writing $x$ copies of $a$ one after another. For example, “$\\texttt{abc}$” $\\cdot~2~=$ “$\\texttt{abcabc}$”, “$\\texttt{a}$” $\\cdot~5~=$ “$\\texttt{aaaaa}$”.\nA string $a$ is divisible by another string $b$ if there exists an integer $x$ such that $b \\cdot x = a$. For example, “$\\texttt{abababab}$” is divisible by “$\\texttt{ab}$”, but is not divisible by “$\\texttt{ababab}$” or “$\\texttt{aa}$”.\nLCM of two strings $s$ and $t$ (defined as $LCM(s, t)$) is the shortest non-empty string that is divisible by both $s$ and $t$.\nYou are given two strings $s$ and $t$. Find $LCM(s, t)$ or report that it does not exist. It can be shown that if $LCM(s, t)$ exists, it is unique.\nInput The first line contains one integer $q$ ($1 \\le q \\le 2000$) — the number of test cases.\nEach test case consists of two lines, containing strings $s$ and $t$ ($1 \\le |s|, |t| \\le 20$). Each character in each of these strings is either ‘$\\texttt{a}$’ or ‘$\\texttt{b}$’.\nOutput For each test case, print $LCM(s, t)$ if it exists; otherwise, print $\\texttt{-1}$ . It can be shown that if $LCM(s, t)$ exists, it is unique.\nExample Input 3 baba ba aa aaa aba ab Output baba aaaaaa -1 Note In the first test case, “$\\texttt{baba}$” = “$\\texttt{baba}$” $\\cdot~1~=$ “$\\texttt{ba}$” $\\cdot~2$.\nIn the second test case, “$\\texttt{aaaaaa}$” = “$\\texttt{aa}$” $\\cdot~3~=$ “$\\texttt{aaa}$” $\\cdot~2$.\nSolution 注意到 $s$ 和 $t$ 的长度均不超过 $20$，因此直接模拟即可。\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 /*************************************************************/ #if __cplusplus \u003c 201103L // For jury which unsupports C++11 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003ccmath\u003e #include \u003ccassert\u003e #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cqueue\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(__typeof__(_end) _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(__typeof__(_rbegin) _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #define cfor(_var, _cbegin, _cend, ...) \\ for(__typeof__(_cend) _var = _cbegin; _var != _cend; __VA_ARGS__) #else #include \u003cbits/stdc++.h\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(decay\u003cdecltype(_end)\u003e::type _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(decay\u003cdecltype(_rbegin)\u003e::type _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #endif typedef long long ll; typedef long double ld; #define ABS(x) ((x) \u003e 0 ? (x) : -(x)) const int INF = 0x3f3f3f3f; // #define __DEBUG__ #ifdef __DEBUG__ #if defined _WIN32 #define _WINDEBUG #include \u003cwindows.h\u003e inline std::ostream\u0026 __YELLOW__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN|FOREGROUND_RED|FOREGROUND_INTENSITY); return s; } inline std::ostream\u0026 __WHITE__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); return s; } inline std::ostream\u0026 __RED__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_RED|FOREGROUND_INTENSITY); return s; } #elif defined __linux__ #define _LINUXDEBUG #define __YELLOW__ \"\\033[33;1m\" #define __WHITE__ \"\\033[0m\" #endif #endif #if defined _WINDEBUG || defined _LINUXDEBUG #define ar2vec(_begin, _end) \\ vector\u003cdecay\u003citerator_traits\u003cdecltype(_begin)\u003e::value_type\u003e::type\u003e(_begin, _end) #define debug(x...) \\ do { cout \u003c\u003c __YELLOW__ \u003c\u003c #x \u003c\u003c \" -\u003e \"; err(x); } while(0) void err() { cout \u003c\u003c __WHITE__ \u003c\u003c endl; } template\u003ctypename T, typename... A\u003e void err(T a, A... x) { cout \u003c\u003c __RED__ \u003c\u003c a \u003c\u003c __YELLOW__ \u003c\u003c ' '; err(x...); } template\u003ctemplate\u003ctypename...\u003e class T, typename t, typename... A\u003e void err(T\u003ct\u003e a, A... x) { for(auto\u0026 v : a) cout \u003c\u003c __RED__ \u003c\u003c v \u003c\u003c __YELLOW__ \u003c\u003c ' '; err(x...); } #else #define ar2vec(...) #define debug(...) #endif /*************************************************************/ string getsub(string \u0026s) { int n = s.length(); for(int i = 1; i \u003c= n; i++) { if(n % i) continue; string sub = s.substr(0, i); bool flag = true; for(int j = i; j \u003c n; j += i) { if(sub != s.substr(j, i)) { flag = false; break; } } if(flag) return sub; } return string(\"\"); } int main() { ios::sync_with_stdio(false); cin.tie(0); // freopen(\"test.in\", \"r\", stdin); // freopen(\"test.out\", \"w\", stdout); int q = 0; cin \u003e\u003e q; while(q--) { string s, t; cin \u003e\u003e s \u003e\u003e t; string s_sub = getsub(s); string t_sub = getsub(t); debug(s_sub); debug(t_sub); if(s_sub != t_sub) cout \u003c\u003c -1 \u003c\u003c endl; else { int s_num = s.length() / s_sub.length(); int t_sum = t.length() / t_sub.length(); int lcd = s_num * t_sum / __gcd(s_num, t_sum); debug(s_num, t_sum, lcd); for(int i = 1; i \u003c lcd; i++) s_sub += t_sub; cout \u003c\u003c s_sub \u003c\u003c endl; } } return 0; } C. No More Inversions Description Time Limit: 2 seconds Memory Limit: 256 megabytes\nYou have a sequence $a$ with $n$ elements $1, 2, 3, \\dots, k - 1, k, k - 1, k - 2, \\dots, k - (n - k)$ ($k \\le n \u003c 2k$).\nLet’s call as inversion in $a$ a pair of indices $i \u003c j$ such that $a[i] \u003e a[j]$.\nSuppose, you have some permutation $p$ of size $k$ and you build a sequence $b$ of size $n$ in the following manner: $b[i] = p[a[i]]$.\nYour goal is to find such permutation $p$ that the total number of inversions in $b$ doesn’t exceed the total number of inversions in $a$, and $b$ is lexicographically maximum .\nSmall reminder: the sequence of $k$ integers is called a permutation if it contains all integers from $1$ to $k$ exactly once.\nAnother small reminder: a sequence $s$ is lexicographically smaller than another sequence $t$, if either $s$ is a prefix of $t$, or for the first $i$ such that $s_i \\ne t_i$, $s_i \u003c t_i$ holds (in the first position that these sequences are different, $s$ has smaller number than $t$).\nInput The first line contains a single integer $t$ ($1 \\le t \\le 1000$) — the number of test cases.\nThe first and only line of each test case contains two integers $n$ and $k$ ($k \\le n \u003c 2k$; $1 \\le k \\le 10^5$) — the length of the sequence $a$ and its maximum.\nIt’s guaranteed that the total sum of $k$ over test cases doesn’t exceed $10^5$.\nOutput For each test case, print $k$ integers — the permutation $p$ which maximizes $b$ lexicographically without increasing the total number of inversions.\nIt can be proven that $p$ exists and is unique.\nExample Input 4 1 1 2 2 3 2 4 3 Output 1 1 2 2 1 1 3 2 Note In the first test case, the sequence $a = [1]$, there is only one permutation $p = [1]$.\nIn the second test case, the sequence $a = [1, 2]$. There is no inversion in $a$, so there is only one permutation $p = [1, 2]$ which doesn’t increase the number of inversions.\nIn the third test case, $a = [1, 2, 1]$ and has $1$ inversion. If we use $p = [2, 1]$, then $b = [p[a[1]], p[a[2]], p[a[3]]] = [2, 1, 2]$ and also has $1$ inversion.\nIn the fourth test case, $a = [1, 2, 3, 2]$, and since $p = [1, 3, 2]$ then $b = [1, 3, 2, 3]$. Both $a$ and $b$ have $1$ inversion and $b$ is the lexicographically maximum.\nSolution 考虑到 $a$ 中的逆序列数目共有 $\\sum\\limits_{i=1}^{n-k} = \\dfrac{(n-k)(n-k+1)}{2}$ 个，全部由序列的后半部分 $k,(k-1),\\cdots,k-(n-k)$ 所贡献，因此只需要保证 $b$ 中的逆序列构造方式和 $a$ 相同即可。\n因此构造 $p = [1, 2, \\cdots, (2k-n-1),k,(k-1),\\cdots,k-(n-k)]$ 即可。容易发现 $b$ 序列中的逆序列部分和 $p$ 相同。\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 /*************************************************************/ #if __cplusplus \u003c 201103L // For jury which unsupports C++11 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003ccmath\u003e #include \u003ccassert\u003e #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cqueue\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(__typeof__(_end) _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(__typeof__(_rbegin) _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #define cfor(_var, _cbegin, _cend, ...) \\ for(__typeof__(_cend) _var = _cbegin; _var != _cend; __VA_ARGS__) #else #include \u003cbits/stdc++.h\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(decay\u003cdecltype(_end)\u003e::type _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(decay\u003cdecltype(_rbegin)\u003e::type _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #endif typedef long long ll; typedef long double ld; #define ABS(x) ((x) \u003e 0 ? (x) : -(x)) const int INF = 0x3f3f3f3f; // #define __DEBUG__ #ifdef __DEBUG__ #if defined _WIN32 #define _WINDEBUG #include \u003cwindows.h\u003e inline std::ostream\u0026 __YELLOW__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN|FOREGROUND_RED|FOREGROUND_INTENSITY); return s; } inline std::ostream\u0026 __WHITE__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); return s; } inline std::ostream\u0026 __RED__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_RED|FOREGROUND_INTENSITY); return s; } #elif defined __linux__ #define _LINUXDEBUG #define __YELLOW__ \"\\033[33;1m\" #define __WHITE__ \"\\033[0m\" #endif #endif #if defined _WINDEBUG || defined _LINUXDEBUG #define ar2vec(_begin, _end) \\ vector\u003cdecay\u003citerator_traits\u003cdecltype(_begin)\u003e::value_type\u003e::type\u003e(_begin, _end) #define debug(x...) \\ do { cout \u003c\u003c __YELLOW__ \u003c\u003c #x \u003c\u003c \" -\u003e \"; err(x); } while(0) void err() { cout \u003c\u003c __WHITE__ \u003c\u003c endl; } template\u003ctypename T, typename... A\u003e void err(T a, A... x) { cout \u003c\u003c __RED__ \u003c\u003c a \u003c\u003c __YELLOW__ \u003c\u003c ' '; err(x...); } template\u003ctemplate\u003ctypename...\u003e class T, typename t, typename... A\u003e void err(T\u003ct\u003e a, A... x) { for(auto\u0026 v : a) cout \u003c\u003c __RED__ \u003c\u003c v \u003c\u003c __YELLOW__ \u003c\u003c ' '; err(x...); } #else #define ar2vec(...) #define debug(...) #endif /*************************************************************/ const int MAXN = 1e5; int p[MAXN + 10]; int main() { ios::sync_with_stdio(false); cin.tie(0); // freopen(\"test.in\", \"r\", stdin); // freopen(\"test.out\", \"w\", stdout); int t = 0; cin \u003e\u003e t; while(t--) { int n = 0, k = 0; cin \u003e\u003e n \u003e\u003e k; for(int i = 1; i \u003c= 2 * k - n - 1; i++) p[i] = i; for(int i = 2 * k - n, cnt = k; i \u003c= k; i++) p[i] = cnt--; for(int i = 1; i \u003c= k; i++) if(i == k) cout \u003c\u003c p[i] \u003c\u003c endl; else cout \u003c\u003c p[i] \u003c\u003c \" \"; } return 0; } D. Program Description Time Limit: 2 seconds Memory Limit: 256 megabytes\nYou are given a program that consists of $n$ instructions. Initially a single variable $x$ is assigned to $0$. Afterwards, the instructions are of two types:\nincrease $x$ by $1$; decrease $x$ by $1$. You are given $m$ queries of the following format:\nquery $l$ $r$ — how many distinct values is $x$ assigned to if all the instructions between the $l$-th one and the $r$-th one inclusive are ignored and the rest are executed without changing the order? Input The first line contains a single integer $t$ ($1 \\le t \\le 1000$) — the number of testcases.\nThen the description of $t$ testcases follows.\nThe first line of each testcase contains two integers $n$ and $m$ ($1 \\le n, m \\le 2 \\cdot 10^5$) — the number of instructions in the program and the number of queries.\nThe second line of each testcase contains a program — a string of $n$ characters: each character is either ‘$\\texttt{+}$’ or ‘$\\texttt{-}$’ — increment and decrement instruction, respectively.\nEach of the next $m$ lines contains two integers $l$ and $r$ ($1 \\le l \\le r \\le n$) — the description of the query.\nThe sum of $n$ over all testcases doesn’t exceed $2 \\cdot 10^5$. The sum of $m$ over all testcases doesn’t exceed $2 \\cdot 10^5$.\nOutput For each testcase print $m$ integers — for each query $l$, $r$ print the number of distinct values variable $x$ is assigned to if all the instructions between the $l$-th one and the $r$-th one inclusive are ignored and the rest are executed without changing the order.\nExample Input 2 8 4 -+--+--+ 1 8 2 8 2 5 1 1 4 10 +-++ 1 1 1 2 2 2 1 3 2 3 3 3 1 4 2 4 3 4 4 4 Output 1 2 4 4 3 3 4 2 3 2 1 2 2 2 Note The instructions that remain for each query of the first testcase are:\nempty program — $x$ was only equal to $0$; “$\\texttt{-}$” — $x$ had values $0$ and $-1$; “$\\texttt{—+}$” — $x$ had values $0$, $-1$, $-2$, $-3$, $-2$ — there are $4$ distinct values among them; “$\\texttt{+–+–+}$” — the distinct values are $1$, $0$, $-1$, $-2$. Solution 首先考虑到在一段连续的指令序列中，$x$ 的赋值序列是连续的；这是因为每条指令只能为 $x$ 加 $1$ 或者减 $1$。因此，只需要维护该段指令序列中 $x$ 的最大值和最小值。\n考虑维护一个如下的数据结构：\n1 2 3 4 5 6 7 8 9 10 11 struct Data { int maxx, minn, add; Data(int _max = 0, int _min = 0, int _add = 0): maxx(_max), minn(_min), add(_add) {} Data operator + (const Data \u0026d) { return Data(max(maxx, add + d.maxx), min(minn, add + d.minn), add + d.add); } }; #endif 其中 maxx 和 minn 分别为在指令序列此处 $x$ 的最大值和最小值，add 代表\n","description":"","tags":["Codeforces","Div. 2","题解"],"title":"Codeforces Edu. Round #102 (Div. 2) [Personal Summary]","uri":"/posts/codeforces-edu-102-div2-%E9%A2%98%E8%A7%A3/"},{"categories":["Programming Contest","Codeforces","Div. 3"],"content":"这场比较水，最后三题值得关注一下。\nMy Status A B C D E1 E2 F O O O O O O O A. Favorite Sequence (800) Description Time Limit: 2 seconds Memory Limit: 256 megabytes\nPolycarp has a favorite sequence $a[1 \\dots n]$ consisting of $n$ integers. He wrote it out on the whiteboard as follows:\nhe wrote the number $a_1$ to the left side (at the beginning of the whiteboard); he wrote the number $a_2$ to the right side (at the end of the whiteboard); then as far to the left as possible (but to the right from $a_1$), he wrote the number $a_3$; then as far to the right as possible (but to the left from $a_2$), he wrote the number $a_4$; Polycarp continued to act as well, until he wrote out the entire sequence on the whiteboard. The beginning of the result looks like this (of course, if $n \\ge 4$). For example, if $n=7$ and $a=[3, 1, 4, 1, 5, 9, 2]$, then Polycarp will write a sequence on the whiteboard $[3, 4, 5, 2, 9, 1, 1]$.\nYou saw the sequence written on the whiteboard and now you want to restore Polycarp’s favorite sequence.\nInput The first line contains a single positive integer $t$ ($1 \\le t \\le 300$) — the number of test cases in the test. Then $t$ test cases follow.\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 300$) — the length of the sequence written on the whiteboard.\nThe next line contains $n$ integers $b_1, b_2,\\ldots, b_n$ ($1 \\le b_i \\le 10^9$) — the sequence written on the whiteboard.\nOutput Output $t$ answers to the test cases. Each answer — is a sequence $a$ that Polycarp wrote out on the whiteboard.\nExample Input 6 7 3 4 5 2 9 1 1 4 9 2 7 1 11 8 4 3 1 2 7 8 7 9 4 2 1 42 2 11 7 8 1 1 1 1 1 1 1 1 Output 3 1 4 1 5 9 2 9 1 2 7 8 2 4 4 3 9 1 7 2 8 7 42 11 7 1 1 1 1 1 1 1 1 Note In the first test case, the sequence $a$ matches the sequence from the statement. The whiteboard states after each step look like this:\n$[3] \\Rightarrow [3, 1] \\Rightarrow [3, 4, 1] \\Rightarrow [3, 4, 1, 1] \\Rightarrow [3, 4, 5, 1, 1] \\Rightarrow [3, 4, 5, 9, 1, 1] \\Rightarrow [3, 4, 5, 2, 9, 1, 1]$.\nSolution 直接模拟。\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 /*************************************************************/ #if __cplusplus \u003c 201103L // For jury which unsupports C++11 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003ccmath\u003e #include \u003ccassert\u003e #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cqueue\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(__typeof__(_end) _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(__typeof__(_rbegin) _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #define cfor(_var, _cbegin, _cend, ...) \\ for(__typeof__(_cend) _var = _cbegin; _var != _cend; __VA_ARGS__) #else #include \u003cbits/stdc++.h\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(decay\u003cdecltype(_end)\u003e::type _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(decay\u003cdecltype(_rbegin)\u003e::type _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #endif typedef long long ll; typedef long double ld; #define ABS(x) ((x) \u003e 0 ? (x) : -(x)) const int INF = 0x3f3f3f3f; // #define __DEBUG__ #ifdef __DEBUG__ #if defined _WIN32 #define _WINDEBUG #include \u003cwindows.h\u003e inline std::ostream\u0026 __YELLOW__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN|FOREGROUND_RED|FOREGROUND_INTENSITY); return s; } inline std::ostream\u0026 __WHITE__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); return s; } inline std::ostream\u0026 __RED__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_RED|FOREGROUND_INTENSITY); return s; } #elif defined __linux__ #define _LINUXDEBUG #define __YELLOW__ \"\\033[33;1m\" #define __WHITE__ \"\\033[0m\" #endif #endif #if defined _WINDEBUG || defined _LINUXDEBUG #define ar2vec(_begin, _end) \\ vector\u003cdecay\u003citerator_traits\u003cdecltype(_begin)\u003e::value_type\u003e::type\u003e(_begin, _end) #define debug(x...) \\ do { cout \u003c\u003c __YELLOW__ \u003c\u003c #x \u003c\u003c \" -\u003e \"; err(x); } while(0) void err() { cout \u003c\u003c __WHITE__ \u003c\u003c endl; } template\u003ctypename T, typename... A\u003e void err(T a, A... x) { cout \u003c\u003c __RED__ \u003c\u003c a \u003c\u003c __YELLOW__ \u003c\u003c ' '; err(x...); } template\u003ctemplate\u003ctypename...\u003e class T, typename t, typename... A\u003e void err(T\u003ct\u003e a, A... x) { for(auto\u0026 v : a) cout \u003c\u003c __RED__ \u003c\u003c v \u003c\u003c __YELLOW__ \u003c\u003c ' '; err(x...); } #else #define ar2vec(...) #define debug(...) #endif /*************************************************************/ const int MAXN = 300; int a[MAXN + 10], b[MAXN + 10]; int main() { // freopen(\"test.in\", \"r\", stdin); // freopen(\"test.out\", \"w\", stdout); ios::sync_with_stdio(false); cin.tie(0); int t = 0; while(cin \u003e\u003e t) { while(t--) { int n = 0; cin \u003e\u003e n; ffor(i, 1, n + 1, i++) cin \u003e\u003e b[i]; int *l = \u0026b[1], *r = \u0026b[n]; int m = 1; while(r - l \u003e= 0) { a[m++] = *l; a[m++] = *r; l++; r--; } ffor(i, 1, n + 1, i++) { if(i == n) cout \u003c\u003c a[i] \u003c\u003c endl; else cout \u003c\u003c a[i] \u003c\u003c \" \"; } } } return 0; } B. Last Year’s Substring (800) Description Time Limit: 2 seconds Memory Limit: 256 megabytes\nPolycarp has a string $s[1 \\dots n]$ of length $n$ consisting of decimal digits. Polycarp performs the following operation with the string $s$ no more than once (i.e. he can perform operation $0$ or $1$ time):\nPolycarp selects two numbers $i$ and $j$ ($1 \\leq i \\leq j \\leq n$) and removes characters from the $s$ string at the positions $i, i+1, i+2, \\ldots, j$ (i.e. removes substring $s[i \\dots j]$). More formally, Polycarp turns the string $s$ into the string $s_1 s_2 \\ldots s_{i-1} s_{j+1} s_{j+2} \\ldots s_{n}$. For example, the string $s=$\"${\\tt 20192020}$“​ Polycarp can turn into strings:\n“$\\tt 2020$” (in this case $(i,j)=(3,6)$ or $(i,j)=(1,4)$); “$\\tt 2019220$” (in this case $(i,j)=(6,6)$); “$\\tt 020$” (in this case $(i,j)=(1,5)$); other operations are also possible, only a few of them are listed above. Polycarp likes the string “$\\tt 2020$” very much, so he is wondering if it is possible to turn the string s into a string “$\\tt 2020$” in no more than one operation? Note that you can perform zero operations.\nInput The first line contains a positive integer $t$ ($1 \\leq t \\leq 1000 $) — number of test cases in the test. Then $t$ test cases follow.\nThe first line of each test case contains an integer $n$ ($4 \\leq n \\leq 200$) — length of the string $s$. The next line contains a string $s$ of length $n$ consisting of decimal digits. It is allowed that the string $s$ starts with digit $\\tt 0$.\nOutput For each test case, output on a separate line:\n“$\\tt YES$” if Polycarp can turn the string $s$ into a string “$\\tt 2020$” in no more than one operation (i.e. he can perform $0$ or $1$ operation); “$\\tt NO$” otherwise. You may print every letter of “$\\tt YES$” and “$\\tt NO$” in any case you want (so, for example, the strings $\\tt yEs$, $\\tt yes$, $\\tt Yes$ and $\\tt YES$ will all be recognized as positive answer).\nExample Input 6 8 20192020 8 22019020 4 2020 5 20002 6 729040 6 200200 Output YES YES YES NO NO NO Note In the first test case, Polycarp could choose $i=3$ and $j=6$.\nIn the second test case, Polycarp could choose $i=2$ and $j=5$.\nIn the third test case, Polycarp did not perform any operations with the string.\nSolution 检查字符串的前缀和后缀是否能拼成 $\\tt 2020$ 即可。\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 /*************************************************************/ #if __cplusplus \u003c 201103L // For jury which unsupports C++11 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003ccmath\u003e #include \u003ccassert\u003e #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cqueue\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(__typeof__(_end) _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(__typeof__(_rbegin) _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #define cfor(_var, _cbegin, _cend, ...) \\ for(__typeof__(_cend) _var = _cbegin; _var != _cend; __VA_ARGS__) #else #include \u003cbits/stdc++.h\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(decay\u003cdecltype(_end)\u003e::type _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(decay\u003cdecltype(_rbegin)\u003e::type _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #endif typedef long long ll; typedef long double ld; #define ABS(x) ((x) \u003e 0 ? (x) : -(x)) const int INF = 0x3f3f3f3f; // #define __DEBUG__ #ifdef __DEBUG__ #if defined _WIN32 #define _WINDEBUG #include \u003cwindows.h\u003e inline std::ostream\u0026 __YELLOW__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN|FOREGROUND_RED|FOREGROUND_INTENSITY); return s; } inline std::ostream\u0026 __WHITE__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); return s; } inline std::ostream\u0026 __RED__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_RED|FOREGROUND_INTENSITY); return s; } #elif defined __linux__ #define _LINUXDEBUG #define __YELLOW__ \"\\033[33;1m\" #define __WHITE__ \"\\033[0m\" #endif #endif #if defined _WINDEBUG || defined _LINUXDEBUG #define ar2vec(_begin, _end) \\ vector\u003cdecay\u003citerator_traits\u003cdecltype(_begin)\u003e::value_type\u003e::type\u003e(_begin, _end) #define debug(x...) \\ do { cout \u003c\u003c __YELLOW__ \u003c\u003c #x \u003c\u003c \" -\u003e \"; err(x); } while(0) void err() { cout \u003c\u003c __WHITE__ \u003c\u003c endl; } template\u003ctypename T, typename... A\u003e void err(T a, A... x) { cout \u003c\u003c __RED__ \u003c\u003c a \u003c\u003c __YELLOW__ \u003c\u003c ' '; err(x...); } template\u003ctemplate\u003ctypename...\u003e class T, typename t, typename... A\u003e void err(T\u003ct\u003e a, A... x) { for(auto\u0026 v : a) cout \u003c\u003c __RED__ \u003c\u003c v \u003c\u003c __YELLOW__ \u003c\u003c ' '; err(x...); } #else #define ar2vec(...) #define debug(...) #endif /*************************************************************/ const int MAXN = 300; int a[MAXN + 10], b[MAXN + 10]; int main() { // freopen(\"test.in\", \"r\", stdin); // freopen(\"test.out\", \"w\", stdout); ios::sync_with_stdio(false); cin.tie(0); int t = 0; cin \u003e\u003e t; while(t--) { int n = 0; cin \u003e\u003e n; string s; cin \u003e\u003e s; bool flag = false; for(int i = 0; i \u003c= 4; i++) { if(s.substr(0, i) + s.substr(n - 4 + i, 4 - i) == string(\"2020\")) { flag = true; break; } } if(flag) cout \u003c\u003c \"YES\" \u003c\u003c endl; else cout \u003c\u003c \"NO\" \u003c\u003c endl; } return 0; } C. Unique Number (900) Description Time Limit: 2 seconds Memory Limit: 256 megabytes\nYou are given a positive number $x$. Find the smallest positive integer number that has the sum of digits equal to $x$ and all digits are distinct (unique).\nInput The first line contains a single positive integer $t$ ($1 \\le t \\le 50$) — the number of test cases in the test. Then $t$ test cases follow.\nEach test case consists of a single integer number $x$ ($1 \\le x \\le 50$).\nOutput Output $t$ answers to the test cases:\nif a positive integer number with the sum of digits equal to $x$ and all digits are different exists, print the smallest such number; otherwise print $\\tt -1$. Example Input 4 1 5 15 50 Output 1 5 69 -1 Solution 先检查 $x$ 是否大于 $45$，之后从 $9$ 到 $0$ 倒序贪心取数即可。\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 /*************************************************************/ #if __cplusplus \u003c 201103L // For jury which unsupports C++11 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003ccmath\u003e #include \u003ccassert\u003e #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cqueue\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(__typeof__(_end) _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(__typeof__(_rbegin) _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #define cfor(_var, _cbegin, _cend, ...) \\ for(__typeof__(_cend) _var = _cbegin; _var != _cend; __VA_ARGS__) #else #include \u003cbits/stdc++.h\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(decay\u003cdecltype(_end)\u003e::type _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(decay\u003cdecltype(_rbegin)\u003e::type _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #endif typedef long long ll; typedef long double ld; #define ABS(x) ((x) \u003e 0 ? (x) : -(x)) const int INF = 0x3f3f3f3f; // #define __DEBUG__ #ifdef __DEBUG__ #if defined _WIN32 #define _WINDEBUG #include \u003cwindows.h\u003e inline std::ostream\u0026 __YELLOW__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN|FOREGROUND_RED|FOREGROUND_INTENSITY); return s; } inline std::ostream\u0026 __WHITE__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); return s; } inline std::ostream\u0026 __RED__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_RED|FOREGROUND_INTENSITY); return s; } #elif defined __linux__ #define _LINUXDEBUG #define __YELLOW__ \"\\033[33;1m\" #define __WHITE__ \"\\033[0m\" #endif #endif #if defined _WINDEBUG || defined _LINUXDEBUG #define ar2vec(_begin, _end) \\ vector\u003cdecay\u003citerator_traits\u003cdecltype(_begin)\u003e::value_type\u003e::type\u003e(_begin, _end) #define debug(x...) \\ do { cout \u003c\u003c __YELLOW__ \u003c\u003c #x \u003c\u003c \" -\u003e \"; err(x); } while(0) void err() { cout \u003c\u003c __WHITE__ \u003c\u003c endl; } template\u003ctypename T, typename... A\u003e void err(T a, A... x) { cout \u003c\u003c __RED__ \u003c\u003c a \u003c\u003c __YELLOW__ \u003c\u003c ' '; err(x...); } template\u003ctemplate\u003ctypename...\u003e class T, typename t, typename... A\u003e void err(T\u003ct\u003e a, A... x) { for(auto\u0026 v : a) cout \u003c\u003c __RED__ \u003c\u003c v \u003c\u003c __YELLOW__ \u003c\u003c ' '; err(x...); } #else #define ar2vec(...) #define debug(...) #endif /*************************************************************/ const int MAXN = 300; int a[MAXN + 10], b[MAXN + 10]; int main() { // freopen(\"test.in\", \"r\", stdin); // freopen(\"test.out\", \"w\", stdout); ios::sync_with_stdio(false); cin.tie(0); int t = 0; cin \u003e\u003e t; while(t--) { int x = 0; cin \u003e\u003e x; if(x \u003c 10) { cout \u003c\u003c x \u003c\u003c endl; } else if(x \u003e 45) { cout \u003c\u003c -1 \u003c\u003c endl; } else { string ans; for(int i = 9; i \u003e= 0 \u0026\u0026 x \u003e 0; i--) { int add = 0; if(x \u003e= i) add = i; else add = x; ans.push_back(add + '0'); x -= add; } sort(ans.begin(), ans.end()); cout \u003c\u003c ans \u003c\u003c endl; } } return 0; } D. Add to Neighbour and Remove (1400) Description Time Limit: 3 seconds Memory Limit: 256 megabytes\nPolycarp was given an array of $a[1 \\dots n]$ of $n$ integers. He can perform the following operation with the array $a$ no more than $n$ times:\nPolycarp selects the index $i$ and adds the value $a_i$ to one of his choice of its neighbors. More formally, Polycarp adds the value of $a_i$ to $a_{i−1}$ or to $a_{i+1}$ (if such a neighbor does not exist, then it is impossible to add to it). After adding it, Polycarp removes the $i$-th element from the $a$ array. During this step the length of $a$ is decreased by $1$. The two items above together denote one single operation.\nFor example, if Polycarp has an array $a = [3, 1, 6, 6, 2]$, then it can perform the following sequence of operations with it:\nPolycarp selects $i = 2$ and adds the value $a_i$ to $(i-1)$-th element: $a = [4, 6, 6, 2]$. Polycarp selects $i = 1$ and adds the value $a_i$ to $(i+1)$-th element: $a = [10, 6, 2]$. Polycarp selects $i = 3$ and adds the value $a_i$ to $(i-1)$-th element: $a = [10, 8]$. Polycarp selects $i = 2$ and adds the value $a_i$ to $(i-1)$-th element: $a = [18]$. Note that Polycarp could stop performing operations at any time.\nPolycarp wondered how many minimum operations he would need to perform to make all the elements of $a$ equal (i.e., he wants all $a_i$ are equal to each other).\nInput The first line contains a single integer $t$ ($1 \\leq t \\leq 3000$) — the number of test cases in the test. Then $t$ test cases follow.\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 3000$) — the length of the array. The next line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^5$) — array $a$.\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3000$.\nOutput For each test case, output a single number — the minimum number of operations that Polycarp needs to perform so that all elements of the $a$ array are the same (equal).\nExample Input 4 5 3 1 6 6 2 4 1 2 2 1 3 2 2 2 4 6 3 2 1 Output 4 2 0 2 Note In the first test case of the example, the answer can be constructed like this (just one way among many other ways):\n$[3, 1, 6, 6, 2]$ $\\xrightarrow[]{i=4,~add~to~left}$ $[3, 1, 12, 2]$ $\\xrightarrow[]{i=2,~add~to~right}$ $[3, 13, 2]$ $\\xrightarrow[]{i=1,~add~to~right}$ $[16, 2]$ $\\xrightarrow[]{i=2,~add~to~left}$ $[18]$. All elements of the array $[18]$ are the same.\nIn the second test case of the example, the answer can be constructed like this (just one way among other ways):\n$[1, 2, 2, 1]$ $\\xrightarrow[]{i=1,~add~to~right}$ $[3, 2, 1]$ $\\xrightarrow[]{i=3,~add~to~left}$ $[3, 3]$. All elements of the array $[3, 3]$ are the same.\nIn the third test case of the example, Polycarp doesn’t need to perform any operations since $[2, 2, 2]$ contains equal (same) elements only.\nIn the fourth test case of the example, the answer can be constructed like this (just one way among other ways):\n$[6, 3, 2, 1]$ $\\xrightarrow[]{i=3,~add~to~right}$ $[6, 3, 3]$ $\\xrightarrow[]{i=3,~add~to~left}$ $[6, 6]$. All elements of the array $[6, 6]$ are the same.\nSolution 可以发现：假设问题存在一个操作次数为 $n - k$ 的解，则整段序列一定可被分解为 $k$ 段子序列，其中每段子序列和为 $(\\sum\\limits_{i=1}^n a[i]) / k$。之后直接模拟即可。\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 /*************************************************************/ #if __cplusplus \u003c 201103L // For jury which unsupports C++11 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003ccmath\u003e #include \u003ccassert\u003e #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cqueue\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(__typeof__(_end) _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(__typeof__(_rbegin) _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #define cfor(_var, _cbegin, _cend, ...) \\ for(__typeof__(_cend) _var = _cbegin; _var != _cend; __VA_ARGS__) #else #include \u003cbits/stdc++.h\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(decay\u003cdecltype(_end)\u003e::type _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(decay\u003cdecltype(_rbegin)\u003e::type _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #endif typedef long long ll; typedef long double ld; #define ABS(x) ((x) \u003e 0 ? (x) : -(x)) const int INF = 0x3f3f3f3f; // #define __DEBUG__ #ifdef __DEBUG__ #if defined _WIN32 #define _WINDEBUG #include \u003cwindows.h\u003e inline std::ostream\u0026 __YELLOW__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_GREEN|FOREGROUND_RED|FOREGROUND_INTENSITY); return s; } inline std::ostream\u0026 __WHITE__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); return s; } inline std::ostream\u0026 __RED__(std::ostream \u0026s) { HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hStdout, FOREGROUND_RED|FOREGROUND_INTENSITY); return s; } #elif defined __linux__ #define _LINUXDEBUG #define __YELLOW__ \"\\033[33;1m\" #define __WHITE__ \"\\033[0m\" #endif #endif #if defined _WINDEBUG || defined _LINUXDEBUG #define ar2vec(_begin, _end) \\ vector\u003cdecay\u003citerator_traits\u003cdecltype(_begin)\u003e::value_type\u003e::type\u003e(_begin, _end) #define debug(x...) \\ do { cout \u003c\u003c __YELLOW__ \u003c\u003c #x \u003c\u003c \" -\u003e \"; err(x); } while(0) void err() { cout \u003c\u003c __WHITE__ \u003c\u003c endl; } template\u003ctypename T, typename... A\u003e void err(T a, A... x) { cout \u003c\u003c __RED__ \u003c\u003c a \u003c\u003c __YELLOW__ \u003c\u003c ' '; err(x...); } template\u003ctemplate\u003ctypename...\u003e class T, typename t, typename... A\u003e void err(T\u003ct\u003e a, A... x) { for(auto\u0026 v : a) cout \u003c\u003c __RED__ \u003c\u003c v \u003c\u003c __YELLOW__ \u003c\u003c ' '; err(x...); } #else #define ar2vec(...) #define debug(...) #endif /*************************************************************/ const int MAXN = 3000; int a[MAXN + 10]; int main() { // freopen(\"test.in\", \"r\", stdin); // freopen(\"test.out\", \"w\", stdout); ios::sync_with_stdio(false); cin.tie(0); int t = 0; cin \u003e\u003e t; while(t--) { int n = 0; cin \u003e\u003e n; for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; int sum = 0; for(int i = 1; i \u003c= n; i++) sum += a[i]; vector\u003cint\u003e div; for(int i = n; i \u003e= 1; i--) if(!(sum % i)) div.push_back(sum / i); for(auto \u0026it : div) { bool flag = true; int seg_sum = 0; for(int i = 1; i \u003c= n; i++) { seg_sum += a[i]; if(seg_sum == it) seg_sum = 0; else if(seg_sum \u003e it) { flag = false; break; } } if(!flag) continue; else { cout \u003c\u003c n - (sum / it) \u003c\u003c endl; break; } } } return 0; } E1. Close Tuples (easy version)","description":"","tags":["Codeforces","Div. 3","题解"],"title":"Codeforces Round #690 (Div. 3) [Personal Summary]","uri":"/posts/codeforces-690-div3%E9%A2%98%E8%A7%A3/"},{"categories":["Reading Notes","MySQL"],"content":"一些关于 SQL 及 MySQL 某些机制的相关笔记。\nSQL 查询语句 select 子句 select 子句用于在所有可能的列中，选择查询结果应当包含哪些列。\n命令格式 SELECT [DISTINCT]/[ALL]\t# 指定是否对行去重，默认为 ALL # 注意对行去重操作需要对数据进行排序，可能相当耗时 [column 1] ([AS] [alias 1]), [column 2] ([AS] [alias 2]), ... # [column] 指定列名或相关的操作，如调用函数、字符串、表达式等 # [alias] 为列指定别名，显示为查询结果中列的标签 # 可以显式地使用 [AS] 关键字阐明为列指定别名的意图，但通常情况下，这是不必要的 [FROM]\t# 仅调用内建函数的情况下不需要使用 FROM 子句，如 SELECT DATABASE(); ...\t# 可添加其他子句，如 WHERE from 子句 from 子句定义查询中所使用的表，及其连接方式。\n命令格式 最普通的使用格式为：\n1 2 3 SELECT [column 1], [column 2], ... FROM [table 1], [table 2], ... ... 也可以在 from 子句中显式地指定表的别名，并在 select 子句中的列名中使用：\n1 2 SELECT [t1.column1], [t1.column2], ... FROM table_1 t1, [table 2] ([alias]), ... from 子句也可指明表连接的方式：\n1 2 SELECT ... FROM [table_1] [INNER]/[LEFT (OUTER)]/[RIGHT (OUTER)]/[FULL (OUTER)]/[CROSS] [JOIN] [table_2] 表的概念 表的概念包含如下三种：\n永久表：存储在数据库中，使用 CREATE TABLE 语句创建的表。 临时表：子查询所返回的表。 虚拟表：使用 CREATE VIEW 语句创建的视图。 以上三种表都可以在 from 子句中使用。\n子查询返回的表 子查询可以出现在 select 子句中的任何部分，使用圆括号进行标示。在 from 语句中，可以使用子查询返回的临时表进行查询，如：\n1 2 3 4 5 SELECT e.emp_id, e.fname, e.lname FROM ( SELECT emp_id, fname, lname, start_date, title FROM employee ) e; 视图 视图是存储在数据字典中的查询，行为表现得像一个表；视图内的数据字段都来源于真实的数据字段。视图只能用于查询，不能对数据进行增删改。\n当对视图发出一个查询时，这个查询会被绑定到视图定义上，以执行最终查询。因此，视图总是显示最近的数据；当用户发出查询时，数据是数据库引擎通过 SQL 语句重建的。\n视图的使用目的一般是为了对用户隐藏列，或者简化数据库设计。\n命令格式 1 2 CREATE VIEW [view_name] AS SELECT ...\t# 内容与 SELECT 子句相同 例：\n1 2 3 CREATE VIEW employee_view AS SELECT emp_id, fname, lname, YEAR(start_date) start_year FROM employee; 之后可直接对视图 employee_view 执行查询：\n1 2 SELECT emp_id, start_year FROM employee_view; where 子句 where 子句用于在查询结果中过滤掉不感兴趣的行。\n命令格式 1 2 3 SELECT ... FROM ... WHERE ([NOT]) [CONDITION 1] ([AND/OR] ([NOT]) [CONDITION 2]) ...\t# 这里的圆括号表示可选 类似其他语言，可以使用圆括号对条件进行分组。\n操作符 between 操作符 between 操作符用于同时限定范围的上下限，用法为 between \u003c下限\u003e and \u003c上限\u003e 。\nbetween 的查询范围是闭区间。\nin 操作符 in 操作符用于检查被查询的值是否属于一个有限集合。例如：\n1 2 3 SELECT account_id, product_id, cust_id, avail_balance FROM account WHERE product_cd IN ('CHK', 'SAV', 'CD', 'MM'); 等价于如下语句：\n1 2 3 SELECT account_id, product_id, cust_id, avail_balance FROM account WHERE product_cd = 'CHK' OR product_cd = 'SAV' OR product_cd = 'CD' OR product_cd = 'MM'; in 操作符也可以被 not 修饰。\nlike 操作符 使用 like 操作符，可以使用通配符构建搜索表达式进行查询。\n例如：\n1 2 3 SELECT lname FROM employee WHERE lname LIKE '_a%a%' regexp 操作符 regexp 操作符接受一个正则表达式做为搜索表达式进行查询。例如：\n1 2 3 SELECT emp_id, fname, lname FROM employee WHERE lname REGEXP '^[FG]'; 对 null 的测试 null 有两个特性：\n表达式的值可以为 null ，但测试 \u003c表达式\u003e = null 总会失败。 两个 null 值不能彼此判断为相等。 想要测试某个表达式的值是否为 null，可以使用IS NULL 操作符：\n1 2 3 SELECT emp_id, fname, lname, superior_emp_id FROM employee WHERE superior_emp_id IS NULL 相应地，可以使用 IS NOT NULL 操作符来判断表达式的值是否不为 NULL。\n需要注意的一点是，当进行普通的条件判断时，值为 NULL 的行可能不会出现在查询结果中；如这个例子中，想要查询所有 superior_emp_id 不为 6 的人：\n1 2 3 SELECT emp_id, fname, lname, superior_emp_id FROM employee WHERE superior_emp_id != 6 将会遗漏某一行的 superior_emp_id 对应值为 NULL 的可能性。因此，为了查询所有 superior_emp_id 不为 6 的人，需要将对 NULL 的判断显式加入条件中：\n1 2 3 SELECT emp_id, fname, lname, superior_emp_id FROM employee WHERE superior_emp_id != 6 AND superior_emp_id IS NOT NULL 使用子查询 子查询的结果也可以做为 where 的条件。例如：\n1 2 3 4 5 6 7 SELECT account_id, product_id, cust_id, avail_balance FROM account WHERE product_cd IN ( SELECT product_cd FROM product WHERE product_type_cd = 'ACCOUNT' ); group by 和 having 子句 group by 子句根据列值对数据进行分组，having 子句对分组数据进行过滤，类似 where 子句。\n命令格式 1 2 3 4 SELECT ... FROM ... GROUP BY [column] HAVING [condition] order by 子句 order by 子句根据某些列值或表达式的计算结果对数据进行排序。\n命令格式 1 2 3 4 SELECT [column 1], [column 2], ... FROM ... ORDER BY [column], ..., [expression], ..., [column id], ... ([ASC]/[DESC]) # ASC 与 DESC 表示排列方式为升序/降序，默认为 ASC order by 根据后面跟随的列名/表达式/列编号，逐个做为第 1 至第 k 关键字对结果进行排序。\norder by 中使用的列编号是 select 中出现的列的顺序编号。\n多表联查 内连接 内连接使用 inner join 标识。\n命令格式 1 2 3 SELECT ... FROM [table 1] ([INNER]) [JOIN] [table 2] ON [CONDITION] 如果 ON 之后的限定条件类似 table_1.column = table_2.column，且两个 column 相同，此时可以改写为\n1 2 3 SELECT ... FROM [table 1] ([INNER]) [JOIN] [table 2] USING [column] 多数情况下，数据库查询引擎能够接受类似如下比较老的内连接语句：\n1 2 3 SELECT e.fname, e.lname, d.name FROM employee e, department d WHERE e.dept_id = d.dept_id 这种语法在 FROM 后将表用逗号隔开，并将连接条件写在 WHERE 内。这种语法在处理较为复杂的多表联查时过于复杂，且难以分清 WHERE 后的条件究竟是连接条件还是过滤条件，也不易于指明连接类型。如以下代码：\n在这里使用三表联查，同时 WHERE 后还有其他过滤条件，显得十分混乱。使用 JOIN 形式书写的查询代码如下：\n立刻变得清晰许多。\n多于两个表的联查 可以对多于两个表进行联查，并且可以对每个表采用不同的连接类型。\n命令格式 1 2 3 4 5 6 SELECT ... FROM [table 1] ([INNER]/[LEFT (OUTER)]/[RIGHT (OUTER)]/[FULL (OUTER)]/[CROSS]) [JOIN] [table 2] ON [CONDITION] (([INNER]/[LEFT (OUTER)]/[RIGHT (OUTER)]/[FULL (OUTER)]/[CROSS]) [JOIN] [table 3] ON [CONDITION]) ... 如以下代码所示：\nSTRAIGHT_JOIN 关键字 一般而言，多个表连接的具体顺序在查询过程中由优化器决定。如果想要手工指定连接方式，可以使用 STRAIGHT_JOIN 关键字。\n","description":"","tags":["MySQL","Database","SQL","读书笔记"],"title":"MySQL相关笔记","uri":"/posts/sql%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Reading Notes","CSAPP"],"content":"CSAPP 第二章主要讲述了整数和浮点数在计算机中的存储与运算方式，及计算机内部表示信息的方式。\n2.2 整数表示 2.2.2 无符号数的编码 考虑一个二进制数值编码 $x$ 由 $w$ 位组成，则我们可以将其拆为由 $w$ 位 $0$ 或 $1$ 表示的位向量 $\\vec{x}$： $$ \\vec{x} = [x_{w-1}, x_{w-2}, \\cdots, x_0],;;x_i \\in {0,1},;;i\\in[0..w-1] $$\n显然地，一个位向量和一个无符号数编码一一对应；定义函数 ${ {\\rm B2U}_w}$，它将位向量转换成对应的无符号数编码： $$ {\\rm B2U}w(\\vec{x}) = \\sum{i=0}^{w-1}x_i2^i $$ 考虑 $w$ 位无符号数编码的取值范围：当 $w$ 位全为 $0$ 时，编码取得最小值 ${\\rm UMin}_w=0$；当 $w$ 位全为 $1$ 时，编码取得最大值，为 ${\\rm UMax}_w = 2^w-1$。\n考虑函数 ${\\rm B2U}w$ 显然是双射，因此随着 $w$ 位无符号数编码按字典序从 $\\underbrace{\\tt 000\\cdots0}{w,,{\\rm zeros} }$ 向 $\\underbrace{\\tt 111\\cdots1}_{w,,{\\rm ones} }$ 遍历，对应的整数值也恰好取遍从 $0$ 到 $2^w-1$ 的每一个值。因此，${\\rm B2U}_w$ 是一个双射 ${0,1}^w \\rightarrow {0,\\cdots,2^w-1}$。\n相应地，我们也可定义 ${\\rm B2U}_w$ 的反函数 ${\\rm U2B}_w$：它将一个 $w$ 位无符号数编码映射成对应的位向量。\n2.2.3 补码编码 无符号数只能表示非负整数。为了表示负数值，我们选择将 $w$ 位编码的最高位解释为负权（negative weight），称为符号位。并定义：当符号位为 $1$ 时，代表数值为负；当符号位为 $0$ 时，代表数值为 $0$ 或正。我们称这种编码形式为（二）补码（two’s-complement）。相应地，我们定义函数 ${\\rm B2T}w$，它将位向量转换成对应的补码编码： $$ {\\rm B2T}w(\\vec{x}) = -x{w-1}2^{w-1} + \\sum{i=0}^{w-2}x_i2^i $$ 从定义中我们可以看到：在补码编码中，低 $(w - 1)$ 位代表的数值仍大于等于 $0$，而整个数值的负号来源是最高位代表的数值 $-2^{w-1}$；这是由于最高位的权重最大，对最高位和低 $(w - 1)$ 位总有 $|-2^{w-1}| \u003e \\sum\\limits_{i=0}^{w-2}1 \\cdot 2^i = 2^{w-1}-1 \\geq \\sum\\limits_{i=0}^{w-2}x_i2^i$，因此只要符号位设为 $1$，整个数值就一定为负。\n由此可以得出 $w$ 位补码编码的取值范围：当符号位为 $1$ 且低 $(w-1)$ 位全为 $0$ ，即编码为 ${\\tt 1}\\underbrace{\\tt 00\\cdots0}_{w-1,,{\\rm zeros} }$ 时，代表的数值最小，为 ${\\rm TMin}w = -2^{w-1}$；当负权被设为 $0$，低 $(w-1)$ 位全为 $1$，即编码为 ${\\tt 0}\\underbrace{\\tt 11\\cdots1}{w-1,,{\\rm ones} }$ 时，代表的数值最大，为 ${\\rm TMax}_w = 2^{w-1}-1$。\n同样易知 ${\\rm B2T}_w$ 是双射 ${0,1}_w \\rightarrow {-2^{w-1},-2^{w-1}+1, \\cdots, 2^{w-1}-1 }$，因此可以定义 ${\\rm B2T}_w$ 的反函数 ${\\rm T2B}_w$。\n容易注意到以下两点：\n$|{\\rm TMin}_w| = |{\\rm TMax}_w| + 1$\n$|{\\rm TMin}_w|$ 没有与之对应的正数，这种不对称性是因为符号位设置为 $0$ 或 $1$ 将 $w$ 位补码的数值表示范围分为两半，其中符号位为 $1$ 时表示的为负数，符号位为 $0$ 时表示的为非负数（包括 $0$）。$0$ 占去了对应 $|{\\rm TMin}_w|$ 的位置。\n${\\rm UMax}_w = 2{\\rm TMax}_w + 1$。\n","description":"","tags":["CSAPP","读书笔记"],"title":"CSAPP第二章读书笔记","uri":"/posts/csapp%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Reading Notes","CSAPP"],"content":"CSAPP 第三章主要以理解 C 语言编译器产生的汇编代码为目的，简要介绍了 x86-64 汇编。\n3.4 访问信息 可以看到对应函数调用的前 6 个参数的寄存器分别是 %rdi，%rsi，%rdx，%rcx，%r8，r9。\n3.5 算术和逻辑操作 下表列出了 x86-64 的一些算术和逻辑操作指令。除 leaq 外，大多数操作都分成了指令类，各自带有不同大小操作数的变种（如 add 分为 addb, addw, addl, addq 四个变种）。这些指令被分为四类：加载有效地址、一元操作、二元操作、移位。\n3.5.1 加载有效地址 leaq （load effective address，加载有效地址）指令是 movq 指令的变体，用来将某个有效内存地址写入对应寄存器，作用类似 C 语言的取地址运算符 \u0026。这条指令可以为后面的内存引用产生指针。leaq 的目的操作数只能是寄存器。\n在此之外，leaq 也常被用于进行一些简单的算术操作，如若 %rdx 的值被设为 $x$，则 leaq 7(%rdx, %rdx, 4), %rax 将 %rax 的值设为 $5x+7$，此时 leaq 的作用完全与有效地址计算无关。GCC 等编译器特别倾向于使用 leaq 指令处理简单的算术操作。\n作为说明，下面这段 C 程序将会被编译成如下三条 leaq 指令实现的汇编代码；注意 x，y，z 对应的寄存器按顺序分别是 %rdi, %rsi, %rdx。\n1 2 3 4 long scale(long x, long y, long z) { long t = x + 4 * y + 12 * z; return t; } 1 2 3 4 5 scale: leaq (%rdi, %rsi, 4), %rax\t# x + 4 * y leaq (%rdx, %rdx, 2), %rdx\t# z + 2 * z = 3 * z leaq (%rax, %rdx, 4), %rax\t# (x + 4 * y) + 4 * (3 * z) = x + 4 * y + 12 * z ret ${\\bf N{\\scriptsize OTE}}.$ 注意 GNU assembler 使用 # 处理单行注释。\n之所以这样做，是因为 Intel 处理器有一个专门的地址运算单元，leaq 的运行不必经过 ALU，只需要单个时钟周期，显然比使用乘法指令 imul 要快得多。\n练习题 3.6 表达式 结果 leaq 6(%rax), %rdx $x + 6$ leaq (%rax, %rcx), %rdx $x + y$ leaq (%rax, %rcx, 4), %rdx $x + 4y$ leaq 7(%rax, %rax, 8), %rdx $7 + 9x$ leaq 0xA(, %rcx, 4), %rdx ${\\tt 0xA} + 4y$ leaq 9(%rax, %rcx, 2), %rdx $9 + x + 2y$ 练习题 3.7 5 * x + 2 * y + 8 * z\n3.5.2 一元和二元操作 一元操作符的操作数只有 1 个，可以是寄存器/内存位置。\n二元操作符的操作数有 2 个，第一个操作数可以是立即数/寄存器/内存位置，第二个操作数可以是寄存器/内存位置；注意第二个操作数同时为源操作数和目的操作数。\n练习题 3.8 指令 目的 值 addq %rcx, (%rax) ${\\tt 0x100}$ ${\\tt 0x100}$ subq %rdx, 8(%rax) ${\\tt 0x108}$ ${\\tt 0xA8}$ imulq $16, (%rax, %rdx, 8) ${\\tt 0x118}$ ${\\tt 0x110}$ incq 16(%rax) ${\\tt 0x110}$ ${\\tt 0x14}$ decq %rcx %rcx ${\\tt 0x0}$ subq %rdx, %rax %rax ${\\tt 0xFD}$ 3.5.3 移位操作 移位指令先给出移位量，再给出要移位的量。其中，移位量可以是一个立即数或单字节寄存器 %cl（不能是其他寄存器），目的操作数可以是一个寄存器或内存位置。\n当移位量为 %cl 时，具体的移位量由 %cl 的低 $m$ 位决定：当移位操作对 $w$ 位的数据进行操作时，$m$ 通过 $2^m=w$ 来确定。\n例如：当 %cl 的值为 ${\\tt 0xFF = 0b1111,1111}$ 时，根据使用的指令不同，分别有：\n使用 salb 指令时，操作数据长度为 8 位，此时有 $m = 3$，即位移量为低 3 位 ${\\tt 0b111 = 7}$。 使用 salw 指令时，操作数据长度为 16 位，此时有 $m = 4$，即位移量为低 4 位 ${\\tt 0b1111 = 15}$。 使用 sall 指令时，操作数据长度为 32 位，此时有 $m = 5$，即位移量为低 5 位 ${\\tt 0b0001,1111 = 31}$。 使用 salq 指令时，操作数据长度为 64 位，此时有 $m = 6$，即位移量为低 6 位 ${\\tt 0b0011,1111 = 63}$。 移位指令中，sal，shl，sar，shr 指令分别代表算术左移、逻辑左移、算术右移、逻辑右移，其中算术左移与逻辑左移的效果是相同的；算术右移的效果为用符号位填充空位，逻辑右移的效果为用 0 填充空位。\n练习题 3.9 salq $4, %rax\nsarq %cl, %rax\n3.5.4 讨论 可以看到上述算术/逻辑操作指令大多数可同时用于有符号和无符号运算，只有右移操作要求显式区分有符号和无符号数；这个特性也是采用补码运算作为有符号整数运算的比较好的原因之一。\n考虑以下 C 语言代码将会被编译成的汇编代码：\n1 2 3 4 5 6 7 long arith(long x, long y, long z) { long t1 = x ^ y; long t2 = z * 48; long t3 = t1 \u0026 0x0F0F0F0F; long t4 = t2 - t3; return t4; } 这里的每一句 C 源代码都紧密地对应一句或多句汇编指令。将其写成对应的汇编代码：\n1 2 3 4 5 6 7 arith: xorq %rsi, %rdi\t# t1 = x ^ y leaq (%rdx, %rdx, 2), %rax\t# z + 2 * z = 3 * z salq $4, %rax\t# t2 = (3 * z) \u003c\u003c 4 = 16 * (3 * z) = 48 * z andl $252645135, %edi\t# t3 = 0x0F0F0F0F \u0026 (x ^ y) subq %rdi, %rax\t# t2 - t3 ret 汇编代码中有值得注意的以下两点：\n使用了两条 leaq 和移位指令来计算小的乘法。 因为 0x0F0F0F0F 是一个双字长，因此使用 andl 和 %edi 参与运算。 练习题 3.10 1 2 3 4 5 6 7 long arith2(long x, long y, long z) { long t1 = x | y; long t2 = t1 \u003e\u003e 3; long t3 = ~t2; long t4 = z - t3; return t4; } 练习题 3.11 A. 将 %rdx 清零。这是因为对任何 $x$，有 ${\\rm XOR}(x,x) = 0$。\nB. movq $0, %rdx\nC. 在 WSL(Ubuntu 20.04, Intel i5-3470) 平台上使用如下汇编代码编译目标文件：\n1 2 3 a: xorq %rdx, %rdx b: movq $0, %rdx c: nop 使用 objdump 反汇编得：\nfile.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u003ca\u003e: 0: 48 31 d2 xor %rdx,%rdx 0000000000000003 \u003cb\u003e: 3: 48 c7 c2 00 00 00 00 mov $0x0,%rdx 000000000000000a \u003cc\u003e: a: 90 nop 可见两条指令编码长度分别为 3 字节和 7 字节。\n${\\bf N{\\scriptsize OTE}}.$ 此外，通过使用「生成 4 字节值并以寄存器作为目的操作数的指令会将高 4 字节置为 0」的特性，可以使用 xorl 和 movl 指令进一步压缩长度。\n如：将如下汇编代码编译为目标文件：\n1 2 3 a: movl $0, %eax b: xorl %eax, %eax c: nop 使用 objdump 反汇编得：\ntest.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u003ca\u003e: 0: b8 00 00 00 00 mov $0x0,%eax 0000000000000005 \u003cb\u003e: 5: 31 c0 xor %eax,%eax 0000000000000007 \u003cc\u003e: 7: 90 nop 可见 xorl 和 movl 指令只分别需要 2 字节和 5 字节。\n关于「生成 4 字节值并以寄存器作为目的操作数的指令会将高 4 字节置为 0」这一特性的效果，可以使用 gdb 进行测试：先编译如下代码：\n1 2 3 4 5 6 7 8 .section .text .globl _start _start: movq $0xABCDABCDABCDABCD, %rax xorl %eax, %eax movq $3, %rax xorl %eax, %eax nop 使用如下指令进行编译（--gstabs+ 参数用于保留符号信息，用于调试）：\n1 2 as -o test.o test.s --gstabs+ ld -o test test.o 使用 gdb 进行调试，在 _start 处加断点，并使用 i register \u003c寄存器名称\u003e 打印寄存器的值：\nCopyright (C) 2020 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u003chttp://gnu.org/licenses/gpl.html\u003e This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"x86_64-linux-gnu\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: \u003chttp://www.gnu.org/software/gdb/bugs/\u003e. Find the GDB manual and other documentation resources online at: \u003chttp://www.gnu.org/software/gdb/documentation/\u003e. For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from testtest... (gdb) b _start Breakpoint 1 at 0x401000: file testtest.s, line 4. (gdb) run Starting program: /mnt/d/programming/tempanswertest/testtest Breakpoint 1, _start () at testtest.s:4 4 movq $0xABCDABCDABCDABCD, %rax (gdb) i registers rax rax 0x0 0 (gdb) s 5 xorl %eax, %eax (gdb) i registers rax rax 0xabcdabcdabcdabcd -6067004223159161907 (gdb) s 6 movq $3, %rax (gdb) i registers rax rax 0x0 0 (gdb) s 7 xorl %eax, %eax (gdb) i registers rax rax 0x3 3 (gdb) s 8 nop (gdb) i registers rax rax 0x0 0 (gdb) s Warning: Cannot insert breakpoint 0. Cannot access memory at address 0x1 0x0000000000401016 in ?? () 3.5.5 特殊的算术操作 考虑两个 $w$ 位无符号整数 $x,y$ （$0 \\leq x,y \\leq 2^w - 1$），则有 $0 \\leq x \\cdot y \\leq (2^w - 1)^2 = 2^{2w}-2^{w+1}+1$，也即 $x \\cdot y$ 最多要用 $2w$ 位来表示；\n同样地，考虑两个 $w$ 位有符号整数 $x, y$（$-2^{w-1} \\leq x,y \\leq 2^{w-1}-1$），则有 $$ -2^{w-1} \\cdot (2^{w-1}-1) \\leq x \\cdot y \\leq (-2^{w-1})^2 $$ 即 $$ -2^{2w-2}+2^{w-1} \\leq x \\cdot y \\leq 2^{2w-2} $$ 最多需要 $2w-2$ 位；但是，考虑到计算机内寄存器的数位长度通常以 2 为倍数进行倍增，可以认为无论有/无符号，$x \\cdot y$ 均需最多 $2w$ 位进行表示。\n因此，x86-64 指令集对长度为 128 位的八字（oct word）提供了有限支持。\n在这组指令中，%rdx 和 %rax 共同组成一个 128 位的八字。\n在这组指令中，有两条单操作数乘法指令 imulq 和 mulq，都要求将一个参数预存在 %rax 中，并将乘积结果的低 64 位放在 %rax 中，将高 64 位放在 %rdx 中。同时，x86-64 指令集还提供一个双操作数乘法指令 imulq（与单操作数乘法指令名称相同），如图 3-10 所示；但运算结果只截取低 64 位，和 C 语言的无符号/补码乘法运算相同（参考 2.3）。在只截取低 64 位的情况下，无符号/乘法运算结果的二进制位表示是相同的，因此只需要一条指令即可处理。\n${\\bf N{\\scriptsize OTE}}.$ 证明：$w$ 位的无符号乘法和补码乘法结果的二进制位表示相同。\n考虑对位向量 $\\vec{x} = [x_{w-1},x_{w-2},\\cdots,x_0],,,x_i \\in {0,1},,,i=0,1,\\cdots,w-1$，\n$\\vec{x}$ 对应的无符号编码的值表示为 $$ x_u = \\sum_{i=0}^{w-1}x_i2^i $$ $\\vec{x}$ 对应的补码编码的值表示为 $$ x_t = -x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}x_i2^i $$ 显然有 $$ x_u = x_t + x_{w-1}2^w $$ 因此，设 $x,y$ 是 $w$ 位无符号整数，则其对应的补码编码的值分别为 $x’ = x + x_{w-1}2^w$，$y’ = y + y_{w-1}2^w$。此时，考虑 $x’$ 与 $y’$ 的乘积截取低 $w$ 位的结果得：\n$$ \\newcommand{\\modop}{,{\\rm mod},} \\begin{aligned} (x’ \\cdot y’)\\modop2^w \u0026= [(x + x_{w-1}2^w) \\cdot (y + y_{w-1}2^w)] \\modop 2^w \\ \u0026= [(x \\cdot y) + x \\cdot y_{w-1}2^w + y \\cdot x_{w-1}2^w + x_{w-1}y_{w-1}2^{2w}] \\modop 2^w \\ \u0026= (x \\cdot y) \\modop 2^w \\end{aligned} $$\n证毕。\n有/无符号整数除法指令 idivq 和 divq 只有单操作数版本，它们都将 %rax 作为被除数的低 64 位，%rdx 作为被除数的高 64 位；并把计算结果的商放在 %rax 中，余数放在 %rdx 中。\n在有符号运算的情况，可以用指令 cqto 将四字符号扩展到八字：被扩展的低 64 位值放在 %rax 中，指令会根据其符号位自动填充 %rdx 中的高 64 位值。如果有符号除法指令中的被除数是一个 64 位的值，则需要提前用 cqto 将其符号扩展至 128 位；无符号除法中则需要手动将 %rdx 置为 0。\n练习题 3.12 1 2 3 4 5 6 7 8 uremdiv: movq %rdx, %r8 movq %rdi, %rax xorq %rdx, %rdx divq %rsi movq %rax, (%r8) movq %rdx, (%rcx) ret 3.6 控制 3.6.1 条件码 常用的条件码寄存器有如下几个：\n图 3-10 中，除了 leaq 外的所有指令都会重新设置条件码寄存器。\n此外，某些操作有一些特殊的行为：\n逻辑操作，例如 xor，会将 CF 和 OF 设置为 0。 移位操作会将 CF 设置为最后一个被移出的位，OF 设置为 0。 inc 和 dec 指令会设置 OF 和 ZF 标志，但是不会改变 CF 标志。 还有 cmp 和 test 两类指令会设置条件码但不修改任何其他寄存器：\n其中，cmp 指令和 sub 指令的行为是一样的，test 指令和 and 指令的行为是一样的。\n当 test 指令的两个操作数相同时，可以用来判断一个值是负数，0，还是正数（例如，对 %rax 使用 testq %rax, %rax）；test 指令也可配合一个掩码来指定测试一个值中的某些位。\n3.6.2 访问条件码","description":"","tags":["CSAPP","读书笔记"],"title":"CSAPP第三章读书笔记","uri":"/posts/csapp%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Reading Notes","CSAPP"],"content":"CSAPP第五章的读书笔记。\n5.2 表示程序性能 引入度量程序性能的指标：每元素的周期数（CPE，Cycles Per Element）。通常使用时钟周期作为过程执行的长度的度量单位。\n许多过程含有在一组元素上迭代的循环，设被处理元素个数为 $n$，此时过程执行时间和 $n$ 近似成线性关系 $kn + b$。此时称线性因子 $k$ 为 CPE 的有效值。当 $n$ 较大时，过程的运行时间就会主要由 $k$ 决定。\n我们的关注重点在于给定的向量长度而不是循环次数，因为循环次数可以采用诸如循环展开之类的技巧进行优化。因此，我们的关注点为每元素的周期数而非每次循环的周期数。\n${\\bf N{\\scriptsize OTE}}.$ 这个概念和算法的时间复杂度无关，因为 CPE 关注的是过程在给定的向量长度上的执行性能。\n练习题 5.2 绘制图像得：\n易得：\n当 $x \\in [0..2]$ 时，$60 + 35n$ 最快； 当 $x \\in [3..7]$ 时，$136 + 4n$ 最快； 当 $x \\geq 8$ 时，$157 + 1.25n$ 最快。 5.4 消除循环的低效率 代码移动（code motion）是一个常见的优化例子，它识别要重复执行多次（例如在循环内）但结果不会改变的计算，并将其移动至该重复进行的过程之前。\n例子：对长度为 $n$ 的字符串 s 而言，以下代码执行的时间复杂度是 $O(n^2)$：\n1 for(int i = 0; i \u003c strlen(s); i++); 通过将 strlen 函数移动至循环之前，可以将这一过程的时间复杂度优化到 $O(n)$：\n1 2 int len = strlen(s); for(int i = 0; i \u003c len; i++); 练习题 5.3 代码 min max incr square A. 1 91 90 90 B. 91 1 90 90 C. 1 1 90 90 5.5 减少过程调用 循环内的过程调用会增加开销。如果能将减少循环中的函数调用，会对提升性能有所帮助。\n以边界检查为例，数组访问时进行边界检查将会很大程度上损害程序的性能。但是，在处理器分支预测的帮助下，边界检查造成的性能影响有可能被克服：在 combine3 函数中，从循环中去除了 get_vec_element 函数后，程序并未产生明显的性能提升；这是因为在这段程序中，不可能产生数组越界问题，因此 get_vec_element 总是确定索引在界内，因此这个过程是高度可预测的。\n${\\bf N{\\scriptsize OTE}}.$ 书中实例代码的安全性问题：\n在 combine3 之前的版本，循环过程是按如下方式进行的：\n1 2 3 4 5 for(i = 0; i \u003c length; i++) { data_t val; get_vec_element(v, i, \u0026val); *dest = *dest OP val; } 可以看到 get_vec_element 的返回值并没有被使用，边界检查对运算结果造成的唯一影响就是在索引越界时，val 将不会被赋值。然而，这一点是危险的，因为 val 并没有被赋初值：这意味着一个随机的垃圾值将参与运算，同样引发了 UB 行为。多余的边界检查在影响性能的同时，反倒造成了更大的不安全性。\n5.6 消除不必要的内存引用 寄存器的读写速度远快于内存，如果能将重复的大量内存读写改为读写寄存器，将能有效提升程序性能。例如，示例代码在每次循环中都直接使用 dest 参与运算，导致每次循环都需要进行一次多余的内存 R/W 操作；如果用一个中间变量 acc 代替 dest 参与运算，仅在循环结束后将运算结果写入 dest， 性能将产生十分显著的提高。\n很多情况下，由于内存别名的因素，编译器不能把内存引用转化为等价的寄存器调用。如，考虑如下例子：\n考虑 data_t 为 long， OP 为 *，IDENT 为 1，对 v = $[2,3,5]$ 按如下方式分别进行调用：\n1 2 combine3(v, get_vec_start(v) + 2); combine4(v, get_vec_start(v) + 2); 由于 combine3 每次运算时都将结果写入 v[2]，会造成这样的行为差异：\n函数 初始值 循环之前 i = 0 i = 1 i = 2 最后 combine3 $[2,3,5]$ $[2,3,1]$ $[2,3,2]$ $[2,3,6]$ $[2,3,36]$ $[2,3,36]$ combine4 $[2,3,5]$ $[2,3,5]$ $[2,3,5]$ $[2,3,5]$ $[2,3,5]$ $[2,3,30]$ 由于事先无法判断函数会在哪里被调用以及程序员设计的真实意图，在比较保守的优化级别（如 -O1 ）下，combine3 中的内存引用不会被优化。\n练习题 5.4","description":"","tags":["CSAPP","读书笔记"],"title":"CSAPP第五章读书笔记","uri":"/posts/csapp%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Programming Contest","LeetCode","String"],"content":"introduction\n","description":"","tags":null,"title":"Leetcode-767-重构字符串","uri":"/posts/leetcode-767-%E9%87%8D%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Programming Contest","Leetcode","Data Structure"],"content":"一道逆序对的变体题目，稍作改变即可解决。\n题面 给定一个数组 nums ，如果 i \u003c j 且 nums[i] \u003e 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。\n你需要返回给定数组中的重要翻转对的数量。\n示例 1:\n输入: [1,3,2,3,1] 输出: 2\n示例 2:\n输入: [2,4,3,5,1] 输出: 3\n注意:\n给定数组的长度不会超过50000。 输入数组中的所有数字都在32位整数的表示范围内。 题解 归并排序 讲解 在归并排序的过程中利用两个数组均为有序的特性，用两个指针分别指向 ${\\rm mid}$ 和 ${\\rm r}$ 处并不断向左移动，过程中即可统计翻转对。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class Solution { #define COUT(x) #x \u003c\u003c \"-\u003e\" \u003c\u003c (x) \u003c\u003c \" \" public: int cnt; int reversePairs(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); if(!n) return 0; vector\u003cint\u003e helper(n); cnt = 0; mergeSort(nums, helper, 0, n - 1); return cnt; } void mergeSort(vector\u003cint\u003e \u0026a, vector\u003cint\u003e \u0026b, int l, int r) { if(l == r) return; int mid = (l + r) / 2; mergeSort(a, b, l, mid); mergeSort(a, b, mid + 1, r); for(int i = mid, j = r; i \u003e= l \u0026\u0026 j \u003e= mid + 1; i--) { bool flag = false; while(j \u003e= mid + 1) { if((long long)a[i] \u003e 2LL * a[j]) { flag = true; break; } j--; } if(flag) { cnt += (j - mid); } } int i = l, j = mid + 1; for(int k = l; k \u003c= r; k++) { if(j \u003e r || i \u003c= mid \u0026\u0026 a[i] \u003c= a[j]) { b[k] = a[i++]; } else { b[k] = a[j++]; } } for(int k = l; k \u003c= r; k++) a[k] = b[k]; } }; 树状数组★ 讲解 与通常的树状数组维护逆序对不同，这里需要维护的是 ${\\rm nums}[i]$ 与 $2\\cdot{\\rm nums}[j]$ 的关系，因此需要做如下变动：\n记 $n={\\rm nums.size()}$，先将 ${ { {\\rm nums}[i],,2\\cdot{\\rm nums}[i];;|;;0 \\leq i \u003c n } }$ 离散化，记为 $m$；之后以 $[1..2n]$ 初始化树状数组；\n此时，对每个 $j;(0 \\leq j \u003c n)$，我们试图统计 ${\\rm nums}[j]$ 左侧大于 $2 \\cdot {\\rm nums}[j]$ 的数目。因此我们正向扫描 ${\\rm nums}$，并在过程中对于每个 $j$：\n计算 ${\\rm ask}(2n) - {\\rm ask}(m[2 \\cdot {\\rm nums}[j]])$，这是 ${\\rm nums}[j]$ 之前被扫描过的，大于 $2 \\cdot {\\rm nums}[j]$ 的数目； ${\\rm add}(m[{\\rm nums}[j]], 1)$。 这样一边扫描一边更新，即可得出所有翻转对个数。\n另外，由于离散化需要排序，树状数组做法的常数比归并排序大。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Solution { #define COUT(x) #x \u003c\u003c \"-\u003e\" \u003c\u003c (x) \u003c\u003c \" \" public: struct BinTree { vector\u003cint\u003e c; int n; BinTree(int _size): n(_size) { c.resize(_size + 1); } static constexpr int lowbit(int x) { return (x \u0026 (-x)); } int ask(int x) { int ans = 0; for( ; x; x -= lowbit(x)) ans += c[x]; return ans; } void add(int x, int y) { for( ; x \u003c= n; x += lowbit(x)) c[x] += y; } }; int reversePairs(vector\u003cint\u003e\u0026 nums) { int n = (int)nums.size(); set\u003clong long\u003e s; for(int i = 0; i \u003c n; i++) { s.insert(nums[i]); s.insert(2LL * nums[i]); } unordered_map\u003clong long, int\u003e m; int cnt = 0; for(auto \u0026it : s) { m.insert(make_pair(it, ++cnt)); } BinTree t(cnt); int ans = 0; for(int i = 0; i \u003c n; i++) { int right = t.ask(cnt); int left = t.ask(m[2LL * nums[i]]); ans += right - left; t.add(m[nums[i]], 1); } return ans; } }; ","description":"","tags":["Leetcode","Hard","逆序对","归并排序","树状数组"],"title":"[Leetcode 493]翻转对（逆序对，归并排序/树状数组）","uri":"/posts/leetcode-493-%E7%BF%BB%E8%BD%AC%E5%AF%B9/"},{"categories":["Programming Contest","Leetcode","Linked List"],"content":"第一次做链表相关的题，虽然是个水题，还是记录一下。\n题面 给你一个链表数组，每个链表都已经按升序排列。\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n示例 1：\n输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 解释：链表数组如下： [ 1-\u003e4-\u003e5, 1-\u003e3-\u003e4, 2-\u003e6 ] 将它们合并到一个有序链表中得到。 1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4-\u003e5-\u003e6\n示例 2：\n输入：lists = [] 输出：[]\n示例 3：\n输入：lists = [[]] 输出：[]\n提示：\nk == lists.length 0 \u003c= k \u003c= 10^4 0 \u003c= lists[i].length \u003c= 500 -10^4 \u003c= lists[i][j] \u003c= 10^4 lists[i] 按 升序 排列 lists[i].length 的总和不超过 10^4 题解 用优先队列维护 $k$ 个元素中的当前最小值即可。假设所有链表长度均为 $n$，因为优先队列单次插入/弹出复杂度为 $O({\\rm log}k)$，故时间复杂度为 $O(nk{\\rm log}k)$。\n注意：vector 内不能存放元素的引用，只能存放指针。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: struct cmp { bool operator () (const ListNode *a, const ListNode *b) { return a-\u003eval \u003e b-\u003eval; } }; const int INF = 0x3f3f3f3f; ListNode* mergeKLists(vector\u003cListNode*\u003e\u0026 lists) { ListNode head(INF, nullptr); ListNode *now = \u0026head; priority_queue\u003cListNode *, vector\u003cListNode *\u003e, cmp\u003e q; int k = lists.size(); for(int i = 0; i \u003c k; i++) { if(lists[i] != nullptr) { q.push(lists[i]); } } while(!q.empty()) { now-\u003enext = q.top(); now = now-\u003enext; q.pop(); if(now-\u003enext != nullptr) { q.push(now-\u003enext); } } return head.next; } }; ","description":"","tags":["Leetcode","Hard","链表","优先队列"],"title":"[Leetcode 23]合并K个升序链表（优先队列）","uri":"/posts/leetcode-23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["Math","Calculus"],"content":"在此记录高等数学中涉及的三类中值定理及其证明。\n涉及函数的中值定理 ${\\bf N{\\scriptsize OTE}}.$ 极值定理与介值的定理涉及实数完备性与 Bolzano–Weierstrass 定理的内容，超出一般高等数学的范围，在此不予列出。\n${\\bf T {\\scriptsize HEROREM};1}.$ 极值定理 该定理分为两部分进行叙述：\n${\\bf T{\\scriptsize HEROREM};1.1}.$ 有界性定理 设 $f(x)$ 在 $[a,b]$ 上连续，则 $\\exists, m,M \\in \\mathbb{R}$ 使得对 $\\forall x \\in [a,b]$ 有 $m \\leq f(x) \\leq M$。\n${\\bf T{\\scriptsize HEROREM};1.2}.$ 极值定理 设 $f(x)$ 在 $[a,b]$ 上连续，则 $\\exists, c,d \\in [a,b]$ 使得对 $\\forall x \\in [a,b]$ 有 $f(c) \\leq f(x) \\leq f(d)$。\n${\\bf T {\\scriptsize HEROREM};2}.$ 介值定理 设 $f(x)$ 在 $[a,b]$ 上连续，记 $A=\\min{(f(a),f(b))}$，$B=\\max{(f(a),f(b))}$，则对 $\\forall C \\in (A,B)$ 均 $\\exists \\xi \\in (a,b)$ 使得 $f(\\xi) = C$。\n${\\bf C{\\scriptsize OROLLARY};2.1}.$ 设 $f(x)$ 在 $[a,b]$ 上连续且有最大值 $M$ 及最小值 $m$，则对 $\\forall \\mu \\in [m,M]$，$\\exists \\xi \\in [a,b]$ 使得 $f(\\xi)=\\mu$。\n${\\bf T {\\scriptsize HEROREM};3}.$ 零点定理 设 $f(x)$ 在 $[a,b]$ 上连续且 $f(a) \\cdot f(b) = 0$，则 $\\exists \\xi \\in (a,b)$ 使得 $f(\\xi) = 0$。\n${\\bf P{\\scriptsize ROOF}}.$ 这是介值定理的直接推论。\n${\\bf T {\\scriptsize HEROREM};4}.$ 平均值定理 设 $f(x)$ 在 $[a,b]$ 上连续且有 $a \u003c x_1 \u003c x_2 \u003c \\cdots \u003c x_n \u003c b$，则 $\\exists \\xi \\in [x_1, x_n]$ 使得 $f(\\xi) = \\dfrac{\\sum\\limits_{i=1}^{n}f(x_i)}{n}$。\n${\\bf P{\\scriptsize ROOF}}.$ 设 $f(x)$ 在 $[x_1, x_n]$ 中分别取得最小值 $m$ 和最大值 $M$，则由介值定理，只需证明 $$ m \\leq \\frac{\\sum\\limits_{i=1}^{n}f(x_i)}{n} \\leq M $$ 又，易得 $$ n \\cdot \\min_{i=1}^n f(x_i) \\leq \\sum_{i=1}^{n}f(x_i) \\leq n \\cdot \\max_{i=1}^{n}f(x_i) $$ 即 $$ m \\leq \\min_{i=1}^{n}f(x_i) \\leq \\frac{\\sum\\limits_{i=1}^{n}f(x_i)}{n} \\leq \\max_{i=1}^{n}f(x_i) \\leq M $$ 证毕。\n微分中值定理 ${\\bf L{\\scriptsize EMMA};5.}$ 费马引理 设 $f(x)$ 在 $[a,b]$ 上连续，在 $x_0 \\in [a,b]$ 处可导且取极值，则 $f’(x_0)=0$。\n${\\bf P{\\scriptsize ROOF}}.$ 不妨设 $f(x)$ 在 $x_0$ 处取极大值，则对 $\\forall x \\in {\\rm U}(x_0, \\delta)$，有 $$ f(x) - f(x_0) \\leq 0 $$ 因此有 $$ f’+(x_0) = \\lim{x \\rightarrow x_0^+}\\frac{f(x)-f(x_0)}{x-x_0} \\leq 0 $$\n$$ f’-(x_0) = \\lim{x \\rightarrow x_0^-}\\frac{f(x) - f(x_0)}{x - x_0} \\geq 0 $$\n又，由 $f(x)$ 在 $x=x_0$ 处可导，有 $f’(x_0) = f’+(x_0) = f’-(x_0) = 0$。\n证毕。\n${\\bf T{\\scriptsize HEROEM};6}.$ 罗尔定理 设 $f(x)$ 在 $[a,b]$ 上连续，在 $(a,b)$ 内可导，且 $f(a)=f(b)$，则 $\\exists \\xi \\in (a,b)$，使得 $f’(\\xi) = 0$。\n${\\bf P{\\scriptsize ROOF}}.$ 设 $f(a)=f(b)=A$，则易得 $\\exists c \\in (a,b)$ 使得 $f(c) \\neq A$；否则，在 $(a,b)$ 内 $f(x)$ 是常函数，此时对 $\\forall x \\in (a,b)$ 总有 $f’(x)=0$ 成立。\n又，由极值定理，$f(x)$ 在 $[a,b]$ 内必取得最大值与最小值。因为 $f(a)=f(b)$ 且 $f(x)$ 不是常函数，故 $f(x)$ 在 $(a,b)$ 内必取得极大值或极小值；不妨设 $f(x)$ 在 $x=\\xi$ 处取得极大值，由费马引理，有 $f’(\\xi)=0$ 成立。\n证毕。\n以下列出罗尔定理在开区间或无穷区间上的诸种推广形式，这些推广形式的证明方式大同小异，均是使用介值定理在开区间一侧重新构造出闭区间。\n${\\bf C{\\scriptsize OROLLARY};6.1}.$ 半无界区间上的有界函数 ${\\bf C{\\scriptsize OROLLARY};6.1.1}.$ 设 $f(x)$ 在 $[a, +\\infty)$ 上连续，在 $(a, \\infty)$ 上可导，且有 $f(a)=f(+\\infty)=A\\in\\mathbb{R}$，则 $\\exists \\xi \\in (a, +\\infty)$ 使得 $f’(\\xi)=0$。\n${\\bf C{\\scriptsize OROLLARY};6.1.2}.$ 设 $f(x)$ 在 $(-\\infty, a]$ 上连续，在 $(-\\infty, a)$ 上可导，且有 $f(a)=f(-\\infty)=A\\in\\mathbb{R}$，则 $\\exists \\xi \\in (-\\infty, a)$ 使得 $f’(\\xi)=0$。\n${\\bf P{\\scriptsize ROOF}}.$ 在此仅证明 ${\\bf C{\\scriptsize{OROLLARY}};6.1.1}$。\n若 $\\exists x_0 \\in (a,+\\infty)$ 使得 $f(x_0)=f(a)=A$，则由罗尔定理，原命题立即得证；\n否则，必然 $\\exists b \\in (a,+\\infty)$ 使得 $f(b)=B\\neq A$。不妨假设 $B\u003eA$，则由介值定理，对 $\\forall C \\in (A,B)$，均 $\\exists c_1 \\in (a,b)$ 使得 $f(c_1)=C$。\n此时，由 $f(+\\infty)=A$，可知对于 $\\epsilon=\\dfrac{C-A}{2}$，$\\exists X\u003ea$ 使得对于 $\\forall x \u003e X$ 均有 $|f(x)-A|\u003c\\epsilon=\\dfrac{C-A}{2}$；\n展开上式，有 $$ \\frac{3A-C}{2} \u003c f(x) \u003c \\frac{A+C}{2} \u003c C $$ 因此，取 $d \u003e X$，则有 $f(d) \u003c C$；由介值定理，则有 $c_2 \\in (b,d)$ 使得 $f(c_2)=C$ 成立。此时有 $f(c_1)=f(c_2)=C$，由罗尔定理，原命题立即得证。证毕。\n${\\bf C{\\scriptsize OROLLARY};6.2}.$ 半无界区间上的无界函数 ${\\bf C{\\scriptsize OROLLARY};6.2.1}.$ 设 $f(x)$ 在 $[a, +\\infty)$ 上连续，在 $(a, +\\infty)$ 上可导，且有 $f(a)=f(+\\infty)=\\pm\\infty$，则 $\\exists \\xi \\in (a,+\\infty)$ 使得 $f’(\\xi)=0$。\n${\\bf C{\\scriptsize OROLLARY};6.2.2}.$ 设 $f(x)$ 在 $(-\\infty, a]$ 上连续，在 $(-\\infty, a)$ 上可导，且有 $f(a)=f(-\\infty)=\\pm\\infty$，则 $\\exists \\xi \\in (-\\infty, a)$ 使得 $f’(\\xi)=0$。\n${\\bf P{\\scriptsize ROOF}}.$\n在此仅证明 ${\\bf C{\\scriptsize{OROLLARY}};6.2.1}$。\n${\\bf C{\\scriptsize OROLLARY};6.4}.$ 有界区间上的无界函数 设 $f(x)$ 在 $(a,b)$ 上连续可导，且 $\\lim\\limits_{x\\rightarrow a^+}f(x)=\\lim\\limits_{x\\rightarrow b^-}f(x)=\\pm \\infty$，则 $\\exists \\xi \\in (a,b)$ 使得 $f’(\\xi)=0$。\n${\\bf P{\\scriptsize ROOF}}.$\n","description":"","tags":["中值定理","高等数学"],"title":"几项中值定理及其证明","uri":"/posts/%E5%87%A0%E9%A1%B9%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E7%9A%84%E8%AF%81%E6%98%8E/"},{"categories":["Computer Science","Visual Tracking"],"content":"最近开始看 CSR-DCF 这篇论文，有一些公式推导及不懂的地方记在此处。\n公式推导 公式 (3) 的推导 ${\\bf N{\\scriptsize OTE}}.$\n原公式中后半部分的 $\\lambda\\sum\\limits_{d=1}^{N_c}\\left|{\\bf \\hat{h}}\\right|2^2$ 似不正确，以下都修正为 $\\lambda\\sum\\limits{d=1}^{N_c}\\left|{\\bf \\hat{h}_d}\\right|_2^2$。但修正后的结果与公式(5)冲突（公式(5)相对(3)的唯一区别只在此处，若进行此修正，则公式(5)无单独列出的意义；但不进行此修正，则无法推导(3)得出结果(4)。\n原公式为\n对 $\\hat{\\bf h}_d$ 进行求导：\n分别对两部分进行求导：\n令 ${\\bf c} = \\sum\\limits_{d=1}^{N_c}\\hat{\\bf f}_d \\odot \\overline{\\hat {\\bf h}}_d - \\hat {\\bf g}$，则\n又\n因此\n故\n又\n因此\n故\n令 $\\dfrac{\\partial\\epsilon}{\\partial\\overline{\\hat{\\bf h}}_d} = 0$，解得\n${\\bf N{\\scriptsize OTE}}.$\n最后的 $\\lambda$ 应向量化作 $\\lambda {\\bf \\vec1}$。\n","description":"","tags":["CSR-DCF","论文笔记"],"title":"Discriminative Correlation Filter Tracker with Channel and Spatial Reliability (CSR-DCF) 论文笔记","uri":"/posts/csr-dcf%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Notes"],"content":"之前 Typora 一直不支持图床功能，在本地写博客时只能事先把图片手动传到 sm.ms 等图床再复制到文章内，十分不方便；Typora 在 0.9.84 版本增加了使用 PicGo 将图片上传到图床的功能，可以直接将图片上传到 Github 图床，配合免费的 JsDelivr CDN 可以有效加快 Github 上静态资源的加载速度，大大方便了博客的编写。\nGithub 上的配置 创建 Github 仓库 在 Github 上创建一个公开仓库，用于存放我们的静态文件，这里不再赘述。\n获取 token 在 Github 上，依次进入 Settings → Developer settings → Personal access tokens，选择 Generate new token：\n之后在 Note 处填写 token 的名字，并将 Select scopes 中的 repo 勾选上即可。\n之后点击 Generate token 并记下生成的 token。（很重要，因为这段 token 只会展示一次）\n安装并配置 PicGo-core 下载 PicGo-core 确保你已经安装 Node.js，在命令行内执行 npm install picgo -g\n设置 PicGo-core 在命令行内执行 picgo set uploader，之后会显示如下内容：\n? Choose a(n) uploader (Use arrow keys) smms tcyun \u003e github qiniu imgur aliyun upyun 使用光标键选择 github，之后对每个设置项按如下方式填入：\n? repo: \u003cusername\u003e/\u003crepo\u003e ? branch: master ? token: \u003ctoken\u003e ? path: img/ ? customUrl: https://cdn.jsdelivr.net/gh/\u003cusername\u003e/\u003crepo\u003e 逐项解释：\nrepo：按照 \u003cusername\u003e/\u003crepo\u003e 的格式填入你刚刚创建的公开仓库，如 panelatta/static-resources branch：你在 repo 内使用的 branch，默认 master token：你刚刚申请的 token path：你在 repo 内用于上传文件的目录，随意填写即可，这里使用 img/ customUrl：你的自定义域名，PicGo 上传图片后将会直接返回此处的自定义域名 + path 组合成的网址，这里设置为 JsDelivr CDN 的地址 之后打开~/.picgo/config.json，按图中所示进行修改：\n之所以进行此项修改的原因是 picgo 可能默认将此项设置置为 smms。\n配置 Typora 在 Typora 的偏好设置→图像中，如图所示进行设置：\n在 插入图片时... 处：\n选择 上传图片 勾选 对本地位置的图片应用上述规则，这一项勾选后会将本地位置/剪贴板内的图片上传至图床 勾选 对网络位置的图片应用上述规则，这一项勾选后会将网络图片上传至图床 在 上传服务设定 处：\n上传服务 选择 Custom Command\nNote: 这里也可选择 PicGo-core 项，就不需要再手动配置下面的 自定义命令 了，但我试了没成功\n自定义命令 处填入 picgo upload\n之后点击 验证图片上传选项，验证图片上传成功即可。\n需要注意的点 当一张图片已经上传至图床后，不要再次尝试将同名图片重新上传，否则会造成上传失败 ","description":"","tags":["Typora"],"title":"配置typora使用picgo+github+jsdelivr图床","uri":"/posts/%E9%85%8D%E7%BD%AEtypora%E4%BD%BF%E7%94%A8picgo-github-jsdelivr%E5%9B%BE%E5%BA%8A/"},{"categories":["Programming Languages","C"],"content":"C语言内处理不同的字符编码一直是个重要问题，正好今天遇到了需要处理读取/输出中文的问题，把研究结果在这里记录一下。\nwchar_t 类型 说明 定义于头文件 wchar.h 内，存储宽字符类型；wchar_t 类型的宽字符串可与使用 char 类型的多字节字符串互相转换。\n宽字符串字面量在字面量前加 L 标记。e.g. L\"s-char-sequence\"\n相关类型 wint_t 类型是可保有任何合法宽字符，并至少多出一个值的整数类型 。\nI/O 函数 本节参考自中文 cppreference 的文件输入/输出一节。\n无格式 I/O 函数名 函数原型 说明 fgetwc/getwc wint_t fgetwc( FILE *stream ); 从文件流获取一个宽字符 fgetws wchar_t *fgetws( wchar_t *str, int count, FILE *stream ); 从文件流获取一个宽字符串 fputwc/putwc wint_t fputwc( wchar_t ch, FILE *stream ); 将一个宽字符写入文件流 fputws int fputws( const wchar_t *str, FILE *stream ); 将一个宽字符串写入文件流 getwchar wint_t getwchar(void); 从 stdin 读取一个宽字符 putwchar wint_t putwchar( wchar_t ch ); 将一个宽字符写入stdout ungetwc wint_t ungetwc( wint_t ch, FILE *stream ); 将一个宽字符送回文件流 有格式 I/O wscanf 系列 函数名 函数原型 说明 wscanf int wscanf( const wchar_t *format, ... ); 从 stdin 读取格式化宽字符输入 fwscanf int fwscanf( FILE *stream, const wchar_t *format, ... ); 从文件流读取格式化宽字符输入 swscanf int swscanf( const wchar_t *buffer, const wchar_t *format, ... ); 从缓冲区读取格式化宽字符输入 wprintf 系列 函数名 函数原型 说明 wprintf int wprintf( const wchar_t *format, ... ); 打印格式化输出到 stdout fwprintf int fwprintf( FILE *stream, const wchar_t* format, ... ); 打印格式化输出到文件流 swprintf int swprintf( wchar_t *buffer, size_t bufsz, const wchar_t* format, ... ); 打印格式化输出到缓冲区 格式化说明符与使用方式 格式化说明符 说明 %lc 对应 wint_t 类型 %ls 对应 wchar_t * 类型 wscanf/wprintf 系列中的 format 参数若是宽字符串字面量，亦须确保加上了对应的 L 标记。\nswprintf 中的 bufsz 参数保证最多会写入 bufsz - 1 个宽字符，再加空终止符。\n注意：若 wscanf 系列函数在赋值首个接收参数前出现读取失败，返回值仍为 EOF 而非 wchar.h 中定义的宏 WEOF 。\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u003clocale.h\u003e #include \u003cwchar.h\u003e int main(void) { char narrow_str[] = \"z\\u00df\\u6c34\\U0001f34c\"; // 或 \"zß水🍌\" // 或 \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9f\\x8d\\x8c\"; wchar_t warr[29]; // 期待的字符串为 28 字节加 1 个空终止符 setlocale(LC_ALL, \"en_US.utf8\"); swprintf(warr, sizeof warr/sizeof *warr, L\"Converted from UTF-8: '%s'\", narrow_str); wprintf(L\"%ls\\n\", warr); } 窄字符 scanf/printf 系列函数对宽字符（串）的处理 本节内容参考自浅谈C中的wprintf和宽字符显示。\n窄字符之 scanf/printf 系列函数亦可使用 %ls/%lc 格式说明符来处理 wchar_t */wchar_t 类型。但由于 scanf/printf 系列函数用于 byte stream，其输入/输出流中的每个字符占 1 byte；wscanf/wprintf 系列函数用于 wide stream，其输入/输出流中的每个字符多于 1 byte，故其有区别如下：\n组合 说明 scanf/printf + %s scanf/printf将将指针对应缓冲区中的内容视作普通字符串，之后逐个字节输出 scanf/printf + %ls scanf/printf 将指针对应缓冲区中的内容视作宽字符串，按照 locale 的设定，将其中的每个字符隐式调用 wcrtomb() 函数将其转换成多字节字符串，之后逐个字节输出 wscanf/wprintf + %s wscanf/wprintf 将指针对应缓冲区中的内容视作普通字符串，按照 locale 的设定，将其中的每个字符隐式调用 mbrtowc() 函数将其转换成宽字符串，之后逐个宽字符输出 wscanf/wprintf + %ls wscanf/wprintf 将指针对应缓冲区中的内容视作宽字符串，之后逐个宽字符输出 文件读写 本节内容参考自 Linux Manual Page 和 Visual Studio 2019 文档。\nC语言没有处理宽字符串或其他编码的特殊文件I/O函数，若需指定采用特殊编码读写文件，需采用一个gcc/msvc扩展，在读写模式字符串 flag 末尾加入额外的 ,ccs=encoding 字段来指示读取文件所用编码。\n当 encoding 为 UTF-8 时，应当使用 ,ccs=utf-8。\n示例 1 2 3 4 FILE *fp = fopen(\"test.in\", \"r, ccs=utf-8\"); fgetws(s, 2047, fp); wprintf(L\"%ls\\n\", s); fclose(fp); 其他相关函数 本节内容参考自中文 cppreference 的 空终止宽字符串。\n限于篇幅，以下只列出常用函数。\n字符串操作 函数名 函数原型 说明 wcscpy wchar_t *wcscpy( wchar_t *dest, const wchar_t *src ); 将一个宽字符串复制给另一个 wcsncpy wchar_t* wcsncpy( wchar_t* dest, const wchar_t* src, size_t count ); 将一定量的宽字符从一个字符串复制到另一个 wcscat wchar_t *wcscat( wchar_t *dest, const wchar_t *src ); 将一个宽字符串的副本后附于另一个 wcsncat wchar_t *wcsncat( wchar_t *dest, const wchar_t *src, size_t count ); 将一定量宽字符串从一个宽字符串后附到另一个 字符串检验 函数名 函数原型 说明 wcslen size_t wcslen( const wchar_t *str ); 返回宽字符串的长度 wcscmp int wcscmp( const wchar_t *lhs, const wchar_t *rhs ); 比较两个宽字符串 wcsncmp int wcsncmp( const wchar_t* lhs, const wchar_t* rhs, size_t count ); 比较来自两个宽字符串的一定量字符 wcsstr wchar_t* wcsstr( const wchar_t* dest, const wchar_t* src ); 在 dest 所指的空终止宽字符串中，寻找 src 所指的空终止宽字符串的首次出现 wcstok wchar_t* wcstok( wchar_t* str, const wchar_t* delim, wchar_t **ptr ); 寻找 str 所指向的空终止宽字符串中的下个记号。以 delim 所指向的空终止宽字符串鉴别分隔符 宽字符数组操作 函数名 函数原型 说明 wmemcpy wchar_t* wmemcpy( wchar_t* dest, const wchar_t* src, size_t count ); 在两个不重叠的数组间复制一定数量的宽字符 wmemset wchar_t *wmemset( wchar_t *dest, wchar_t ch, size_t count ); 将给定的宽字符复制到宽字符数组的所有位置 locale 设置 采用 setlocale(LC_ALL, \"chs\"); 将当前 locale 设置为中文环境即可。\n","description":"","tags":["中文处理","编码"],"title":"C语言内中文I/O及处理方法","uri":"/posts/c%E8%AF%AD%E8%A8%80%E5%86%85%E4%B8%AD%E6%96%87i-o%E5%8F%8A%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"},{"categories":["Computer Science","Adversarial Attack"],"content":"最近对图像对抗攻击领域产生了一点兴趣，转一篇机器之心翻译的18年的综述论文，虽然比较老了，行外人了解一下还是可以的。\n介绍 这篇文章首次展示了在对抗攻击领域的综合考察。本文是为了比机器视觉更广泛的社区而写的，假设了读者只有基本的深度学习和图像处理知识。不管怎样，这里也为感兴趣的读者讨论了有重要贡献的技术细节。机器之心重点摘要了第 3 节的攻击方法（12 种）和第 6 节的防御方法（15 种），详情请参考原文。\n尽管深度学习在很多计算机视觉领域的任务上表现出色，Szegedy et al. [22] 第一次发现了深度神经网络在图像分类领域存在有意思的弱点。他们证明尽管有很高的正确率，现代深度网络是非常容易受到对抗样本的攻击的。这些对抗样本仅有很轻微的扰动，以至于人类视觉系统无法察觉这种扰动（图片看起来几乎一样）。这样的攻击会导致神经网络完全改变它对图片的分类。此外，同样的图片扰动可以欺骗好多网络分类器。这类现象的深远意义吸引了好多研究员在对抗攻击和深度学习安全性领域的研究。\n自从有了 Szegedy 的发现，机器视觉领域中陆续出现了好几个有意思的受对抗攻击影响的结果。例如，除了在特定图像的对抗性扰动之外，Moosavi-Dezfooli et al. [16] 展示了「通用扰动（universal perturbations）」的存在（如图 1 所示），这种通用扰动可以让一个分类器对所有图片错误分类。同样的，Athalye et al. [65] 展示了即使用 3D 打印的真实世界中存在的物体也可以欺骗深度网络分类器（如图 2 所示）。考虑到深度学习研究在计算机视觉的重要性和在真实生活中的潜在应用，这篇文章首次展示了在对抗攻击领域的综合考察。这篇文章是为了比机器视觉更广泛的社区而写的，假设了读者只有基本的深度学习和图像处理知识。不管怎样，这里也为感兴趣的读者讨论了有重要贡献的技术细节。\n图 1：三种网络的对抗样本和原始样本的对比，以及错误分类结果。\n图 2：3D 打印的对抗样本。\n第 2 节里列举了机器视觉中关于对抗攻击的常用术语。\n第 3 节回顾了针对图片分类任务的对抗攻击。\n图 3：单像素攻击。\n第 4 节单独介绍了在实际生活场景中对抗攻击的方法。\n图 4：人脸识别的对抗样本构造。\n第 5 节关注对抗攻击的工作焦点和研究方向。\n第 6 节讨论了防御对抗攻击的文献。\n图 5：防御通用扰动的图示。\n在第 7 章里，我们以讨论过的文献为基础的展望了未来的研究方向。\n第 8 章总结并画上结尾。\n论文：Threat of Adversarial Attacks on Deep Learning in Computer Vision: A Survey 论文地址：https://arxiv.org/abs/1801.00553\n深度学习正占据如今飞速发展的机器学习和人工智能领域的心脏地位。在机器视觉领域中，它已经变成了从自动驾驶到监控、安保应用中的主力。然而，即便深度网络已经展示了在处理复杂问题时所取得的现象级成功，最近的研究表明它们对于输入中带有的轻微扰动是很脆弱的，从而导致错误的输出。对于图片来说，这样的扰动经常是太小了从而不能被人类感知，但是它们完全愚弄了深度学习模型。对抗攻击造成了深度学习在实践中成功的一系列威胁，进而引导了大量的研究进入这个方向。这篇文章展示了第一个对抗攻击在机器视觉领域的深度学习中的综合考察。我们回顾了对抗攻击设计的研究，分析了这些攻击的存在性以及提出的防御机制。为了强调对抗攻击在实际场所中存在，我们独立地回顾了实际场景中的对抗攻击。最终，我们引用文献来展望更广阔的研究方向。\n3.1 对分类网络的攻击 本节列举了 12 种生成对抗样本的方法，专门针对分类网络。\n1 Box-constrained L-BFGS Szegedy[22] 等人首次证明了可以通过对图像添加小量的人类察觉不到的扰动误导神经网络做出误分类。他们首先尝试求解让神经网络做出误分类的最小扰动的方程。但由于问题的复杂度太高，他们转而求解简化后的问题，即寻找最小的损失函数添加项，使得神经网络做出误分类，这就将问题转化成了凸优化过程。\n2 Fast Gradient Sign Method (FGSM) Szegedy 等人发现可以通过对抗训练提高深度神经网络的鲁棒性，从而提升防御对抗样本攻击的能力。GoodFellow[23] 等人开发了一种能有效计算对抗扰动的方法。而求解对抗扰动的方法在原文中就被称为 FGSM。\nKurakin[80] 等人提出了 FGSM 的「one-step target class」的变体。通过用识别概率最小的类别（目标类别）代替对抗扰动中的类别变量，再将原始图像减去该扰动，原始图像就变成了对抗样本，并能输出目标类别。\n3 Basic \u0026 Least-Likely-Class Iterative Methods one-step 方法通过一大步运算增大分类器的损失函数而进行图像扰动，因而可以直接将其扩展为通过多个小步增大损失函数的变体，从而我们得到 Basic Iterative Methods（BIM）[35]。而该方法的变体和前述方法类似，通过用识别概率最小的类别（目标类别）代替对抗扰动中的类别变量，而得到 Least-Likely-Class Iterative Methods[35]。\n4 Jacobian-based Saliency Map Attack (JSMA) 对抗攻击文献中通常使用的方法是限制扰动的 l_∞或 l_2 范数的值以使对抗样本中的扰动无法被人察觉。但 JSMA[60] 提出了限制 l_0 范数的方法，即仅改变几个像素的值，而不是扰动整张图像。\n5 One Pixel Attack 这是一种极端的对抗攻击方法，仅改变图像中的一个像素值就可以实现对抗攻击。Su[68] 等人使用了差分进化算法，对每个像素进行迭代地修改生成子图像，并与母图像对比，根据选择标准保留攻击效果最好的子图像，实现对抗攻击。这种对抗攻击不需要知道网络参数或梯度的任何信息。\n6 Carlini and Wagner Attacks (C\u0026W) Carlini 和 Wagner[36] 提出了三种对抗攻击方法，通过限制 l_∞、l_2 和 l_0 范数使得扰动无法被察觉。实验证明 defensive distillation 完全无法防御这三种攻击。该算法生成的对抗扰动可以从 unsecured 的网络迁移到 secured 的网络上，从而实现黑箱攻击。\n7 DeepFool Moosavi-Dezfooli 等人 [72] 通过迭代计算的方法生成最小规范对抗扰动，将位于分类边界内的图像逐步推到边界外，直到出现错误分类。作者证明他们生成的扰动比 FGSM 更小，同时有相似的欺骗率。\n8 Universal Adversarial Perturbations 诸如 FGSM [23]、 ILCM [35]、 DeepFool [72] 等方法只能生成单张图像的对抗扰动，而 Universal Adversarial Perturbations[16] 能生成对任何图像实现攻击的扰动，这些扰动同样对人类是几乎不可见的。该论文中使用的方法和 DeepFool 相似，都是用对抗扰动将图像推出分类边界，不过同一个扰动针对的是所有的图像。虽然文中只针对单个网络 ResNet 进行攻击，但已证明这种扰动可以泛化到其它网络上。\n9 UPSET and ANGRI Sarkar[146] 等人提出了两个黑箱攻击算法，UPSET 和 ANGRI。UPSET 可以为特定的目标类别生成对抗扰动，使得该扰动添加到任何图像时都可以将该图像分类成目标类别。相对于 UPSET 的「图像不可知」扰动，ANGRI 生成的是「图像特定」的扰动。它们都在 MNIST 和 CIFAR 数据集上获得了高欺骗率。\n10 Houdini Houdini[131] 是一种用于欺骗基于梯度的机器学习算法的方法，通过生成特定于任务损失函数的对抗样本实现对抗攻击，即利用网络的可微损失函数的梯度信息生成对抗扰动。除了图像分类网络，该算法还可以用于欺骗语音识别网络。\n11 Adversarial Transformation Networks (ATNs) Baluja 和 Fischer[42] 训练了多个前向神经网络来生成对抗样本，可用于攻击一个或多个网络。该算法通过最小化一个联合损失函数来生成对抗样本，该损失函数有两个部分，第一部分使对抗样本和原始图像保持相似，第二部分使对抗样本被错误分类。\n12 Miscellaneous Attacks 这一部分列举了更多其它的生成对抗样本的方法，详情请参见原文。\n表 1：以上列举的各种攻击方法的属性总结：「perturbation norm」表示其限制的 p-范数（p-norm）以使对抗扰动对人类不可见或难以察觉。strength 项（*越多，对抗强度越大）基于回顾过的文献得到的印象。\n3.2 分类/识别场景以外的对抗攻击 除了 Houdini 这个例外, 在 3.1 节中概述的所有主流对抗攻击直接针对于分类任务——欺骗基于 CNN 的分类器。然而，因为对抗性威胁的严重性，对抗攻击的研究已经超越了分类/识别场景。文中概述了以下分类应用领域之外的攻击深度神经网络的方法：\n在自编码器和生成模型上的攻击 在循环神经网络上的攻击 深度强化学习上的攻击 在语义切割和物体检测上的攻击 目前，在对抗攻击防御上存在三个主要方向：\n1）在学习过程中修改训练过程或者修改的输入样本。\n2）修改网络，比如：添加更多层/子网络、改变损失/激活函数等。\n3）当分类未见过的样本时，用外部模型作为附加网络。\n第一个方法没有直接处理学习模型。另一方面，另外两个分类是更加关心神经网络本身的。这些方法可以被进一步细分为两种类型：（a）完全防御；（b）仅探测（detection only）。「完全防御」方法的目标是让网络将对抗样本识别为正确的类别。另一方面，「仅探测」方法意味着在对抗样本上发出报警以拒绝任何进一步的处理。详细的分类在图 9 中展示了。剩下的章节是按这个分类来整理的。\n图 9：防御对抗攻击的方法分类。\n6.1 修改训练过程/ 输入数据 1 蛮力对抗训练 通过不断输入新类型的对抗样本并执行对抗训练，从而不断提升网络的鲁棒性。为了保证有效性，该方法需要使用高强度的对抗样本，并且网络架构要有充足的表达能力。这种方法需要大量的训练数据，因而被称为蛮力对抗训练。很多文献中提到这种蛮力的对抗训练可以正则化网络以减少过拟合 [23,90]。然而，Moosavi-Dezfooli[16] 指出，无论添加多少对抗样本，都存在新的对抗攻击样本可以再次欺骗网络。\n2 数据压缩 注意到大多数训练图像都是 JPG 格式，Dziugaite[123] 等人使用 JPG 图像压缩的方法，减少对抗扰动对准确率的影响。实验证明该方法对部分对抗攻击算法有效，但通常仅采用压缩方法是远远不够的，并且压缩图像时同时也会降低正常分类的准确率，后来提出的 PCA 压缩方法也有同样的缺点。\n3 基于中央凹机制的防御 Luo[119] 等人提出用中央凹（foveation）机制可以防御 L-BFGS 和 FGSM 生成的对抗扰动，其假设是图像分布对于转换变动是鲁棒的，而扰动不具备这种特性。但这种方法的普遍性尚未得到证明。\n4 数据随机化方法 Xie[115] 等人发现对训练图像引入随机重缩放可以减弱对抗攻击的强度，其它方法还包括随机 padding、训练过程中的图像增强等。\n6.2 修改网络 5 深度压缩网络 人们观察到简单地将去噪自编码器（Denoising Auto Encoders）堆叠到原来的网络上只会使其变得更加脆弱，因而 Gu 和 Rigazio[24] 引入了深度压缩网络（Deep Contractive Networks），其中使用了和压缩自编码器（Contractive Auto Encoders）类似的平滑度惩罚项。\n6 梯度正则化/ masking 使用输入梯度正则化以提高对抗攻击鲁棒性 [52]，该方法和蛮力对抗训练结合有很好的效果，但计算复杂度太高。\n7 Defensive distillation distillation 是指将复杂网络的知识迁移到简单网络上，由 Hinton[166] 提出。Papernot[38] 利用这种技术提出了 Defensive distillation，并证明其可以抵抗小幅度扰动的对抗攻击。\n8 生物启发的防御方法 使用类似与生物大脑中非线性树突计算的高度非线性激活函数以防御对抗攻击 [124]。另外一项工作 Dense Associative Memory 模型也是基于相似的机制 [127]。\n9 Parseval 网络 在一层中利用全局 Lipschitz 常数加控制，利用保持每一层的 Lipschitz 常数来摆脱对抗样本的干扰。\n10 DeepCloak 在分类层（一般为输出层）前加一层特意为对抗样本训练的层。它背后的理论认为在最显著的层里包含着最敏感的特征。\n11 混杂方法 这章包含了多个人从多种角度对深度学习模型的调整从而使模型可以抵抗对抗性攻击。\n12 仅探测方法 这章介绍了 4 种网络，SafetyNet，Detector subnetwork，Exploiting convolution filter statistics 及 Additional class augmentation。\nSafetyNet 介绍了 ReLU 对对抗样本的模式与一般图片的不一样，文中介绍了一个用 SVM 实现的工作。 Detector subnetwork 介绍了用 FGSM, BIM 和 DeepFool 方法实现的对对抗样本免疫的网络的优缺点。 Exploiting convolution filter statistics 介绍了同 CNN 和统计学的方法做的模型在分辨对抗样本上可以有 85% 的正确率。 6.3 使用附加网络 13 防御通用扰动 利用一个单独训练的网络加在原来的模型上，从而达到不需要调整系数而且免疫对抗样本的方法。\n14 基于 GAN 的防御 用 GAN 为基础的网络可以抵抗对抗攻击，而且作者提出在所有模型上用相同的办法来做都可以抵抗对抗样本。\n15 仅探测方法 介绍了 Feature Squeezing、MagNet 以及混杂的办法。\nFeature Squeezing 方法用了两个模型来探查是不是对抗样本。后续的工作介绍了这个方法对 C\u0026W 攻击也有能接受的抵抗力。 MagNet:作者用一个分类器对图片的流行（manifold）测量值来训练，从而分辨出图片是不是带噪声的。 混杂方法（Miscellaneous Methods）：作者训练了一个模型，把所有输入图片当成带噪声的，先学习怎么去平滑图片，之后再进行分类。 ","description":"","tags":null,"title":"综述论文：对抗攻击的12种攻击方法和15种防御方法","uri":"/posts/%E7%BB%BC%E8%BF%B0%E8%AE%BA%E6%96%87%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E7%9A%8412%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E5%92%8C15%E7%A7%8D%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95/"},{"categories":["Notes"],"content":"因为一些众所周知的原因，在国内使用 pip 等网络服务的时候会很麻烦，即使换了源有时候速度也不理想，这种时候就会希望使用代理；但 WSL 并不能直接使用 Windows 上的代理软件，需要进行一些配置。\n配置 Windows 本地代理软件 首先最重要的一步：Windows 上的代理软件需要允许来自 LAN 的连接\n以 V2rayN 为例：\n安装并使用 polipo 在 WSL 上安装 polipo：（这里以 Ubuntu 为例）\n1 sudo apt install polipo 之后编辑配置文件 sudo vim /etc/polipo/config，在文件末尾添加内容如下：\nsocksParentProxy = \"localhost:1080\" socksProxyType = socks5 proxyPort = 8123 其中\nsocksParentProxy 是 Windows 上代理软件设置的代理地址和端口号\nsocksProxyType 是 socks 类型，通常都是 socks5\nproxyPort 是 WSL 上的代理端口地址\n保存后重启 polipo 服务即可。\n1 2 service polipo stop service polipo start 之后配置登入 WSL 终端后，自动开启代理：\n新建文件 sudo vim /usr/local/sbin/polipo.sh，添加如下内容\n#!/bin/bash export http_proxy=http://localhost:8123 这里 8123 修改成上面你在 proxyPort 里填写的端口号，之后保存退出。\n编辑 ~/.bashrc 文件，在末尾添加\nsource /usr/local/sbin/polipo.sh 保存退出后重启 Shell 即可。可以用 curl www.google.com 测试代理是否开启。\n","description":"","tags":null,"title":"为WSL配置SOCKS5代理","uri":"/posts/%E4%B8%BAwsl%E9%85%8D%E7%BD%AEsocks5%E4%BB%A3%E7%90%86/"},{"categories":["Notes"],"content":"KeeTrayTOTP 这个 KeePass 插件支持生成 Steam Guard 的安全验证码，但是 Steam 出于安全原因并没有提供导出 TOTP 种子的选项；网上现有的方法需要用到已 root 的安卓机，这里提供一种方法，可以在 PC 上直接获取 TOTP 种子，继而导入进 KeePass 里。\n注意：这个方法会重新绑定 Steam Guard 设备，会使得已有设备上开启的 Steam Guard 失效，如果你仍想保留已有设备上的 Steam Guard ，请勿使用该方法。\n安装 Steam Desktop Authenticator 从官方的 Github 仓库下载最新的 Steam Desktop Authenticator，并按照官方教程配置，但注意在这一步不要输入 encryption key，否则存储 TOTP 信息的文件会被加密：\n之后无视提醒即可\n之后在 Steam Desktop Authenticator 所在目录下找到 maFiles 目录，里面以 .maFile 为后缀名的文件就是存储了密钥信息的数据文件。在其中找到这一行：\n\"uri\":\"otpauth://totp/Steam:[your_Steam_login]?secret=[TOTP_secret]\u0026issuer=Steam\" 将 [TOTP_secret] 导入 KeePass 即可，注意不要再重新在其他设备上重新绑定 Steam Guard，否则会使提取的 TOTP 种子失效。\n如果前面输入了 encryption key 怎么办 打开 maFiles 目录里的 manifest.json 并记录以下信息：\n\"encryption_iv\":\"[string]\" \"encryption_salt\":\"[string]\" 之后在同一目录下创建两个 Python 脚本 pkcs7.py 和 stm.py，内容分别为：\npkcs7.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #!/usr/bin/env python # -*- coding: utf-8 -*- from Crypto.Cipher import AES import binascii from io import StringIO class PKCS7Encoder(object): ''' RFC 2315: PKCS#7 page 21 Some content-encryption algorithms assume the input length is a multiple of k octets, where k \u003e 1, and let the application define a method for handling inputs whose lengths are not a multiple of k octets. For such algorithms, the method shall be to pad the input at the trailing end with k - (l mod k) octets all having value k - (l mod k), where l is the length of the input. In other words, the input is padded at the trailing end with one of the following strings: 01 -- if l mod k = k-1 02 02 -- if l mod k = k-2 . . . k k ... k k -- if l mod k = 0 The padding can be removed unambiguously since all input is padded and no padding string is a suffix of another. This padding method is well-defined if and only if k \u003c 256; methods for larger k are an open issue for further study. ''' def __init__(self, k=16): self.k = k ## @param text The padded text for which the padding is to be removed. # @exception ValueError Raised when the input padding is missing or corrupt. def decode(self, text): ''' Remove the PKCS#7 padding from a text string ''' nl = len(text) val = int(binascii.hexlify(text[-1]), 16) if val \u003e self.k: raise ValueError('Input is not padded or padding is corrupt') l = nl - val return text[:l] ## @param text The text to encode. def encode(self, text): ''' Pad an input string according to PKCS#7 ''' l = len(text) output = StringIO() val = self.k - (l % self.k) for _ in range(val): output.write('%02x' % val) return text + binascii.unhexlify(output.getvalue()) stm.py 此处需要手动填入四个值：\n前面记录的 encryption_iv 和 encryption_salt 分别填入 iv 和 salt 中；\n将以 .maFile 结尾的数据文件（此时已被加密）全文整个字符串填入 maFile 中；\n将前面你填入的 encryption key 填入 passwd 中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import base64 from pbkdf2 import PBKDF2 from Crypto.Cipher import AES from pkcs7 import PKCS7Encoder iv = '' salt = '' mafile = '' getb64str = lambda x : str(base64.b64decode(x), encoding=\"utf-8\") iv = base64.b64decode(iv) salt = base64.b64decode(salt) cipher = base64.b64decode(mafile) passwd = '' PBKDF2_ITERATIONS = 50000 KEY_SIZE_BYTES = 32 encoder = PKCS7Encoder() key = PBKDF2(passwd, salt, iterations=PBKDF2_ITERATIONS).read(KEY_SIZE_BYTES) decryptor = AES.new(key, AES.MODE_CBC, iv) plain = decryptor.decrypt(cipher) print(plain) 之后手动运行 python ./stm.py 即可解密。\n","description":"","tags":null,"title":"用Steam Desktop Authenticator获取Steam Guard的TOTP种子","uri":"/posts/%E7%94%A8steam-desktop-authenticator%E8%8E%B7%E5%8F%96steam-guard%E7%9A%84totp%E7%A7%8D%E5%AD%90/"},{"categories":["Computer Science","Visual Tracking"],"content":"问题动机 当前前沿的 tracker 大多基于 template matching 方法，但大多 tracker 在同一时间只使用目标的单张 template，其 updating 过程始终基于当前目标仍与原始 template 有较高相似度的假设，因而在目标发生较大形态变化时便会丢失目标，如图所示：\n主要贡献 以 Multi-template module 为基础，使用长短期特征结合的方式进行跟踪，较好地解决了传统 single-template tracker 在 updating 过程中的漂移问题。 可以很容易地用于其他 tracker 而不需特别训练，在 accuracy 和 robustness 均有提升的情况下速度几乎没有降低。 解决思路 为了获得关于目标动态变化的较好表达，作者提出了一种基于 STM(short-term module) 和 LTM(long-term module) 构成的 multi-template 框架，如上图所示。其中，STM 和 LTM 分别用于描述模板的短期更新和目标在较长一段时间内的外观变化。\n对每帧模板 $T_i$，由 Siamese Network 从中提取特征$f_i$ ，之后用当前获取的所有特征构建 Gram 矩阵： $$ G(f_1, \\cdots, f_n) = \\begin{bmatrix}f_1 \\star f_1 \u0026 f_1 \\star f_2 \u0026 \\cdots \u0026 f_1 \\star f_n \\\\vdots\t\u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\f_n \\star f_1 \u0026 f_n \\star f_2 \u0026 \\cdots \u0026 f_n \\star f_n\\end{bmatrix} $$\nGram 矩阵对两两特征间进行卷积运算，用于表示其间相关性和不同特征分别在图像中出现的量，在图像风格迁移 (Justin Johnson etc., ECCV 2016) 中引入用于表示图像的整体风格。\n其中 $G$是一个 $n \\times n$ 矩阵，且通常$n$ 比特征空间的维度要小。\nLTM 的目的是维护一个关于当前目标的最具多样性的模板的集合，因而从当前获取的特征中选取一定数量的最具多样性的特征，以最大化由特征向量 ${f_1, f_2, \\cdots, f_n}$构成的平行多面体的体积 $\\Gamma(f_1, f_2, \\cdots, f_n)$；而 $G$的行列式（即$|G|$）为${f_1, f_2, \\cdots, f_n}$ 构成的平行多面体的体积之平方。因此目标函数为 $$ \\max_{f_1, f_2, \\cdots, f_n} \\Gamma(f_1, \\cdots, f_n) \\propto \\max_{f_1, f_2, \\cdots, f_n}|G(f_1, f_2, \\cdots, f_n)| $$ LTM 的更新方法为：当某个模板可增大 $|G|$ 时，说明其更具多样性，此时用其替换 LTM 集合中的对应模板。同时，为了避免 漂移问题，作者为更新过程设置了 lower bound，新的模板需要满足如下条件： $$ f_c \\star f_1 \u003e \\ell \\cdot G_{11} - \\gamma $$ 同时，对于 abrupt movements 和 partial occlusion，此时模板与原始模板相似度过低，LTM 在这种情况下不适用；因此类似传统 tracker，作者设置了 STM 模块来维护当前所在帧附近一段短期时间中的时序信息。STM 采用 FIFO 的方式更新模板，并构建对应的 Gram 矩阵 $G_{st}$。但通过 Gram 行列式的值进行计算的方法在 STM 上表现并不好，因此作者采用以下方式度量 diversity $$ \\gamma = 1 - \\frac{2}{N(N+1)G_{st,max}}\\sum_{i\u003cj}^N G_{st,ij} $$ 其中 $\\gamma \\in [0,1]$，且当 $\\gamma$越靠近$1$ 时，说明 STM 中模板 diversity 程度越高。\n在实际跟踪过程中，出于应对短期变化的考虑，大部分情况下使用 STM 特征；当发生模板漂移时，选择使用 LTM 特征，同时重新初始化 STM 特征。\n实验 可以看到应用 THOR 方法后，跟踪器的 robustness 提升显著，但在 VOT 和 OTB 数据集中 accuracy 的表现差异较大，OTB 的情况下有不错提升但 VOT 中没什么效果，推测是因为加入颜色特征后目标发生剧烈变化时与 origin template 差别太大导致 LTM 大部分情况下没起作用，大部分时候仍使用 STM 特征，而 OTB 的灰度特征因为只主要与目标的外形变化有关因而 LTM 特征可以顺利得以应用。此外，THOR 的这个情况和 CSR-DCF 的情况刚好相反，比较有意思。\n","description":"","tags":null,"title":"Tracking Holistic Object Representations 论文笔记","uri":"/posts/tracking_holistic_object_representations_%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"categories":["Math","Convex Optimization"],"content":"考虑原始 Constrained Optimization Problem\n$$ \\begin{aligned} \u0026\\min; f({\\bf x}) \\ {\\rm s.t.};;c_i({\\bf x}) \u0026\\leq 0, ; i=1,2,\\cdots,n \\ h_j({\\bf x}) \u0026= 0, ; j = 1,2,\\cdots,m\\ \\end{aligned} \\tag{1} $$\n其 Lagrangian 形式为\n$$ \\mathcal{L}({\\bf x}, \\boldsymbol{\\alpha},\\boldsymbol{\\beta})=f({\\bf x})+\\boldsymbol{\\alpha}^\\top {\\bf c}({\\bf x})+\\boldsymbol{\\beta}^\\top{\\bf h}({\\bf x}) $$\n为了最小化 $\\mathcal{L}({\\bf x}, \\boldsymbol{\\alpha}, \\boldsymbol{\\beta})$，考虑函数\n$$ \\theta_P=\\max_{\\boldsymbol{\\alpha}, \\boldsymbol{\\beta}}\\mathcal{L}({\\bf x}, \\boldsymbol{\\alpha}, \\boldsymbol{\\beta}) \\ {\\rm s.t.};; \\alpha_i \\geq 0,;i=1,2,\\cdots,n $$\n则有\n$$ \\theta_P(\\boldsymbol{\\alpha}, \\boldsymbol{\\beta}) = \\begin{cases} f(\\mathbf{x}) \u0026\\begin{cases} c_i(\\mathbf{x}) \\leq 0 \u0026i = 1,2,\\cdots,n \\ h_j(\\mathbf{x}) = 0 \u0026j = 1,2,\\cdots,m \\end{cases} \\ \\infty \u0026\\text{others} \\end{cases} $$\n${\\bf P{\\scriptsize ROOF}.}$若 $\\exists, i\\in[1:n]$使得 $c_i({\\bf x})\\geq0$，则可调整 $\\alpha_i$使 $\\theta_P \\rightarrow +\\infty$；同理，若 $\\exists, j \\in [1:m]$ 使得$h_j({\\bf x}) \\neq 0$，则可调整$\\beta_j h_j({\\bf x})$ 使得$\\theta_P \\rightarrow +\\infty$。$\\blacksquare$\n因此，$(1)$ 的最优解为\n$$ p^* = \\min_{\\bf x}f({\\bf x}) = \\min_{\\bf x}\\max_{\\boldsymbol{\\alpha},\\boldsymbol{\\beta}}\\mathcal{L}({\\bf x},\\boldsymbol{\\alpha},\\boldsymbol{\\beta}) \\ {\\rm s.t.};; \\alpha_i \\geq 0,; i=1,2,\\cdots,n $$\n现在，为了逐步逼近 $p^*$，考虑找到 $(1)$ 的一个足够好的下界；注意到当方程组\n$$ \\left{ \\begin{aligned} f({\\bf x}) \u0026\u003c d^* \\ {\\bf c}({\\bf x}) \u0026\\leq {\\bf 0} \\ {\\bf h}({\\bf x}) \u0026= {\\bf 0} \\end{aligned} \\right. \\tag{2} $$\n无解时，$d^$是 $p^$ 的一个下界。同时，$(2)$ 有解当且仅当对$\\forall \\boldsymbol{\\alpha},\\boldsymbol{\\beta}$ 均有\n$$ f({\\bf x})+\\boldsymbol{\\alpha}^\\top {\\bf c}({\\bf x})+\\boldsymbol{\\beta}^\\top{\\bf h}({\\bf x}) \u003c d^* \\tag{3} $$\n同时 $(3)$无解的充要条件是$\\exists\\boldsymbol{\\alpha ‘},\\boldsymbol{\\beta ‘}$ 使得\n$$ \\min_{\\bf x} \\left( f({\\bf x})+\\boldsymbol{\\alpha ‘}^\\top{\\bf c}({\\bf x})+\\boldsymbol{\\beta ‘}^\\top{\\bf h}({\\bf x}) \\right) \\geq d^* $$\n由此，为了获得足够好的下界，可将上式取最大值\n$$ \\begin{aligned} d^* \u0026= \\max_{\\boldsymbol{\\alpha},\\boldsymbol{\\beta}}\\min_{\\bf x} \\left( f({\\bf x})+\\boldsymbol{\\alpha}^\\top{\\bf c}({\\bf x})+\\boldsymbol{\\beta}^\\top{\\bf h}({\\bf x}) \\right) \\ \u0026= \\max_{\\boldsymbol{\\alpha},\\boldsymbol{\\beta}}\\min_{\\bf x}\\mathcal{L}({\\bf x}, \\boldsymbol{\\alpha}, \\boldsymbol{\\beta}) \\end{aligned} \\tag{4} $$\n注意到 $d^$与 $p^$对$\\mathcal{L}({\\bf x}, \\boldsymbol{\\alpha}, \\boldsymbol{\\beta})$ 取最值的顺序恰好相反，称$d^*$ 对应的问题是原问题的 Dual Problem。至此，引入函数\n$$ \\theta_D({\\bf x}) = \\max_{\\boldsymbol{\\alpha},\\boldsymbol{\\beta}}\\mathcal{L}({\\bf x}, \\boldsymbol{\\alpha}, \\boldsymbol{\\beta}) $$\n定义 Dual Lagrangian 函数及其最优解\n$$ d^* = \\max_{\\boldsymbol{\\alpha},\\boldsymbol{\\beta}}\\min_{\\bf x}\\mathcal{L}({\\bf x}, \\boldsymbol{\\alpha}, \\boldsymbol{\\beta}) \\ {\\rm s.t.};; \\boldsymbol{\\alpha} \\geq {\\bf 0} $$\n此时，给出如下定理：\n${\\bf T{\\scriptsize HEOREM};1}.;;{\\rm W{\\scriptsize EAK};D{\\scriptsize UALITY}.}$\n假设 $p^$与$d^$ 均存在，则\n$$ \\boxed{d^* \\leq p^*.} $$\n${\\bf P{\\scriptsize ROOF}}.$ 易得\n$$ \\min_{\\bf x}\\mathcal{L}({\\bf x}, \\boldsymbol{\\alpha}, \\boldsymbol{\\beta}) \\leq ({\\bf x}, \\boldsymbol{\\alpha}, \\boldsymbol{\\beta}) \\leq \\max_{\\boldsymbol{\\alpha},\\boldsymbol{\\beta}}\\mathcal{L}({\\bf x}, \\boldsymbol{\\alpha}, \\boldsymbol{\\beta}) $$\n则有\n$$ \\begin{aligned} d^* \u0026= \\max_{\\boldsymbol{\\alpha},\\boldsymbol{\\beta}}\\min_{x}\\mathcal{L}({\\bf x}, \\boldsymbol{\\alpha}, \\boldsymbol{\\beta}) \\ \u0026\\leq \\min_{\\bf x}\\max_{\\boldsymbol{\\alpha},\\boldsymbol{\\beta}}\\mathcal{L}({\\bf x}, \\boldsymbol{\\alpha}, \\boldsymbol{\\beta}) \\ \u0026= p^*;\\blacksquare \\end{aligned} $$\n此时称 $(p^* - d^*)$ 为 Duality Gap.\n${\\bf N\\scriptsize{OTE}}.$ 注意 Weak Duality 实际上对于一切优化问题均成立，而与原始问题是否为凸无关。\n由此可给出如下引理：\n${\\bf C{\\scriptsize OROLLARY};;1}.$若 $p^$与 $d^$ 均存在且有$p^* = d^$，则 Primal Problem 和 Dual Problem 的可行解$({\\bf x}^, \\boldsymbol{\\alpha}^, \\boldsymbol{\\beta}^)$ 分别也是对应问题的最优解。\n因此，一旦 $p^* = d^$成立，则可以经由计算 Dual Problem 来获得 Primal Problem 的解；称$p^ = d^*$ 为 Strong Duality。\n","description":"","tags":null,"title":"Lagrangian Duality I. Definition","uri":"/posts/lagrangian_duality_i._definition/"},{"categories":["Math","Convex Optimization"],"content":"These four constrained optimization methods looks similarly when first seen:\nLagrange Multipliers Penalty Methods Augmented Lagrangian Methods Merit Methods Here is a comprehensive explaination towards these four methods written by Brian Borchers.\nNo, they’re not all the same and it’s important to understand the differences between them.\nStart with a simple optimization problem $$ {\\rm min},f({\\bf x}) $$ subject to $$ {\\bf g}({\\bf x})=0 $$ where we can assume for simplicity that $f$ and $g$ are smooth (at least twice continously differentiable.)\nThe Lagrangian function is $$ L({\\bf x},\\boldsymbol{\\lambda})=f({\\bf x})+\\boldsymbol{\\lambda}^\\top {\\bf g}({\\bf x}) $$ Note that $L$ is a function of ${\\bf x}$ and $\\boldsymbol{\\lambda}$. The first order necessary condition for a point ${\\bf x}^$ to be a minimizer is that there is a $\\boldsymbol{\\lambda}^$ such that $({\\bf x}^,\\boldsymbol{\\lambda}^)$ is a stationary point of $L$. In the method of multipliers, we try to solve the nonlinear system of equations $$ \\nabla_{\\bf x}L={\\bf 0} \\\\nabla_{\\boldsymbol{\\lambda}}L={\\bf 0} $$ This is typically done by alternately minimizing with respect to $\\bf x$ and updating $\\boldsymbol{\\lambda}$. Given a Lagrange multiplier estimate $\\boldsymbol{\\lambda}^{(k)}$, we minimize $L({\\bf x},\\boldsymbol{\\lambda}^{(k)})$ to get ${\\bf x}^{(k)}$. Then we update $\\boldsymbol{\\lambda}$ with $$ \\boldsymbol\\lambda^{(k+1)}=\\boldsymbol\\lambda^{(k)}+\\alpha_k {\\bf g}({\\bf x}^k) $$ Where $\\alpha_k$ is a step size parameter that can be set in various ways.\nAn penalty function for our problem is a function that is $0$ if ${\\bf g}({\\bf x})={\\bf 0}$ and greater than $\\bf 0$ when ${\\bf g}({\\bf x}) \\neq \\bf 0$. A commonly used penalty function is the quadratic penalty function $$ \\phi({\\bf g}({\\bf x}))={\\bf g}^2 ({\\bf x}) $$ In the penalty function method, we solve an unconstrained problem of the form $$ {\\rm min}, f({\\bf x})+\\boldsymbol\\rho^\\top\\phi({\\bf g}({\\bf x})) $$ where $\\boldsymbol \\rho$ is a penalty parameter that is increased until the solution of the penalized problem is close to satisfying ${\\bf g}({\\bf x})={\\bf 0}$. Note that $\\boldsymbol \\rho$ is not a Lagrange multiplier in this case.\nFor problems with inequality constraints a commonly used penalty function is $$ \\phi({\\bf g}({\\bf x})) = \\left({\\rm max} \\left{ 0, {\\bf g}({\\bf x}) \\right}\\right)^2 $$ An augmented Lagrangian function combines the penalty function idea with the Lagrangian: $$ \\hat L({\\bf x},\\boldsymbol\\lambda, \\boldsymbol\\rho)=f({\\bf x})+\\boldsymbol\\lambda^\\top{\\bf g}({\\bf x})+\\boldsymbol\\rho^\\top\\phi({\\bf g}({\\bf x})) $$ Augmented Lagrangian methods minimize $\\hat L$ with respect to $\\bf x$, update the Lagrange multiplier estimate $\\boldsymbol \\lambda$ and then (if necessary) update the penalty parameter $\\boldsymbol\\rho$ in each iteration. In practice, augmented Lagrangian methods outperform simple penalty methods and the method of multipliers.\nMerit functions are used in a variety of nonlinear programming algorithms. You’ll most commonly see them used in sequential quadratic programming methods. In these methods, a search direction, ${\\bf d}^{(k)}$, is computed at each iteration. The step is from ${\\bf x}^{(k)}$ to $$ {\\bf x}^{(k+1)}={\\bf x}^{(k)}+\\alpha_k {\\bf d}^{(k)} $$ where the step size parameter $\\alpha_k$ is determined by minimizing a merit function $$ \\alpha_k = {\\rm arg}\\min_\\alpha M({\\bf x}^{(k)}+\\alpha{\\bf d}^{(k)}) $$ The merit function is typically something like a penalized objective function or an augmented Lagrangian, but there’s a great deal of freedom in the form of the merit function.\nThese functions and the associated methods are described in many textbooks on nonlinear optimization. A good discussion can be found in Numerical Optimization by Nocedal and Wright.\n","description":"","tags":null,"title":"Differences Towards the Four Constrained Optimization Methods","uri":"/posts/differences_towards_the_four_constrained_optimization_methods/"},{"categories":["Essay"],"content":"逛知乎时发现一“由于系统维护”而“暂不支持”点赞的匿名答案，甚奇之；且此答案已获得2.7K赞，出于防备删除的目的，备份于此同诸君共览。\n在国内读博士，千万不要以发现知识，探索真理为目的。需要时刻记得的是，读博士就是为了发文章，(发文章，发文章，发文章)。\n如果不能发文章，不管多么有趣的事情都不要做。如果不能发文章，不管学的东西多么有意思都不要去学。\n明白了目的，那就知道了努力方向。博士的主要工作内容有三点：看论文，做实验，写论文。那么这三点就得围绕着发文章进行。看论文，一是确定研究问题，即去看看别人对某个问题的评价和观点。二是看是否有文献发现有没有与这个idea重复的，然后适当修改成与众不同。\n做实验，做到什么程度，以写论文的需求为准则。多余的实验不做，不然太浪费时间了。工业界一个好的算法能够创业带来数千万的估值，学术界，一个好的算法，最多就是几个引用率，还会被一些搞圈子文化的超过。自己估计价值。\n写论文，就是讲好故事，写好句子，画好图。\n另外，明确一点，读博士，本质上是混关系。因此给导师找事情做很重要。第一，让导师觉得自己是一个上进的人。第二，能够保持跟导师很多的沟通。导师互动好了，一切都没有问题。文章写的不好，没关系，找导师帮忙。相投好的期刊，自己文章写的不好，没关系，导师会托人找更牛的人帮你修改。\n凡是凭自己想搞个大炮仗，证明自己实力的博士生都没有好结果的。因为你只是一个人，而别人是一群人。不然，为什么有人能够博士5年平均3个月一篇文章，一毕业就是教授呢？\n——————–这是分割线———————————–\n鉴于以上回答太过功利，对满怀理想和求知欲的准博士生没有说服力。现在重新修订一下回答。\n科学研究是高强度的脑力活动。往往一个新的概念的形成，需要与类似的概念进行反复的类比，质疑，删繁存简。这个过程，有过经历的人应该有体会：情绪往往剧烈的起伏变化，从开始有所突破的兴奋，到中间发现逻辑漏洞的担忧，再到完全放弃的失落，如此反复多次。即使如此，最后不一定有可靠的成果的产出。\n这个过程，由于附带多重剧烈情绪，特别影响工作效率。多次的失败，导致负反馈过多，往往会出现研究信心丧失等不良后果。\n当然如果有棋逢对手的人全程跟进讨论，那是快乐无比，也会收获很多。但是现实是，博士生往往没有人讨论，几乎一人一方向，一人一课题。对于大多数人而言，实在是知音难求。\n这应该就是通常所说，追求真理过程的孤独与苦闷吧。\n这份孤独与苦闷，源自脑力活动的规律。即对脑力活动对交流的渴望，或者叫做创造来自于思维的碰撞。而你一个人没有谁可以碰撞。\n剩余的途径，就是自己与自己碰撞。如果不想变成《美丽心灵》精神分裂的纳什，那就写吧。\n语言是思维的外壳，所有的思维活动都是基于某种语言的。描述某个对象的词汇越丰富，代表着使用这种语言的族群对该对象的观察理解越多。例如，中国人关于做吃的词就特别多。煎、煮、炆、炸、蒸、炖、焗、炒、烤、闷、溜、扒等等。英语中就没有这么多做饭的词了。再比如，一个uncle就囊括了汉语中多少亲属关系。\n言归正传，写论文，是科学研究在语言的表达，更是自己与自己进行思维碰撞的激烈过程。当你写完一篇文章，对这个文章的研究内容的各个细节也就清楚了。这个过程将产生很多新的想法和心得。从而支持自己下一阶段的研究。\n论文的发表过程，将会收到很多同行给出的意见，这些意见对于完善你的思路，很有帮助。\n好了，以上是博士写论文的重要性，和必要性。\n搞清楚了这些，我们可以得出结论：博士生涯中，你的知识广度与深度，与你的论文数量和质量是成正比的。论文越多，说明你的知识越广，论文质量越高，说明你的知识越深。\n而之前的回答，则是对如何产生大量的论文进行的功利性概括。\nnote：\n1.科研交流，也是搞关系的一种。关系越广，学习机会越多，获取的知识也约先进。\n2.知识不是精确的实验数据，也不是某种优化模型时用的trick。还是那句话，不能发论文的实验不做，这会影响获取知识的进度。为了高效获取知识，适当的预估一下实验结果也应该是可以的(自己承担风险)，不然文章不出，哪里有大牛的指导意见呢？\n3.兴趣是思维活动，思维的特性是发散。因此，应该将兴趣固定到论文上。因此，还是那句话，与论文无关的知识不学，与论文无关的兴趣坚决扼杀。有关无关是一个判断，体现了一个博士生对研究问题的分析判断能力。\n4.搞大炮仗，可以看做 ‘成了英雄主义的俘虏’。这是各种舆论宣传的下的毒。塑造英雄，是人物传作者的吸引眼球的伎俩，不把那些人物传的主角写的与众不同，谁他妈的看他们的东西，那些主角又如何给他们钱呢？\n可以说，做任何事情都不应该谋求大炮仗，而是应该顺势而为。毛主席不是说过了么，英雄人物，是历史时代的产物。你参与了某个历史事件，就成为了英雄人物。做科研如何参与历史事件呢？那就是追求热点，多发文章。\n5.不以\"发现知识，追求真理\"为目的读博士。那是因为好多帖子会说博士为了探索知识，追求真理。\n这导致了在高大上的目标感召下，年轻人头脑发热，实验有点进展就觉得快找到了真理，失去了博士期间的规划，浪费时间。也有人会因此盲目的选择读博士，浪费自己的生命。\n另外，“追求知识和发现真理”，因为太抽象，所以成为一个巨深无比的坑，什么都能装。细心一点会发现，所有的抽象词汇，如真理，普世价值，正义，公正，都是洗脑专用词汇，也是极具攻击的词汇。真理-谬误，正义-邪恶，公正-非公证。你被适用了这些词，你就被洗脑攻击了，无论褒贬。\n而博士帖子洗脑的原因是什么?对于某些学科的博士，就是屠龙之术，没有什么社会效益。而所有的人都是得吃饭生存的。依靠抽象词汇洗脑，是可以降低人的对现实需求的欲望和不满的。只有回报低，或者需要巨大的牺牲的时候，才需要\"真理\"之类的崇高目标作为指引。\n———————我是分割线————————–\n还是有人觉得我传递了负能量，我再次补充一点略微高大上的观点。\n一、为什么我说让博士生探索真理，发现知识是在洗脑呢？\n真理化身规律无处不在，巨如浩瀚星辰，微若质子微粒，均在其规制之下。发现了确实的规律，如同拿到了上帝的权柄，必定会得到巨大的奖赏，无论是物质上，还是荣誉上。真能有如此大的回报，还需要你去标榜是你是在发现真理，在创造知识?\n以科技创新为特征的工业社会，具有无比强大的生命力，根本不会在意你是否扛着发现真理创造知识的崇高大旗。自有一套实实在在的奖惩机制，来保证你的工作是在发现知识，探索真理。\n你造的基站网速更快更可靠，你的石墨烯更便宜，他的氢氟酸工艺产量更纯更安全等等，或者你观察到了原子，检测出了引力波，证明了黎曼猜想等等。\n因此科研不需要口号。喊口号就是在洗脑。\n另外而戴高帽子的副作用还不小。高大上的概念、崇高的目标，容易让人昏头昏脑。特别在文章作为硬性考核指标的压力下，人容易自我催眠，以自己在做崇高的事业为借口，掩盖自己的懒惰。\n另外，由于高大上的概念、崇高的目标，会自我催眠，形成完美主义标准，和养成孤芳自赏文人相轻的毛病。\n而完美主义，实在是效率的大敌。而孤芳自赏文人相轻，则是交流合作的大敌。\n二、博士算是科研工作者了。科研工作，包含两个很重要的内容：一是科学研究; 二是科学表达。科学研究探索未知，发现知识; 科学表达，则是语言化知识，并传播知识。\n那这两方面究竟哪个更重要呢? 应该都是极其重要的。\n为什么呢？因为知识只有广泛传播才能产生社会影响，并实现自我更新。好的科学表达能够极大的促进知识的传播，从而提高知识共享效率，让大家避免重复造轮子，节约人力资源，加速新知识的发现。\n因为不好好发表自己的工作，而导致科技推迟进步的例子很多。比如孟德尔遗传定律，高乐瓦的群论，牛顿和莱布尼茨微积分发明权之争。\n科学研究和科学表达的能力的培养成本和紧迫性是不一样的。\n探索真理，你会受到很多限制，如经费，仪器，指导老师，以及科技发展的水平(你需要站在前人的肩膀上)。但是提高科学表达能力却没有那么多限制，并且还与你能否毕业密切相关。真有重大突破的成果要完成，即使你要执着的去写论文的，也有人拽着你的。还是那句话，奖励实在巨大。\n如果没人拽着你，那就去写吧。\n","description":"","tags":null,"title":"如何读博士","uri":"/posts/%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8D%9A%E5%A3%AB/"},{"categories":["Essay"],"content":" 追逐梦想的好友在远方去世了\n用着无法出声的身体归来\n他留下的东西只有一件\n那便是破烂不堪的一张达到目的地的照片\n夢を追った親友は遠くで死にました 声も出ない体で帰ってきたんだ そいつが残した物はたったひとつだけ 費やしきって行きついた一枚の写真 何かのメロディーを奏でる 譜面にも見えたんだ 東京キャスター　僕は生きる でも　ここに何が在る？ 景色の真ん中に　誰が居る？ 東京キャスター　いつまでも そうだきっと　いつまでも 写真を撮る側に　僕が居る 右目で覗く望遠鏡　左目に顕微鏡 どれだけ遠くが見えるんだい そんなに欲張って ポッケの中の算数式でお腹を満たす日々 だけど 左右に違う方程式は今日も行き止まり 音の無いメロディーを覗き込む 互い違いの双眼鏡 東京キャスター　僕は生きる でも　何かに呼ばれてる 蜃気楼のような未来は在る 東京キャスター　いつまでも こんな不確かな満足感に 浸っている訳にいかないんだ 何かのメロディーを奏でる 譜面にも見えた景色 新しいメロディーを探るため 捻り出した　双眼鏡 東京キャスター　僕は生きる でも確かに在るものを 見逃さないように目を凝らせ 東京キャスター　いつまでも きっと　僕は僕だから 景色の真ん中で息をする - 東京キャスター. Harry. RESCUE OF RAINBOWS. 東京Caster 我会活着\n但是 为了不错过确实存在的东西\n我凝视着\n東京Caster 永远\n一定 因为我就是我\n在景色的正中呼吸着\n私たちはいつまでも自分のメロディーを探しながら生きていくのではないのだろうか。\nめっちゃ泣きましたね。\nありがとうございます。\n","description":"","tags":null,"title":"東京キャスター","uri":"/posts/%E6%9D%B1%E4%BA%AC%E3%82%AD%E3%83%A3%E3%82%B9%E3%82%BF%E3%83%BC/"},{"categories":["Math","Convex Optimization"],"content":"This article simply introduced strategies for finding the stationary points of the objective function subject to one or more equality or inequality constraints.\nConsider a standard form of continuous optimization problem, $$ \\min\\limits_{\\bf x} f({\\bf x}) \\ {\\rm s.t.};;g_k({\\bf x})\\leq0,;;k=1,2,\\cdots,m \\ h_l({\\bf x})=0,;;l=1,2,\\cdots,p \\ $$ in which $$ {\\bf x} \\in \\Re^{n} \\ f,g_k,h_l:\\Re^n \\rightarrow \\Re;;{\\rm for};;k=1,2,\\cdots,m;;{\\rm and};;l=1,2,\\cdots,p \\ m,p\\geq0 $$ And $f,g_k,h_l$ are all continuous differentable.\nWe divided the problem into two cases: $p = 0$ or $p \\neq 0$. For the former we introduced The Method of Lagrange Multipliers as the solving strategy, and simply introduced KKT Conditions for the other one when it suits some Regularity Conditions.\nNotice that it was easy to treat a maximization problem by negating the objective function, we only use the maximization problem as a general example.\nThe Method of Lagrange Multipliers Consider the optimization problem $$ \\min_{\\bf x}f({\\bf x}) \\ {\\rm s.t.};;g_k({\\bf x})=0;;{\\rm for};;k=1,2,\\cdots,m. $$ To transfer the constrained problem into an unconstrained one, we define the Lagrange Function, $$ L({\\bf x, \\overrightarrow{\\lambda}})=f({\\bf x})+\\sum_{k=1}^m \\lambda_k g_k({\\bf x}) $$ In which $\\lambda_{k} \\in \\Re ;; {\\rm for} ;; k=1,2,\\cdots,m$. Then we have the necessary conditions for the optimal solution, which is $$ \\left{\\begin{matrix} \\bigtriangledown_{\\bf x}L={\\bf 0} \\ \\bigtriangledown_{\\bf \\overrightarrow{\\lambda}}L={\\bf 0} \\end{matrix}\\right. $$ called Stationary Equation and Constraints separately. Then solving the $n+m$ simultaneous equations, and the solution $({\\bf x^},\\overrightarrow{\\lambda}!^)$ are stationary points and corresponding coefficients.\n${\\bf N{\\scriptsize OTE}}.$ Cause we could get stationary point through Lagrange Multipliers directly, the minimization/maximization problems are treated in same way.\n${\\bf E{\\scriptsize XAMPLE}}.$ Maximize $f(x,y,z) = 8xyz$ subject to $\\dfrac{x^2}{a^2}+\\dfrac{y^2}{b^2}+\\dfrac{z^2}{c^2}=1$.\n${\\bf S{\\scriptsize OLUTION}}.$ Form the Lagrange Function $$ L(x,y,z,\\lambda)=8xyz+\\lambda(\\dfrac{x^2}{a^2}+\\dfrac{y^2}{b^2}+\\dfrac{z^2}{c^2}-1) $$ Then calculate gradient of the function $L$ and set it to $\\bf 0$. $$ \\bigtriangledown L=\\begin{bmatrix} (8yz+\\dfrac{2\\lambda x}{a^2}) \u0026 (8xz+\\dfrac{2\\lambda y}{b^2}) \u0026 (8xy+\\dfrac{2\\lambda z}{c^2}) \u0026 (\\dfrac{x^2}{a^2}+\\dfrac{y^2}{b^2}+\\dfrac{z^2}{c^2}-1) \\end{bmatrix} = {\\bf 0} $$ We could get the solution $$ \\left{\\begin{matrix} x=\\dfrac{\\sqrt{3}}{3}a \\ y=\\dfrac{\\sqrt{3}}{3}b \\ z=\\dfrac{\\sqrt{3}}{3}c \\ \\end{matrix}\\right. $$ Considering the background of the question, the maximum solution must exist. Now we can get the answer $$ f_{\\rm max}(x,y,z)=\\dfrac{8\\sqrt{3}}{9}abc $$\nKKT Conditions For convinience, we consider the case without equality constraint but with a single inequality constraint first, $$ \\min_{\\bf x}f({\\bf x}) \\ {\\rm s.t.} ;; g({\\bf x}) \\leq 0. $$ Then define the feasible region $\\mathbb{K}=\\left{ \\Re^n,|,g({\\bf x}) \\leq 0 \\right}$ and assuming that ${\\bf x}^$ is the best solution under the constraint condition $g$. According to whether ${\\bf x}^$ is on the border of $\\mathbb{K}$ or not, we can divide the problem into two cases and discuss them separately.\n${\\bf C{\\scriptsize ASE}; 1}.;; g({\\bf x}^) \u003c0.$ The best solution is inside $\\mathbb{K}$. At this time we call ${\\bf x}^$ as the interior solution. Obviously, at this time, an infinitesimal displacement of the point towards any direction will not against the constraint, so we call that the constraint condition$g$ is inactive.\n${\\bf C{\\scriptsize ASE};2}.;;g({\\bf x}^)=0.$ The best solution is on the border of $\\mathbb{K}$. At this time we call ${\\bf x}^$ as the boundary solution. Correspondingly, now we call that the constraint condition $g$ is active.\nLikely, defining the Lagrangian Function $$ L({\\bf x},\\lambda)=f({\\bf x})+\\lambda g({\\bf x}) $$ According to $g$ is active or inactive, the necessary condition for us to get the best solution are different.\n${\\bf C{\\scriptsize ASE};I{\\scriptsize NACTIVE}}. $Cause the constraint condition $g$ has no influence on getting the best solution, we could make $\\lambda = 0$ directly. Now the task is equivalent to unconstrained optimization, and only $\\bigtriangledown f={\\bf 0}$ is needed.\n${\\bf C{\\scriptsize ASE} ; A{\\scriptsize CTIVE}}.$ Now the constraint condition $g$ is equivalent to $$ g({\\bf x})=0 $$ Notice that for every points ${\\bf x} \\in g$, there is $\\bigtriangledown g({\\bf x})$ orthogonal to $g$. Likely, it is obvious to find that $\\bigtriangledown f({\\bf x}^)$ is also orthogonal to $g$. So, we can easily prove that $\\bigtriangledown f \\in {\\rm span}(\\bigtriangledown g)$ at ${\\bf x}^$. That is to say, there exists $\\lambda$ which makes that $$ \\bigtriangledown_{\\bf x} f=-\\lambda \\bigtriangledown_{\\bf x} g $$ It’s easy to find that $\\lambda \\geq 0$ should be kept, cause we want to minimize $f$, and $\\bigtriangledown f({\\bf x}^*)$ (pointing to the fastest growing direction) should point to the interior of $\\mathbb{K}$. However, $\\bigtriangledown g$ points to the outside of $\\mathbb{K}$, so $\\lambda$ should be kept not less than$0$, which is called dual feasibility. Likely, if we want to maximize $f$, we should keep $\\lambda \\leq 0$.\nObviously, there will always be either $\\lambda$ or $g$ equal to $0$, so it always holds that $\\lambda g({\\bf x})=0$, which is called complementary slackness.\nThus we can summarize all necessary conditions mentioned above as KKT Conditions,\n$$ \\begin{aligned} \\bigtriangledown_{\\bf x} f + \\lambda \\bigtriangledown_{\\bf x} g \u0026= {\\bf 0} \\ {\\bf g}({\\bf x}) \u0026\\leq 0 \\ \\lambda \u0026\\geq 0 \\ \\lambda g({\\bf x}) \u0026= 0 \\end{aligned} $$\nSimilarly, we can also extend the conclusion to the general continuous optimization problem. The corresponding Lagrangian Function is defined as $$ L({\\bf x}, \\overrightarrow \\lambda, \\overrightarrow \\mu)=f({\\bf x})+\\overrightarrow \\lambda!^\\top {\\bf g}({\\bf x}) + \\overrightarrow \\mu!^\\top {\\bf h}({\\bf x}) $$ And it’s also convinient to write down the corresponding KKT Conditions $$ \\begin{aligned} \\bigtriangledown_{\\bf x} f + \\overrightarrow \\lambda!^\\top \\bigtriangledown_{\\bf x}{\\bf g}+\\overrightarrow \\mu!^\\top\\bigtriangledown_{\\bf x}{\\bf h} \u0026= {\\bf 0} \\ g_k({\\bf x}) \u0026\\leq 0, ;; k=1,2,\\cdots, m \\ h_l({\\bf x}) \u0026= 0, ;; l=1,2,\\cdots, p \\ \\lambda_k \u0026\\geq 0,\\ \\lambda_k g_k({\\bf x}) \u0026= 0 \\end{aligned} $$\n${\\bf N{\\scriptsize OTE}}.$ In order for existing a point ${\\bf x}^*$ fitting the KKT Conditions, The primal question should satisfy some regular conditions, which has been listed on Wikipedia.\n${\\bf E{\\scriptsize XAMPLE}}.$ Minimize $x_1^2 + x_2^2$ subject to $x_1 + x_2=1$ and $x_2 \\leq \\alpha$, in which $x_1, x_2, \\alpha \\in \\Re$.\n${\\bf S{\\scriptsize OLUTION}}.$ The corresponding Langrangian Function is $$ L({\\bf x}, \\lambda, \\mu)=x_1^2 + x_2^2 +\\lambda(x_2-\\alpha)+\\mu(x_1 + x_2 - 1) $$ According to KKT Condition, there must be $$ \\left { \\begin{aligned} \\frac{\\partial L}{\\partial x_1} = \\frac{\\partial L}{\\partial x_2} \u0026= 0 \\ x_1 + x_2 \u0026= 1 \\ x_2 \u0026\\leq \\alpha \\ \\lambda \u0026\\geq 0 \\ \\lambda(x_2 - \\alpha) \u0026= 0 \\end{aligned} \\right. $$ which is equivalent to $$ \\left { \\begin{aligned} x_1 \u0026= -\\frac{\\mu}{2} \\ x_2 \u0026= \\frac{\\mu}{2} + 1 \\ \\mu \u0026\\leq -1 \\ \\mu \u0026\\leq 2\\alpha - 2 \\end{aligned} \\right. $$ Now we can divide the problem into 2 cases according to whether $2\\alpha - 2 \\geq -1$ or not.\n${\\bf C{\\scriptsize ASE}};;\\alpha \\geq \\dfrac{1}{2}.$ It is easy to verify that $\\mu = -1$ satisfies all KKT Conditions above, so when $x_1 = x_2 = \\dfrac{1}{2}$, $x_1^2 + x_2^2$ takes minimum value $\\dfrac{1}{2}$.\n${\\bf C{\\scriptsize ASE}};;\\alpha \u003c \\dfrac{1}{2}.$ There is $\\mu=2\\alpha - 2$ satisfies all KKT Conditions above only, so when $x_1=1-\\alpha$and$x_2 = \\alpha$, $x_1^2 + x_2^2$ takes minimum value $1 - 2\\alpha + 2\\alpha^2$.\n","description":"","tags":null,"title":"The Method of Lagrangian Multipliers and The KKT Conditions","uri":"/posts/the_method_of_lagrangian_multipliers_and_the_kkt_conditions/"},{"categories":["Math","Linear Algebra"],"content":"矩阵微积分是多元函数微积分在矩阵空间中进行表达时采用的一种简化形式，常用于机器学习中，可通过将多个变量记为向量或矩阵的形式来简化运算。但目前矩阵微积分的相关概念定义尚未统一，运算方式亦繁乱无绪；若按许多人之习惯做法，显式依照定义进行计算，则又因为对向量/矩阵进行逐元素运算而破坏整体性，计算难度颇高，多须借助查表方能完成运算。本文通过引入矩阵微分算子的方式重新维护了整体性，大幅降低了运算难度，同时亦使得其定义更契合已有的标量微积分运算。\n本文是矩阵求导术（上）的笔记，对全文缺漏处进行了部分完善，同时在证明与例题处亦重新进行了推导，十分感谢作者长躯鬼侠。\n符号约定 在引入矩阵微积分进行计算的公式中，往往混杂标量、向量、矩阵，若按传统习惯使用同一风格字体进行表述，公式复杂时难以进行分辨；为简化辨认，约定如下符号使用规范：\n用拉丁字母表示的数学常量（$\\mathrm{e}, \\mathrm{i}$, e.g.）、函数/算子名称（$\\dfrac{\\mathrm{d}f}{\\mathrm{d}x},\\sin{x}$ , e.g.）、其他相关记号（$\\textrm{argmin}$, e.g.），用 Roman 正体表示。 用拉丁字母表示的标量（$x,y,z$, e.g.）、用希腊字母表示的数学常量或标量（$\\pi, \\alpha$, e.g.），用 Italic 斜体表示。 向量（$\\mathbf{x}, \\mathbf{y},{\\boldsymbol \\pi},{\\boldsymbol \\alpha}$, e.g.），用小写 Bold 粗体表示。 矩阵（$\\mathbf{A}, \\mathbf{B}, {\\bf \\Pi, \\Sigma}$, e.g.），用大写 Bold 粗体表示。 域（$\\mathfrak{R,C}$, e.g.），用 Fraktur 哥特体表示。 若非特殊注明，计算过程均采用分子记法，文中所有函数均属于 $C^{1}$ 。 定义 标量 $f: \\mathfrak{R}^{n} \\rightarrow \\mathfrak{R}$对向量 $\\mathbf{x} \\in \\mathfrak{R}^{n}$求导，所得结果为$f$ 对$\\bf x$ 各分量分别求导构成的向量，记为 $$ \\frac{\\partial f}{\\partial \\mathbf{x}}= \\begin{bmatrix} \\frac{\\partial f}{\\partial x_1} \u0026 \\frac{\\partial f}{\\partial x_2} \u0026 \\frac{\\partial f}{\\partial x_3} \u0026 \\cdots \u0026 \\frac{\\partial f}{\\partial x_n} \\end{bmatrix}^{\\top} = \\nabla_{\\mathbf{x}}f $$ 其中 $\\nabla$是 Nabla 算子，表示 $f$ 对$\\mathbf{x}$ 的梯度。\n标量 $g: \\mathfrak{R}^{n \\times m} \\rightarrow \\mathfrak{R}$对矩阵 $\\mathbf{X} \\in \\mathfrak{R}^{n \\times m}$求导，所得结果为$g$ 对$\\bf X$ 各元素分别求导构成的矩阵，记为 $$ \\frac{\\partial g}{\\partial \\mathbf{X}}=[\\frac{\\partial g}{\\partial X_{ij}}]{n \\times m} $$ 我们已知，$f$对$\\mathbf{x}$ 的全微分为 $$ \\mathrm{d}f = \\sum\\limits{i=1}^{n}\\frac{\\partial f}{\\partial x_{i}}\\mathrm{d}x_{i}=\\frac{\\partial f}{\\partial \\mathbf{x}}^{\\top}\\mathrm{d}\\mathbf{x} $$ 其中 $$ \\mathrm{d} \\mathbf{x} = \\begin{bmatrix} \\mathrm{d}x_{1} \u0026 \\mathrm{d}x_{2} \u0026 \\cdots \u0026 \\mathrm{d}x_{n} \\end{bmatrix}^{\\top} $$ 相似的，我们可定义 $g$对$\\mathbf{X}$ 的微分为 $$ \\mathrm{d}g=\\mathrm{tr}(\\frac{\\partial g}{\\partial \\mathbf{X}}^{\\top}\\mathrm{d}\\mathbf{X}) $$ 其中 $\\mathrm{tr}$ 表示矩阵的迹，且 $$ \\mathrm{d}\\mathbf{X} = [\\mathrm{d}X_{ij}]_{n \\times m} $$ 此时，微分算子 $\\mathrm{d}$ 的运算对象是一个矩阵；我们称此时进行的运算为矩阵微分。\n矩阵微分的运算法则 线性、矩阵乘法、转置、迹、常量的微分\n$\\mathrm{d}(\\mathbf{X \\pm Y})=\\mathrm{d}{\\mathbf{X}} \\pm \\mathrm{d}\\mathbf{Y}$ ，${\\rm d}(r{\\bf X}) = r{\\rm d}{\\bf X},;r \\in {\\frak R}$ 。\n$\\mathrm{d}(\\mathbf{XY})=(\\mathrm{d}\\mathbf{X})\\mathbf{Y}+\\mathbf{X}\\mathrm{d}\\mathbf{Y}$ 。\n$\\mathrm{d}(\\mathbf{X}^{\\top}) = (\\mathrm{d}\\mathbf{X})^{\\top}$ 。\n$\\mathrm{d}(\\mathrm{tr}(\\mathbf{X})) = \\mathrm{tr}(\\mathrm{d}\\mathbf{X})$ 。\n${\\rm d}({\\bf A})={\\bf 0}$ ，${\\bf A}$ 是常量。\n推论：${\\rm d}({\\bf AXB})={\\bf A}({\\rm d}{\\bf X}){\\bf B}$ ，$\\bf A,B$ 是常量。\n证明略。\n矩阵的逆 $$ \\mathrm{d}\\mathbf{X}^{-1}=-\\mathbf{X}^{-1}(\\mathrm{d}\\mathbf{X})\\mathbf{X}^{-1} $$ 证：由 $\\mathbf{X}\\mathbf{X}^{-1}=\\mathbf{I}$ 两侧取微分即得。\nJacobi’s Formula $$ \\mathrm{d}|\\mathbf{X}|=\\mathrm{tr}(\\mathbf{X}^{}\\mathrm{d}\\mathbf{X}) $$ 其中 $\\mathbf{X}^{}$指 $\\mathbf{X}$ 的伴随矩阵（而非$\\mathbf{X}$ 的复共轭）。\n特别地，当 $\\mathbf{X}$ 可逆时，有 $$ \\mathrm{d}|\\mathbf{X}|=|\\mathbf{X}|\\mathrm{tr}(\\mathbf{X}^{-1}\\mathrm{d}\\mathbf{X}) $$ 证：\n${\\bf L{\\scriptsize EMMA}}.$对 $\\mathbf{A,B} \\in \\mathfrak{R}^{n \\times n}$，有$\\mathrm{tr}(\\mathbf{A^{\\top}B})=\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n}\\mathbf{A}{ij}\\mathbf{B}{ij}$。\n${\\bf P{\\scriptsize ROOF}}.$由矩阵乘法，$(\\mathbf{AB}){jk} = \\sum\\limits{i=1}^{n}\\mathbf{A}{ji}\\mathbf{B}{ik}$，故有$(\\mathbf{A^{\\top}B}){jk}=\\sum\\limits{i=1}^{n}\\mathbf{A}{ij}\\mathbf{B}{ik}$。\n因此，$\\mathrm{tr}(\\mathbf{A^{\\top}B}) = \\sum\\limits_{i=1}^{n}(\\mathbf{A^{\\top}B}){ii} = \\sum\\limits{i=1}^{n}\\sum\\limits_{j=1}^{n}\\mathbf{A}{ij}\\mathbf{B}{ij}$ 。证毕。\n${\\bf J{\\scriptsize ACOBI’S};F{\\scriptsize ORMULA}}.$对 ${\\bf X} \\in {\\frak R}^{n \\times n}$，有${\\rm d}|{\\bf X}|= {\\rm tr}({\\bf X^{*}}{\\rm d}{\\bf X})$。\n${\\bf P{\\scriptsize ROOF}}.$对 $\\bf X$ 的第$i$ 行做 Laplace 展开，有 $$ |{\\bf X}|=\\sum\\limits_{j=1}^{n}({\\bf X^{}})^{\\top}{ij}X{ij};,;\\forall i\\in{1,2, : \\cdots :, n} $$ 又，矩阵的行列式运算可视作 ${\\rm det}: {\\frak R}^{n^2} \\rightarrow {\\frak R}$，因此可使用向量的全微分公式 $$ {\\rm d|{\\bf X|}}=\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n}\\frac{\\partial {\\bf |X|}}{\\partial X_{ij}}{\\rm d}{X_{ij}} $$ 现在，需要求出 $\\dfrac{\\partial {\\bf |X|}}{\\partial X_{ij}}$。考虑 ${\\bf |X|}$的 Laplace 展开式中 $i$ 可任取${1,2,:\\cdots:.n}$ 中的任一数值，不妨假定其与$X_{ij}$ 保持一致。因此， $$ \\begin{aligned} \\frac{\\partial {\\bf |X|}}{\\partial X_{ij}}\u0026= \\frac{\\partial\\sum\\limits_{k=1}^{n}({\\bf X^{}})^{\\top}{ik}X{ik}}{\\partial X_{ij}}\\ \u0026=\\sum\\limits_{k=1}^{n}\\frac{\\partial ({\\bf X^{}})^{\\top}{ik}X{ik}}{\\partial X_{ij}}\\ \u0026=\\sum\\limits_{k=1}^{n}\\frac{\\partial({\\bf X^{}})^{\\top}{ik}}{\\partial X{ij}}X_{ik}+\\sum\\limits_{k=1}^{n}\\frac{\\partial X_{ik}}{\\partial X_{ij}}({\\bf X^{}})^{\\top}_{ik} \\end{aligned} $$ 考虑代数余子式的构造方式，可得知 $({\\bf X^})^{\\top}{ik}$并非$X{ij}$ 的函数。因此， $$ \\sum\\limits_{k=1}^{n}\\frac{\\partial ({\\bf X^})^{\\top}{ik}}{\\partial X{ij}}X_{ik}=0 $$ 类似地，由矩阵元素相互之间的独立性，可得知 $X_{ik};(k \\neq j)$并非$X_{ij}$ 的函数。因此， $$ \\sum\\limits_{k=1}^{n}\\frac{\\partial X_{ik}}{\\partial X_{ij}}({\\bf X^})^{\\top}{ik}=\\frac{\\partial X{ij}}{\\partial X_{ij}}({\\bf X^})^{\\top}_{ij}=({\\bf X^})^{\\top}{ij} $$ 因此， $$ \\frac{\\partial {\\bf |X|}}{\\partial X{ij}}=({\\bf X^})^{\\top}{ij} $$ 故有 $$ {\\rm d}{\\bf |X|}=\\sum{i=1}^{n}\\sum_{j=1}^{n}({\\bf X^})^{\\top}{ij}{\\rm d}X{ij} $$ 由前证引理，有 $$ {\\rm d}{\\bf |X|}={\\rm tr}({\\bf X^*}{\\rm d}{\\bf X}) $$ 证毕。\n矩阵的 Hadamard 积\n定义矩阵 ${\\bf A} \\in {\\frak R}^{n \\times m}$与 ${\\bf B} \\in {\\frak R}^{n \\times m}$的 Hadamard 积为$[A_{ij}B_{ij}]_{n \\times m}$，记作${\\bf A}\\odot {\\bf B}$ ，则有结论 $$ {\\rm d}({ {\\bf A \\odot B})}={\\rm d}{\\bf A \\odot B}+{\\bf A}\\odot{\\rm d}{\\bf B} $$ 证明略。\n逐元素标量函数\n我们规定：若有一个函数 $f:{\\frak R \\rightarrow R}$和矩阵 ${\\bf A} \\in {\\frak R}^{n \\times m}$，则定义记号 $f({\\bf A}) = [f(A_{ij})]{n \\times m}$ 及$f^{:’}({\\bf A})=[f^{:’}(A{ij})]_{n \\times m}$ 。 则有结论 $$ {\\rm d}f({\\bf A})=f^{:’}({\\bf A})\\odot{\\rm d}{\\bf A} $$ 证明略。\n全微分法则\n设 ${\\bf A}_1 \\in {\\frak R}^{m_1 \\times n_1},{\\bf A}_2 \\in {\\frak R}^{m_2 \\times n_2},\\cdots,{\\bf A}_p \\in {\\frak R}^{m_p \\times n_p}$，考虑 $\\exists f \\in {\\frak R}$ 且$f = \\sigma({\\bf A}_1,{\\bf A}_2,\\cdots,{\\bf A}p)$ ，则有 $$ {\\rm d}f=\\sum{i=1}^{p}{\\rm tr}(\\frac{\\partial f}{\\partial {\\bf A}_i}^\\top{\\rm d}{\\bf A}_i) $$ 证明略。\n标量对矩阵求导 求导法则与迹技巧 设 $f:{\\frak R^{\\it n \\times m} \\rightarrow R}$, ${\\bf A} \\in {\\frak R}^{n \\times m}$；考虑从矩阵微分的定义式 ${\\rm d}f={\\rm tr}(\\dfrac{\\partial f}{\\partial {\\bf A}}^{\\top}{\\rm d}{\\bf A})$无法获得$\\dfrac{\\partial f}{\\partial {\\bf A}}$ 的显式解，在左侧的${\\rm d}f$ 已知的情况下，必须将其写为右侧的形式方可求得导数$\\dfrac{\\partial f}{\\partial {\\bf A}}$ 。为此，我们引入矩阵的迹运算的一些性质，称作迹技巧：\n标量套上迹：$a = {\\rm tr}(a),;a \\in {\\frak R}$ 。\n转置：${\\rm tr}({\\bf A^{\\top}})={\\rm tr}({\\bf A})$ 。\n线性：${\\rm tr}({\\bf A \\pm B})={\\rm tr}({\\bf A}) \\pm {\\rm tr}({\\bf B}),;{\\rm tr}(r{\\bf A})=r{\\rm tr}({\\bf A}),;r\\in {\\frak R}$ 。\n矩阵乘法：\n设 ${\\bf A,B^{\\top}} \\in {\\frak R^{\\it n \\times m}}$，则${\\rm tr}({\\bf AB}) = {\\rm tr}({\\bf BA}) = \\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m}A_{ij}B_{ji}$ 。\n设 ${\\bf A_1,A_2,\\cdots,A_n} \\in {\\frak R}^{n \\times n}$ ，则 $$ \\begin{aligned} {\\rm tr}({\\bf A_1 A_2 A_3 \\cdots A_n}) \u0026= {\\rm tr}({\\bf A_2 A_3 \\cdots A_n A_1}) \\ \u0026= {\\rm tr}({\\bf A_3 A_4 \\cdots A_n A_1 A_2}) \\ \u0026= \\cdots \\ \u0026= {\\rm tr}({\\bf A_{n-1}A_n A_1 \\cdots A_{n-2}}) \\ \u0026= {\\rm tr}({\\bf A_n A_1 \\cdots A_{n-2}A_{n-1}}) \\end{aligned} $$\n这称为循环不变性。更一般地，对 $\\bf A_1 , A_2, \\cdots A_n$ 不全为方阵的情况，在所有可能出现的循环乘积中，凡是存在的循环乘积其迹都相同。\n当且仅当 ${\\bf A_1 A_2 \\cdots A_n} \\in {\\frak R}^{n \\times n}$且均为对称矩阵时，这些矩阵以所有可能的$n!$ 个顺序排列构成的乘积的迹均相同。\n矩阵乘法与 Hadamard 积交换\n设 ${\\bf A,B,C} \\in {\\frak R}^{n \\times m}$ ，则 $$ {\\rm tr}({\\bf A}^{\\top}({\\bf B \\odot C})) = {\\rm tr}(({\\bf A \\odot B})^\\top {\\bf C})=\\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^m A_{ij}B_{ij}C_{ij} $$\n由此可以得出结论：已知 $f:{\\frak R^{\\it n \\times m} \\rightarrow R}$, ${\\bf A} \\in {\\frak R}^{n \\times m}$时，若 $f$是由矩阵加减乘法、逆、行列式、逐元素函数等运算构成，则可运用矩阵微分的运算法则在有限次内得到 ${\\rm d}f$，由于${\\rm d}f$ 是标量，故可直接套上迹运算符后，将${\\rm tr}({\\rm d}f)$ 内除${\\rm d}\\bf A$ 外其他项交换至其左侧，写成${\\rm tr}(\\dfrac{\\partial f}{\\partial \\bf A}^\\top {\\rm d}{\\bf A})$ 的形式，即可获得导数。\n复合函数求导法则 设 $f:{\\frak R^{\\it n \\times m} \\rightarrow R}$，$\\sigma : {\\frak R^{\\it p \\times q} \\rightarrow R^{\\it n \\times m}}$，${\\bf X} \\in {\\frak R}^{p \\times q}$，${\\bf Y} \\in {\\frak R}^{n \\times m}$，且${\\bf Y} = \\sigma({\\bf X})$ ，在已知$\\dfrac {\\partial f}{\\partial {\\bf Y}}$ 的情况下，如何求$\\dfrac{\\partial f}{\\partial {\\bf X}}$ ？\n显然，此处链式法则 $\\dfrac{\\partial f}{\\partial {\\bf X}}=\\dfrac{\\partial f}{\\partial {\\bf Y}}\\dfrac{\\partial {\\bf Y}}{\\partial {\\bf X}}$不成立，因为此处 $\\dfrac{\\partial {\\bf Y}}{\\partial {\\bf X}}$是未定义的。因此，考虑矩阵微分定义式 ${\\rm d} f={\\rm tr}(\\dfrac{\\partial f}{\\partial {\\bf Y}}^\\top {\\rm d}{\\bf Y})$，可将 ${\\bf Y}=\\sigma({\\bf X})$ 代入${\\rm d}\\bf Y$ 后将原式写作${\\rm d}f={\\rm tr}(g(\\dfrac{\\partial f}{\\partial \\bf Y},\\bf X)^\\top {\\rm d}{\\bf X})$ 的形式，此时即有$\\dfrac{\\partial f}{\\partial \\bf X}=g({\\dfrac{\\partial f}{\\partial \\bf Y}, \\bf X})$ 。\n${\\bf E{\\scriptsize XAMPLE}}.$设 ${\\bf A} \\in {\\frak R}^{n \\times p},;{\\bf B} \\in {\\frak R}^{q \\times m}$且 $\\bf Y=AXB$ ，已知$\\dfrac{\\partial f}{\\partial \\bf Y}$ ，求$\\dfrac{\\partial f}{\\partial \\bf X}$ 。\n${\\bf S{\\scriptsize OLUTION}}.$\n$$ \\begin{aligned} {\\rm d}f \u0026= {\\rm tr}({\\frac{\\partial f}{\\partial \\bf Y}}^\\top {\\rm d}{\\bf Y}) \\ \u0026= {\\rm tr}({\\frac{\\partial f}{\\partial \\bf Y}}^\\top{\\rm d}({\\bf AXB})) \\ \u0026= {\\rm tr}({\\frac{\\partial f}{\\partial \\bf Y}}^\\top{\\bf A}({\\rm d}{\\bf X}){\\bf B}) \\ \u0026= {\\rm tr}({\\bf B}{\\frac{\\partial f}{\\partial \\bf Y}}^\\top{\\bf A}{\\rm d}{\\bf X}) \\ \u0026= {\\rm tr}(({ {\\bf A}^\\top {\\frac{\\partial f}{\\partial \\bf Y}} {\\bf B}^\\top})^\\top {\\rm d}{\\bf X}) \\end{aligned} $$\n一些例子 ${\\bf E{\\scriptsize XAMPLE};1}.$\n设 ${\\bf a} \\in {\\frak R}^{m},;{\\bf b}\\in{\\frak R}^{n},;{\\bf X}\\in{\\frak R}^{n \\times m}, ; f \\in \\frak R$，且已知 $f = {\\bf a^\\top Xb}$ ，求$\\dfrac{\\partial f}{\\partial X}$。\n${\\bf S{\\scriptsize OLUTION}}.$ 易得 $$ {\\rm d}f = {\\rm d}({\\bf a^\\top Xb}) = {\\bf a^\\top}({\\rm d}{\\bf X}){\\bf b} $$ 又 $$ {\\rm d}f={\\rm tr}({\\rm d}f) $$ 故 $$ \\begin{aligned} {\\rm d}f \u0026= {\\rm tr}({\\bf a^\\top}({\\rm d}{\\bf X}){\\bf b}) \\ \u0026= {\\rm tr}({\\bf ba^\\top}{\\rm d}{\\bf X}) \\ \u0026= {\\rm tr}(({\\bf ab^\\top})^\\top {\\rm d}{\\bf X}) \\end{aligned} $$ 因此 $$ \\frac{\\partial f}{\\partial \\bf X}={\\bf ab^\\top} $$ ${\\bf N{\\scriptsize OTE}}.$不能直接$\\dfrac{\\partial ({\\bf a^\\top Xb})}{\\partial \\bf X}={\\bf a^\\top}\\dfrac{\\partial \\bf X}{\\partial \\bf X}{\\bf b}$ 。这是不合法的，且我们并未定义标量对矩阵导数的运算法则。\n${\\bf E{\\scriptsize XAMPLE};2}.$\n设 ${\\rm exp}(x)={\\rm e}^x,; {\\bf a} \\in {\\frak R}^m,; {\\bf b} \\in {\\frak R}^n, ; {\\bf X} \\in {\\frak R}^{n \\times m}, f \\in {\\frak R}$，且已知 $f={\\bf a^\\top}{\\rm exp}({\\bf Xb})$ ，求$\\dfrac{\\partial f}{\\partial \\bf X}$ .\n${\\bf S{\\scriptsize OLUTION}}.$ 易得 $$ \\begin{aligned} {\\rm d}f \u0026= {\\rm d}({\\bf a^\\top}{\\rm exp}({\\bf Xb})) = {\\bf a^\\top}{\\rm d}({\\rm exp}({\\bf Xb})) \\ \u0026= {\\bf a^\\top}({\\rm exp}({\\bf Xb}) \\odot {\\rm d}({\\bf Xb})) \\ \u0026= {\\bf a^\\top}({\\rm exp}({\\bf Xb}) \\odot ({\\rm d}{\\bf X}){\\bf b}) \\ \u0026= {\\rm tr}({\\bf a^\\top}({\\rm exp}({\\bf Xb}) \\odot ({\\rm d}{\\bf X}){\\bf b})) \\ \u0026= {\\rm tr}(({\\bf a} \\odot ({\\rm exp}({\\bf Xb}))^\\top ({\\rm d}{\\bf X}){\\bf b})) \\ \u0026= {\\rm tr}({\\bf b}({\\bf a} \\odot ({\\rm exp}({\\bf Xb}))^\\top {\\rm d}{\\bf X})) \\ \u0026= {\\rm tr}(({\\bf a} \\odot {\\rm exp}({\\bf Xb})){\\bf b}^\\top)^\\top {\\rm d}{\\bf X}) \\ \\end{aligned} $$ 因此 $$ \\frac{\\partial f}{\\partial \\bf X}=({\\bf a} \\odot {\\rm exp}({\\bf Xb})){\\bf b}^\\top $$\n${\\bf E{\\scriptsize XAMPLE};3}.$\n设 ${\\bf W} \\in {\\frak R}^{l \\times m},;{\\bf X}\\in{\\frak R}^{m \\times n},;{\\bf Y}\\in{\\frak R}^{l \\times n},$对称矩阵 ${\\bf M} \\in {\\frak R}^{l \\times l},;\\sigma:{\\frak R \\rightarrow R},;f \\in {\\frak R}$，且已知$f={\\rm tr}({ {\\bf Y^\\top MY}}),;{\\bf Y}=\\sigma({\\bf WX})$ ，求$\\dfrac{\\partial f}{\\partial \\bf X}$ 。\n${\\bf S{\\scriptsize OLUTION}}.$ 易得 $$ \\begin{aligned} {\\rm d}f \u0026= {\\rm d}({\\rm tr}({\\bf Y^\\top MY})) = {\\rm tr}({\\rm d}({\\bf Y^\\top MY})) \\ \u0026= {\\rm tr}(({\\rm d}{\\bf Y^\\top}){\\bf MY}+{\\bf Y^\\top}{\\rm d}({\\bf MY})) \\ \u0026= {\\rm tr}(({\\rm d}{\\bf Y})^\\top{\\bf MY}+{\\bf Y^\\top M}{\\rm d}{\\bf Y}) \\ \u0026= {\\rm tr}(({\\rm d}{\\bf Y})^\\top{\\bf MY})+{\\rm tr}({\\bf Y^\\top M}{\\rm d}{\\bf Y}) \\ \\end{aligned} $$ 此时考虑迹的转置不变性，有 $$ {\\rm tr}(({\\rm d}{\\bf Y})^\\top{\\bf MY})={\\rm tr}({\\bf Y^\\top M^\\top}{\\rm d}{\\bf Y}) $$ 因此 $$ {\\rm d}f={\\rm tr}({\\bf Y^\\top}({\\bf M+M^\\top}){\\rm d}{\\bf Y})={\\rm tr}(({\\bf 2M} {\\bf Y})^\\top {\\rm d}{\\bf Y}) $$ 将 ${\\bf Y}=\\sigma({\\bf WX})$ 代入得 $$ \\begin{aligned} {\\rm d}f \u0026= {\\rm tr}(({\\bf 2M}\\sigma({\\bf WX}))^\\top{\\rm d}\\sigma({\\bf WX})) \\ \u0026= {\\rm tr}(({\\bf 2M}\\sigma({\\bf WX}))^\\top(\\sigma^{;’}({\\bf WX}) \\odot ({\\bf W}{\\rm d}{\\bf X}))) \\ \u0026= {\\rm tr}(({\\bf 2M}\\sigma({\\bf WX}) \\odot\\sigma^{;’}({\\bf WX})^\\top ({\\bf W}{\\rm d}{\\bf X}))) \\ \u0026= {\\rm tr}(({\\bf W^\\top}({\\bf 2M}\\sigma({\\bf WX}) \\odot\\sigma^{;’}({\\bf WX})))^\\top {\\rm d}{\\bf X}) \\ \\end{aligned} $$ 因此 $$ \\frac{\\partial f}{\\partial \\bf X} = {\\bf W^\\top}({\\bf 2M}\\sigma({\\bf WX}) \\odot\\sigma^{;’}({\\bf WX})) $$\n${\\bf E{\\scriptsize XAMPLE};4}.;;{\\bf L{\\scriptsize INEAR} ;R{\\scriptsize EGRESSION}}.$\n设 ${\\bf Y}\\in{\\frak R}^m,;{\\bf w}\\in{\\frak R}^n,;{\\bf X}\\in{\\frak R}^{m \\times n}$，求${\\rm arg}\\min\\limits_{\\bf w}||{\\bf Xw-y}||^2_2$ 。\n${\\bf S{\\scriptsize OLUTION}}.$记 ${\\bf l}=||{\\bf Xw-y}||^2_2$ ，此时只需令$\\nabla _{\\bf w}l=\\dfrac{\\partial l}{\\partial \\bf w}={\\bf 0}$ 。又易得 $$ \\begin{aligned} {\\rm d}l \u0026= {\\rm d}(({\\bf Xw-y})^\\top ({\\bf Xw-y})) \\ \u0026= ({\\rm d}({\\bf Xw-y})^\\top)({\\bf Xw-y})+({\\bf Xw-y})^\\top{\\rm d}({\\bf Xw-y}) \\ \u0026= ({\\rm d}{\\bf w})^\\top {\\bf X}^\\top({\\bf Xw-y})+({\\bf Xw-y})^\\top{\\bf X}{\\rm d}{\\bf w} \\ \u0026= {\\rm tr}(({\\rm d}{\\bf w})^\\top {\\bf X}^\\top({\\bf Xw-y}))+{\\rm tr}(({\\bf Xw-y})^\\top{\\bf X}{\\rm d}{\\bf w}) \\ \u0026= {\\rm tr}(2({\\bf Xw-y})^\\top{\\bf X}{\\rm d}{\\bf w}) \\ \u0026= {\\rm tr}((2{\\bf X}^\\top({\\bf Xw-y}))^\\top{\\rm d}{\\bf w}) \\end{aligned} $$ 因此 $$ \\frac{\\partial l}{\\partial \\bf w}=2{\\bf X^\\top(Xw-y)}={\\bf 0} $$ 解得 $$ {\\bf w}=({\\bf X^\\top X})^{-1}{\\bf X^\\top y} $$\n${\\bf E{\\scriptsize XAMPLE}; 5}.$${\\bf M{\\scriptsize AXIMUM};L{\\scriptsize IKELIHOOD};E{\\scriptsize STIMATION};O{\\scriptsize F};V{\\scriptsize ARIANCE}}.$\n设 ${\\bf x}_1,;{\\bf x}_2,;\\cdots{\\bf x}N;\\sim;\\mathcal{N}({\\boldsymbol \\mu},;{\\bf \\Sigma})$，求${\\bf \\Sigma}$ 的最大似然估计，即，对函数 $$ l={\\rm ln}|{\\bf \\Sigma}|+\\frac{1}{N}\\sum{i=1}^N ({\\bf x}_i-{\\bf \\bar x})^\\top {\\bf \\Sigma}^{-1} ({\\bf x}_i-{\\bf \\bar x}) $$ 求 ${\\bf \\Sigma}$使得$\\dfrac{\\partial l}{\\partial {\\bf \\Sigma}}={\\bf 0}$ 。\n其中，${\\bf x}_1,;{\\bf x}_2,;\\cdots,;{\\bf x}N \\in {\\frak R}^m$，${\\bf \\bar x}=\\dfrac{1}{N}\\sum\\limits{i=1}^N {\\bf x}_i$ ，${\\bf \\Sigma} \\in {\\frak R}^{m \\times m}$ 且是对称正定矩阵，$l \\in \\frak R$ ，$\\rm ln$ 表示自然对数。\n${\\bf S{\\scriptsize OLUTION}}.$ 易得 $$ {\\rm d}l={\\rm d}{\\rm ln}|{\\bf \\Sigma}|+\\frac{1}{N}\\sum_{i=1}^{N}{\\rm d}(({\\bf x}_i-{\\bf \\bar x})^\\top {\\bf \\Sigma}^{-1} ({\\bf x}i-{\\bf \\bar x})) $$ 又 $$ \\begin{aligned} {\\rm dln}|{\\bf \\Sigma}| \u0026= |{\\bf \\Sigma}|^{-1}{\\rm d}|{\\bf \\Sigma}| \\ \u0026= |{\\bf \\Sigma}|^{-1}|{\\bf \\Sigma}|{\\rm tr}({\\bf \\Sigma}^{-1} {\\rm d}{\\bf \\Sigma}) \\ \u0026= {\\rm tr}({\\bf \\Sigma}^{-1} {\\rm d}{\\bf \\Sigma}) \\end{aligned} $$ 且 $$ \\begin{aligned} \\frac{1}{N}\\sum{i=1}^{N}{\\rm d}(({\\bf x}_i-{\\bf \\bar x})^\\top {\\bf \\Sigma}^{-1} ({\\bf x}i-{\\bf \\bar x})) \u0026= \\frac{1}{N}\\sum{i=1}^{N}({\\bf x}_i-{\\bf \\bar x})^\\top({\\rm d}{\\bf \\Sigma}^{-1})({\\bf x}i-{\\bf \\bar x}) \\ \u0026= -\\frac{1}{N}\\sum{i=1}^{N}({\\bf x}_i-{\\bf \\bar x})^\\top{\\bf \\Sigma}^{-1}({\\rm d}{\\bf \\Sigma}){\\bf \\Sigma}^{-1}({\\bf x}i-{\\bf \\bar x}) \\end{aligned} $$ 因此 $$ \\begin{aligned} {\\rm d}l \u0026= {\\rm tr}({\\bf \\Sigma}^{-1} {\\rm d}{\\bf \\Sigma})-\\frac{1}{N}\\sum{i=1}^{N}({\\bf x}_i-{\\bf \\bar x})^\\top{\\bf \\Sigma}^{-1}({\\rm d}{\\bf \\Sigma}){\\bf \\Sigma}^{-1}({\\bf x}i-{\\bf \\bar x}) \\ \u0026= {\\rm tr}({\\bf \\Sigma}^{-1} {\\rm d}{\\bf \\Sigma})-\\frac{1}{N}\\sum{i=1}^{N}{\\rm tr}(({\\bf x}_i-{\\bf \\bar x})^\\top{\\bf \\Sigma}^{-1}({\\rm d}{\\bf \\Sigma}){\\bf \\Sigma}^{-1}({\\bf x}i-{\\bf \\bar x})) \\ \u0026= {\\rm tr}({\\bf \\Sigma}^{-1} {\\rm d}{\\bf \\Sigma})-\\frac{1}{N}\\sum{i=1}^{N}{\\rm tr}({\\bf \\Sigma}^{-1}({\\bf x}_i-{\\bf \\bar x})({\\bf x}i-{\\bf \\bar x})^\\top{\\bf \\Sigma}^{-1}{\\rm d}{\\bf \\Sigma}) \\ \u0026= {\\rm tr}(({\\bf \\Sigma}^{-1}-{\\bf \\Sigma}^{-1}\\left(\\sum{i=1}^N ({\\bf x}_i-{\\bf \\bar x})({\\bf x}i-{\\bf \\bar x})^\\top\\right){\\bf \\Sigma}^{-1}){\\rm d}{\\bf \\Sigma}) \\end{aligned} $$ 故 $$ \\frac{\\partial l}{\\partial \\bf \\Sigma}=({\\bf \\Sigma}^{-1}-{\\bf \\Sigma}^{-1}\\left(\\sum{i=1}^N ({\\bf x}_i-{\\bf \\bar x})({\\bf x}i-{\\bf \\bar x})^\\top\\right){\\bf \\Sigma}^{-1})^\\top $$ 令 $\\dfrac{\\partial l}{\\partial \\bf \\Sigma}={\\bf 0}$ ，得 $$ \\begin{aligned} {\\bf \\Sigma}^{-1}-{\\bf \\Sigma}^{-1}\\left(\\sum{i=1}^N ({\\bf x}_i-{\\bf \\bar x})({\\bf x}i-{\\bf \\bar x})^\\top\\right){\\bf \\Sigma}^{-1} \u0026= {\\bf 0} \\ {\\bf \\Sigma}^{-1}\\left(\\sum{i=1}^N ({\\bf x}_i-{\\bf \\bar x})({\\bf x}i-{\\bf \\bar x})^\\top\\right){\\bf \\Sigma}^{-1} \u0026= {\\bf \\Sigma}^{-1} \\ \\left(\\sum{i=1}^N ({\\bf x}_i-{\\bf \\bar x})({\\bf x}i-{\\bf \\bar x})^\\top\\right){\\bf \\Sigma}^{-1} \u0026= {\\bf I} \\ {\\bf \\Sigma} \u0026= \\sum{i=1}^N ({\\bf x}_i-{\\bf \\bar x})({\\bf x}i-{\\bf \\bar x})^\\top \\end{aligned} $$ 故 $\\bf \\Sigma$ 的最大似然估计为 $$ {\\bf \\Sigma}=\\sum{i=1}^N ({\\bf x}_i-{\\bf \\bar x})({\\bf x}_i-{\\bf \\bar x})^\\top $$\n${\\bf E{\\scriptsize XAMPLE};6}.$${\\bf M{\\scriptsize ULTINOMIAL};L{\\scriptsize OGISTIC};R{\\scriptsize EGRESSION}}.$\n定义 $\\rm Softmax$函数 $\\mathcal{S} : {\\frak R}^m \\rightarrow {\\frak R}$且 $\\mathcal{S} ({\\bf x})=\\dfrac{ {\\rm exp}({\\bf x})}{ {\\bf 1}^\\top {\\rm exp}({\\bf x})}$ ，其中${\\bf 1}$ 指全$1$ 向量。\n设 ${\\bf y} \\in {\\frak R}^m$除一个元素为 $1$，其他元素均为 $0$ ；${\\bf x} \\in {\\frak R}^n$ ，${\\bf W} \\in {\\frak R}^{m \\times n}$ ，$l \\in {\\frak R}$。已知$l=-{\\bf y}^\\top \\ln\\mathcal{S}({\\bf Wx})$ ，求$\\dfrac{\\partial l}{\\partial \\bf W}$ 。\n${\\bf S{\\scriptsize OLUTION}}.$先对$l$ 做化简，易得 $$ \\begin{aligned} l \u0026= -{\\bf y}^\\top \\ln\\mathcal{S}({\\bf Wx}) \\ \u0026=-{\\bf y}^\\top\\ln\\frac{\\exp({\\bf Wx})}{ {\\bf 1}^\\top\\exp({\\bf Wx})} \\ \u0026= -{\\bf y}^\\top(\\ln \\exp({\\bf Wx})-{\\bf 1}\\ln ({\\bf 1}^\\top\\exp({\\bf Wx})) \\ \u0026= -{\\bf y^\\top Wx}+\\ln({\\bf 1}^\\top \\exp({\\bf Wx})) \\end{aligned} $$\n${\\bf N{\\scriptsize OTE};1}.$注意 ${\\bf 1}^\\top \\exp({\\bf Wx}) \\in {\\frak R}$，而$\\ln\\exp({\\bf Wx}) \\in {\\frak R}^m$ ，因此要用${\\bf 1}$ 补全成向量。\n${\\bf N{\\scriptsize OTE};2}.$${\\bf y}^\\top{\\bf 1}=1$ 。\n因此 $$ \\begin{aligned} {\\rm d}l \u0026= {\\rm d}(-{\\bf y^\\top Wx}+\\ln({\\bf 1}^\\top \\exp({\\bf Wx}))) \\ \u0026= -{\\bf y}^\\top({\\rm d}{\\bf W}){\\bf x},+,{\\rm d}\\ln({\\bf 1}^\\top\\exp({\\bf Wx})) \\ \u0026= -{\\bf y}^\\top({\\rm d}{\\bf W}){\\bf x},+,\\frac{ {\\bf 1}^\\top\\left(\\exp\\left({\\bf Wx}\\right)\\odot\\left(\\left({\\rm d}{\\bf W}\\right){\\bf x}\\right)\\right)}{ {\\bf 1}^\\top \\exp({\\bf Wx})} \\ \u0026= -{\\bf y}^\\top({\\rm d}{\\bf W}){\\bf x},+,\\frac{\\exp({\\bf Wx})^\\top(({\\rm d}{\\bf W}){\\bf x})}{ {\\bf 1}^\\top \\exp({\\bf Wx})} \\end{aligned} $$\n${\\bf N{\\scriptsize OTE}}.$${\\bf 1^\\top}({\\bf u \\odot v})={\\bf u^\\top v}$ 。\n因此 $$ \\begin{aligned} {\\rm d}l \u0026= -{\\rm tr}({\\bf y}^\\top({\\rm d}{\\bf W}){\\bf x}) + {\\rm tr}\\left(\\frac{\\exp({\\bf Wx})^\\top}{ {\\bf 1}^\\top \\exp({\\bf Wx})}({\\rm d}{\\bf W}){\\bf x}\\right) \\ \u0026= -{\\rm tr}({\\bf y}^\\top({\\rm d}{\\bf W}){\\bf x}) + {\\rm tr}\\left(\\mathcal{S}({\\bf Wx})^\\top({\\rm d}{\\bf W}){\\bf x}\\right) \\ \u0026= {\\rm tr}({\\bf x}(\\mathcal{S}({\\bf Wx})^\\top-{\\bf y^\\top}){\\rm d}{\\bf W}) \\ \u0026= {\\rm tr}\\left( \\left( \\mathcal{S}\\left({\\bf Wx}-{\\bf y}\\right) {\\bf x}^\\top \\right)^\\top {\\rm d}{\\bf W} \\right) \\end{aligned} $$ 因此 $$ \\frac{\\partial l}{\\partial \\bf W}=\\mathcal{S}({\\bf Wx-y}){\\bf x}^\\top $$\n${\\bf E{\\scriptsize XAMPLE};7}.$${\\bf B{\\scriptsize ACKPROPAGATION};O{\\scriptsize F};T{\\scriptsize HE};2{\\scriptsize-LAYER};N{\\scriptsize EURAL};N{\\scriptsize ETWORK}}.$\n定义 $\\rm Sigmoid$函数 $\\sigma : {\\frak R \\rightarrow R}$ 且$\\sigma(x)=\\dfrac{1}{1+{\\rm exp}(-x)}$ 。\n设 ${\\bf y} \\in {\\frak R}^m$除一个元素为 $1$ ，其他元素均为$0$ ；${\\bf W}_2 \\in {\\frak R}^{m \\times p}$ ，${\\bf W}_1 \\in {\\frak R}^{p \\times n}$ ，${\\bf x} \\in {\\frak R}^n$ ，$l \\in {\\frak R}$ 。\n已知 $l = -{\\bf y^\\top}\\ln\\mathcal{S}({ {\\bf W}_2\\sigma({\\bf W}1{\\bf x})})$，求 $\\dfrac{\\partial l}{\\partial {\\bf W}{1}}$ 和$\\dfrac{\\partial l}{\\partial {\\bf W}_2}$ 。\n${\\bf S{\\scriptsize OLUTION}}.$设${\\bf a}_2 = { {\\bf W}_2\\sigma({\\bf W}_1{\\bf x})}$ ，易得 $$ \\begin{aligned} {\\rm d}l \u0026= -{\\bf y^\\top}{\\rm d}\\ln\\mathcal{S}({\\bf a}_2) \\ \u0026= -{\\bf y^\\top}{\\rm d}(\\ln\\exp({\\bf a}_2)-{\\bf 1}\\ln({\\bf 1^\\top}\\exp({\\bf a}_2))) \\ \u0026= -{\\bf y^\\top}{\\rm d}{\\bf a}_2 + {\\rm d}\\ln({\\bf 1^\\top}\\exp({\\bf a}_2)) \\ \u0026= -{\\bf y^\\top}{\\rm d}{\\bf a}_2 + \\frac{ {\\bf 1^\\top}(\\exp({\\bf a}_2)\\odot{\\rm d}({\\bf a}_2))}{ {\\bf 1^\\top}\\exp({\\bf a}_2)} \\ \u0026= -{\\bf y^\\top}{\\rm d}{\\bf a}_2 + \\frac{\\exp({\\bf a}_2)^\\top}{ {\\bf 1^\\top}\\exp({\\bf a}_2)}{\\rm d}{\\bf a}_2 \\ \u0026= (\\mathcal{S}({\\bf a}_2)-{\\bf y})^\\top{\\rm d}{\\bf a}_2 \\end{aligned} $$ 因此 $$ \\frac{\\partial l}{\\partial {\\bf a}_2} = \\mathcal{S}({\\bf a}_2)-{\\bf y} $$ 又，设 ${\\bf a}_1 = {\\bf W}_1 {\\bf x}$，${\\bf h}_1 = \\sigma({\\bf a}_1)$ ，则${\\bf a}_2 = {\\bf W}_2{\\bf h}_1$ 。因此 $$ \\begin{aligned} {\\rm d}l \u0026= {\\rm tr}\\left( \\frac{\\partial l}{\\partial {\\bf a}_2}^\\top {\\bf W}_2{\\rm d}{\\bf h}_1 \\right) + {\\rm tr}\\left({\\bf h}_1 \\frac{\\partial l}{\\partial {\\bf a}_2}^\\top {\\rm d}{\\bf W}_2 \\right) \\ \u0026= {\\rm tr}\\left( \\left({\\bf W}_2^\\top\\frac{\\partial l}{\\partial {\\bf a}_2}\\right)^\\top {\\rm d}{\\bf h}_1 \\right) + {\\rm tr}\\left( \\left( \\frac{\\partial l}{\\partial {\\bf a}_2} {\\bf h}_1^\\top \\right)^\\top {\\rm d}{\\bf W}_2 \\right) \\ \\end{aligned} $$ 分别记 $$ \\begin{aligned} {\\rm d}l_1 \u0026= {\\rm tr}\\left( \\left({\\bf W}_2^\\top\\frac{\\partial l}{\\partial {\\bf a}_2}\\right)^\\top {\\rm d}{\\bf h}_1 \\right) \\ {\\rm d}l_2 \u0026= {\\rm tr}\\left( \\left( \\frac{\\partial l}{\\partial {\\bf a}_2} {\\bf h}_1^\\top \\right)^\\top {\\rm d}{\\bf W}_2 \\right) \\end{aligned} $$\n由全微分法则，有 $$ \\begin{aligned} \\frac{\\partial l}{\\partial {\\bf h}_1} \u0026= {\\bf W}_2^\\top\\frac{\\partial l}{\\partial {\\bf a}_2} \\ \\frac{\\partial l}{\\partial {\\bf W}_2} \u0026= \\frac{\\partial l}{\\partial {\\bf a}_2} {\\bf h}_1^\\top = (\\mathcal{S}({\\bf W}_2{\\bf h}_1)-{\\bf y})\\sigma({\\bf W}_1{\\bf x})^\\top \\end{aligned} $$ 又，考虑 $$ \\begin{aligned} {\\rm d}l_1 \u0026= {\\rm tr}\\left( \\frac{\\partial l}{\\partial {\\bf h}_1}^\\top {\\rm d}{\\bf h}_1 \\right) \\ \u0026= {\\rm tr}\\left(\\frac{\\partial l}{\\partial {\\bf h}_1}^\\top {\\rm d}\\sigma\\left( {\\bf a}_1 \\right) \\right) \\ \u0026= {\\rm tr}\\left( \\frac{\\partial l}{\\partial {\\bf h}_1}^\\top \\left( \\sigma^{’}\\left( {\\bf a}_1 \\right) \\odot {\\rm d}{\\bf a}_1 \\right) \\right) \\ \u0026= {\\rm tr}\\left( \\left( \\frac{\\partial l}{\\partial {\\bf h}_1} \\odot \\sigma^{’}\\left( {\\bf a}_1 \\right) \\right)^\\top {\\rm d}{\\bf a}_1 \\right) \\ \\end{aligned} $$ 可得 $$ \\frac{\\partial l}{\\partial {\\bf a}_1} = \\frac{\\partial l}{\\partial {\\bf h}_1} \\odot \\sigma^{’}\\left( {\\bf a}_1 \\right) $$ 继续使用复合函数求导法则，得 $$ \\begin{aligned} {\\rm d}l_1 \u0026= {\\rm tr}\\left( \\frac{\\partial l}{\\partial {\\bf a}_1}^\\top {\\rm d}{\\bf a}_1 \\right) \\ \u0026= {\\rm tr}\\left( \\frac{\\partial l}{\\partial {\\bf a}_1}^\\top ({\\rm d}{\\bf W}_1){\\bf x} \\right) \\ \u0026= {\\rm tr}\\left( {\\bf x}\\frac{\\partial l}{\\partial {\\bf a}_1}^\\top {\\rm d}{\\bf W}_1 \\right) \\ \u0026= {\\rm tr}\\left( (\\frac{\\partial l}{\\partial {\\bf a}_1}{\\bf x}^\\top)^\\top {\\rm d}{\\bf W}_1 \\right) \\ \\end{aligned} $$ 因此 $$ \\begin{aligned} \\frac{\\partial l}{\\partial {\\bf W}_1} \u0026= \\frac{\\partial l}{\\partial {\\bf a}_1}{\\bf x}^\\top \\ \u0026= (\\frac{\\partial l}{\\partial {\\bf h}_1} \\odot \\sigma^{’}\\left( {\\bf a}_1 \\right)){\\bf x^\\top} \\ \u0026= (({\\bf W}_2^\\top\\frac{\\partial l}{\\partial {\\bf a}_2}) \\odot \\sigma^{’}\\left( {\\bf W}_1{\\bf x} \\right)){\\bf x^\\top} \\ \u0026= (({\\bf W}_2^\\top(\\mathcal{S}({\\bf a}_2)-{\\bf y}) \\odot \\sigma^{’}\\left( {\\bf W}_1{\\bf x} \\right)){\\bf x^\\top} \\ \\end{aligned} $$ 综上，有 $$ \\begin{aligned} \\frac{\\partial l}{\\partial {\\bf W}_1} \u0026= (({\\bf W}_2^\\top(\\mathcal{S}({\\bf W}_2{\\bf h}_1)-{\\bf y}) \\odot \\sigma^{’}\\left( {\\bf W}_1{\\bf x} \\right)){\\bf x^\\top} \\ \\frac{\\partial l}{\\partial {\\bf W}_2} \u0026= (\\mathcal{S}({\\bf W}_2{\\bf h}_1)-{\\bf y})\\sigma({\\bf W}_1{\\bf x})^\\top \\end{aligned} $$\n","description":"","tags":null,"title":"矩阵微积分(一)：标量对矩阵求导","uri":"/posts/%E7%9F%A9%E9%98%B5%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B8%80%E6%A0%87%E9%87%8F%E5%AF%B9%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/"},{"categories":["Notes"],"content":"最近有在word里书写大量数学公式的需求，但word自带的公式编辑器难用的一批而且我又没买office 365，因此想到用mathjax将latex公式转为mathml code，之后便可直接在word中显示。\n可用的一个基于mathjax的latex在线编辑器：\n在生成的latex公式图片上右击\n之后将生成的mathml code粘贴到word中即可，注意word对复杂mathml的支持不是很好\n","description":"","tags":null,"title":"在word中借助mathjax插入latex公式","uri":"/posts/%E5%9C%A8word%E4%B8%AD%E5%80%9F%E5%8A%A9mathjax%E6%8F%92%E5%85%A5latex%E5%85%AC%E5%BC%8F/"},{"categories":["Computer Science","Discrete-time System"],"content":"Note for the course Discrete-Time System Analysis.\n1.1 Introduction 1.2 Discrete-Time Signals Discrete-time Variable If the time variable $t$only takes on discrete values $t=t_{n}$for some range of integer values of$n$, then$t$ is called discrete-time variable.\nDiscrete-time Signal If a continuous-time signal $x(t)$is a function of discrete-time variable $t_{n}$, then the signal $x(t_{n})$ is a discrete-time signal, which is called the sampled version of the continuous-time function$x(t)$.\nIf we let $t_{n}=nT$, then obviously $T$is the sampling interval. When $T$is a constant, such a sampling process is called uniform sampling, instead, nonuniform sampling. Then we could write$x(t_{n})$ in form of$ x[n]$, in which square brackets is needed. And also,$x[n] = x(t_{n}) = x(t)|_{t=nT}=x(nT)$ .\nSome typical examples of discrete-time signals Discrete-Time Unit-Step Function $$ u[n] = \\left{\\begin{matrix} 1,n=0,1,2, \\cdots \\ 0,n=-1,-2,-3,\\cdots \\end{matrix}\\right. $$\nDiscrete-Time Unit-Ramp Function $$ r[n]=nu[n]=\\left{\\begin{matrix} n, n=0,1,2,\\cdots \\ 0,n=-1,-2,-3,\\cdots \\end{matrix}\\right. $$\nUnit Pulse $$ \\delta[n] = \\left{\\begin{matrix} 1,n=0 \\ 0,n \\neq 0 \\end{matrix}\\right. $$\nPeriodic Discrete-Time Signals For a discrete-time signal $x[n]$, if there exists a positive integer $r$which makes that $x[n+r]=x[n]$for all integers n, Then $x[n]$ is called a periodic discrete-time signal and the integer$r$ is period. Fundamental period is the smallest value for positive integer$r$.\nFor example, if we let $x[n]=A\\mathrm{cos}(\\Omega n + \\theta)$, then the signal is periodic if $x[n+r]=A\\mathrm{cos}(\\Omega (n + r)+\\theta) = A\\mathrm{cos}(\\Omega n+\\theta)$ .\nCause $\\mathrm{cos}$is periodic, there is $A\\mathrm{cos}(\\Omega n + \\theta) = A\\mathrm{cos}(\\Omega n + 2 \\pi q + \\theta)$ for all integers$q$ .\nObviously, $x[n]$is periodic when there exists an integer $r$which makes $\\Omega r = 2 \\pi q$for some integers$q$, in equivalent, the discrete-time frequency$\\Omega = \\dfrac{2 \\pi q}{r}$ for some integers$q,r$.\nDiscrete-Time Complex Exponential Signals $$ x[n]=Ca^{n}=|C||a|^{n}\\mathrm{cos}(\\omega _{0}n+\\theta)+j|C||a|^{n}\\mathrm{sin}(\\omega _{0}n + \\theta) $$\nwhere $C = |C|e^{j\\theta}$and$a = |a|e^{j\\omega _{0}}$ .\nDiscrete-Time Rectangular Pulse $$ p_{L}[n] = \\left{\\begin{matrix} 1,;n=-\\dfrac{L-1}{2},\\cdots,-1,0,1,\\cdots,\\dfrac{L-1}{2} \\ 0,; \\mathrm{others} \\end{matrix}\\right. $$\nwhere $L$ is a positive odd integer.\nDigital Signals When a discrete-time signal $x[n]$satiesfies that its values are all belongs to a finite set$\\left{ a_{1},a_{2},\\cdots,a_{n} }\\right.$ , then the signal called a digital signal.\nHowever, the sampled signals don’t have to be digital signals. For example, the sampled unit-ramp function values on a infinite set $\\left{ 0,1,2,\\cdots }\\right.$.\nBinary Signal is a digital signal whose values are all belongs in to set $\\left{ 0,1 }\\right.$.\nTime-Shifted Signals Giving a discrete-time signal $x[n]$and a positive integer$q$ , then\n$x[n-q]$is the $q$-step right shifts of$x[n]$ $x[n + q]$is the $q$-step left shifts of$x[n]$ Discrete-Time Signals defined Interval by Interval Discrete-Time Signals also may be defined Interval by Interval. For example, $$ x[n]=\\left{\\begin{matrix} x_{1}[n],;n_{1}\\leq n \u003c n_{2} \\ x_{2}[n],;n_{2} \\leq n \u003c n_{3} \\ x_{3}[n], ; n \\geq n_{3} \\end{matrix}\\right. $$ Cause the Unit-Step Function satisfies when $n \\geq 0$, $u[n]=1$ , we can use it to write$x[n]$ in such a form $$ x[n]=x_{1}[n]\\cdot(u[n-n_{1}]-u[n-n_{2}]) +x_{2}[n]\\cdot(u[n-n_{2}] - u[n - n_{3}]) +x_{3}[n]\\cdot u[n - n_{3}] \\ = u[n - n_{1}]\\cdot x_{1}[n] +u[n - n_{2}]\\cdot(x_{2}[n] - x_{1}[n]) +u[n - n_{3}]\\cdot(x_{3}[n] - x_{2}[n]) $$\n1.3 Discrete-Time Systems Definition of Discrete-Time Systems and Analysis The Discrete-Time System is a system which transforms discrete-time inputs to discrete-time outputs.\nThe Discrete-Time System Analysis is a process to solve the discrete-time output with discrete-time inputs and discrete-time system.\nFor example. Consider the differential equation $\\dfrac{dv(t)}{dt}+av(t)=bx(t)$, now we resolve time into discrete interval forms of length$\\bigtriangleup$ , so the equation will become $$ \\frac{v(n\\bigtriangleup)-v((n-1)\\bigtriangleup)}{\\bigtriangleup}+av(n \\bigtriangleup)=bx(n \\bigtriangleup) $$ which equals to $$ \\frac{v[n]-v[n-1]}{\\bigtriangleup}+av[n]=bx[n] $$ and $$ v[n]-\\frac{1}{1+a\\bigtriangleup}v[n-1]=\\frac{b\\bigtriangleup}{1+a\\bigtriangleup}x[n] $$\n1.4 Basic Properties of Discrete-Time Systems System with or without memory Given a discrete-time system with input of $x[n]$and output with $y[n]$ , we call the system memoryless when$y[n]$ is only related to input at present time, otherwise we call it is the one with memory.\nFor example, $$ y[n] = \\sum_{k=- \\infty}^{n}x[k] $$ and $$ y[n] = x[n] + x[n - 1] $$ are systems with memory, and $$ y[n]=(2x[n] - x[n]^{2})^{2} $$ is an example of system in memoryless.\nCausality Given a discrete-time system with input of $x[n]$and output with $y[n]$ , we call the system causal when$y[n]$ is only related to input at present and past time, or we call it not causal.\nFor example, $$ y[n]=\\sum_{k=-\\infty}^{n}x[k] $$ is system in causality, but $$ y[n]=x[n-1]+x[n+1] $$ not because $x[n + 1]$ is input in future, and $$ y[n]=x[-n] $$ is also not because when $n$is negative, there is$-n \u003e n$ .\nTime Invariance To a discrete-time system with input of $x[n]$and output of $y[n]$ , we call the system time invariant when a time shifts in the input signal results identical time shifts in the output signal. This is also to say, output$y[n]$ is not explicity related on the varaible of time.\nFor example, $$ y[n]=(n+1)x[n] $$ is not time invariant because $y[n]$has an explicit relationship with time variable$n$.\nand, the system $$ y[n]=x[2n] $$ is also not time invariant, because any time shift in input will be compressed by factor 2.\nAs an example of system which is time invariant, $$ y[n]=10x[n] $$ which is obvious.\nLinearity A system is to be called a linear system when the input consists of a weighted sum of several signals, the output will also be a weighted sum of the responses of the system for each of those signals.\nTo make a proof of a system to be in linearity, we let $y_{1}[n]$is the response of the system to the input $x_{1}[n]$, and$y_{2}[n]$ is the response of the input$x_{2}[n]$ . The system is a linear system if and only if\nAddivity Property\nThe response to $x_{1}[n]+x_{2}[n]$is$y_{1}[n]+y_{2}[n]$.\nHomogeneity Property\nThe response to $ax_{1}[n]$is $ay_{1}[n]$, for$a$ is any complex constant.\nIt’s interesting to find that a system with a linear equation may not be a linear system.\nFor example, considering the system $y[n]=2x[n]+3$, it’s easy to find the system is not linear, because\nFor two inputs $x_{1}[n]$and$x_{2}[n]$, there are\n$x_{1}[n] \\rightarrow y_{1}[n]=2x_{1}[n]+3$\n$x_{2}[n] \\rightarrow y_{2}[n]=2x_{2}[n]+3$\nHowever, the response to input $(x_{1}[n]+x_{2}[n])$ is\n$y_{3}[n]=2(x_{1}[n] + x_{2}[n])+3 \\neq y_{1}[n]+y_{2}[n]$.\nNotice that $y[n]=3$when $x[n]=0$, it reminds us that the system violates the “zero-in/zero-out” property and the zero-input response of the system is$y_{0}[n]=3$.\n","description":"","tags":null,"title":"Notes For Discrete-Time System Analysis [Chapter I. Fundamental Concepts]","uri":"/posts/notes_for_discrete-time_system_analysis_chapter_i._fundamental_concepts/"},{"categories":["Programming Contest","ACM","POJ"],"content":"题面 Description A supermarket has a set Prod of products on sale. It earns a profit px for each product x∈Prod sold by a deadline dx that is measured as an integral number of time units starting from the moment the sale begins. Each product takes precisely one unit of time for being sold. A selling schedule is an ordered subset of products Sell ≤ Prod such that the selling of each product x∈Sell, according to the ordering of Sell, completes before the deadline dx or just when dx expires. The profit of the selling schedule is Profit(Sell)=Σx∈Sellpx. An optimal selling schedule is a schedule with a maximum profit.\nFor example, consider the products Prod={a,b,c,d} with (pa,da)=(50,2), (pb,db)=(10,1), (pc,dc)=(20,2), and (pd,dd)=(30,1). The possible selling schedules are listed in table 1. For instance, the schedule Sell={d,a} shows that the selling of product d starts at time 0 and ends at time 1, while the selling of product a starts at time 1 and ends at time 2. Each of these products is sold by its deadline. Sell is the optimal schedule and its profit is 80.\nWrite a program that reads sets of products from an input text file and computes the profit of an optimal selling schedule for each set of products.\nInput A set of products starts with an integer 0 \u003c= n \u003c= 10000, which is the number of products in the set, and continues with n pairs pi di of integers, 1 \u003c= pi \u003c= 10000 and 1 \u003c= di \u003c= 10000, that designate the profit and the selling deadline of the i-th product. White spaces can occur freely in input. Input data terminate with an end of file and are guaranteed correct.\nOutput For each set of products, the program prints on the standard output the profit of an optimal selling schedule for the set. Each result is printed from the beginning of a separate line.\nSample Input 4 50 2 10 1 20 2 30 1 7 20 1 2 1 10 3 100 2 8 2 5 20 50 10 Sample Output 80 185 Hint The sample input contains two product sets. The first set encodes the products from table 1. The second set is for 7 products. The profit of an optimal schedule for these products is 185.\n题目大意 商店有 $n$件商品 $(0 \\leq n \\leq 10000)$，每件商品各有其利润 $p_{i}$和过期时间$d_{i}$$(1 \\leq p_{i}, d_{i} \\leq 10000)$，现商店每天只欲出售一件商品，且过期商品不能再出售，求问商店可获得的最大利润。\n题解 分析 方法 #1：优先队列+贪心 由于对第 $t$天 $( \\displaystyle t \\in \\bigcup\\limits_{i=1}^{n}d_{i})$可售出的商品最多有 $t$件，因此在第$t$ 天显然总希望售出允许范围内利润前$t$ 大的商品；因此我们动态维护利润前$t$ 大的方案表即可。\n先将商品按过期时间从小到大排序，之后新建一个空的小根堆（权值为商品利润），之后遍历每件商品，对第 $i$ 件商品判断：\n如果有 $d_{i} \u003e i$ ，直接将该商品插入堆。 如果有 $d_{i} = i$ ，判断该商品利润是否高于队首商品利润（当前堆中最小利润），如果是则弹出队首并将该商品插入堆。 之后统计堆中所有商品利润总和即可。\n方法 #2：并查集+贪心 还可以这样考虑：我们在优先卖出利润大的商品的同时，还希望每件商品卖得尽量晚。因此，我们需要维护当前已经有商品出售的日期，根据 $d_{i}$天之前日期的占用情况来确定第$i$ 件商品的出售日期。\n将商品按利润从大到小排序，并建立一个关于日期的并查集。遍历所有商品，对第 $i$ 件商品进行如下操作：\n查询 $d_{i}$所在的树根 $r$ ，并把该商品安排于第$r$ 天售出。 合并 $r$到$r-1$ 。 之后统计所有售出商品利润总和即可。\n代码 方法 #1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 // #include \u003cbits/stdc++.h\u003e #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003ccstdio\u003e #include \u003ccmath\u003e #include \u003ccassert\u003e #include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003cqueue\u003e #include \u003cset\u003e #include \u003cmap\u003e using namespace std; typedef long long ll; typedef long double ld; const int INF = 0x3f3f3f3f; const double PI = acos(-1.0); // #define ffor(_var, _begin, _end, ...) \\ // for(decay\u003cdecltype(_end)\u003e::type _var = _begin; _var \u003c _end; __VA_ARGS__) #define ffor(_var, _begin, _end, ...) \\ for(int _var = _begin; _var \u003c _end; __VA_ARGS__) // #define rfor(_var, _rbegin, _rend, ...) \\ // for(decay\u003cdecltype(_rbegin)\u003e::type _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #define ABS(x) ((x) \u003e 0 ? (x) : -(x)) // #if defined _WIN32 // // #define _WINDEBUG // #include \u003cwindows.h\u003e // inline std::ostream\u0026 yellow(std::ostream \u0026s) { // HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); // SetConsoleTextAttribute(hStdout, // FOREGROUND_GREEN|FOREGROUND_RED|FOREGROUND_INTENSITY); // return s; // } // inline std::ostream\u0026 white(std::ostream \u0026s) { // HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); // SetConsoleTextAttribute(hStdout, // FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); // return s; // } // #elif defined __linux__ // // #define _LINUXDEBUG // #define yellow \"\\033[33;1m\" // #define white \"\\033[0m\" // #endif #if defined _WINDEBUG || defined _LINUXDEBUG #define debug(x...) \\ do { cout \u003c\u003c yellow \u003c\u003c #x \u003c\u003c \" -\u003e \"; err(x); } while(0) void err() { cout \u003c\u003c white \u003c\u003c endl; } template\u003ctypename T, typename... A\u003e void err(T a, A... x) { cout \u003c\u003c a \u003c\u003c ' '; err(x...); } template\u003ctemplate\u003ctypename...\u003e class T, typename t, typename... A\u003e void err(T\u003ct\u003e a, A... x) { for(auto\u0026 v : a) cout \u003c\u003c v \u003c\u003c ' '; err(x...); } #else #define debug(...) #endif /*********************************************************************/ const int MAXN = 10010; struct goods { int p, d; bool operator \u003c (const goods\u0026 g) const { return (d == g.d ? p \u003c g.p : d \u003c g.d); } bool operator \u003e (const goods\u0026 g) const { return (p == g.p ? d \u003e g.d : p \u003e g.p); } friend ostream\u0026 operator \u003c\u003c (ostream\u0026 co, const goods\u0026 g); }; ostream\u0026 operator \u003c\u003c (ostream\u0026 co, const goods\u0026 g) { co \u003c\u003c \"(\" \u003c\u003c g.p \u003c\u003c \", \" \u003c\u003c g.d \u003c\u003c \") \"; return co; } goods a[MAXN]; int main() { ios::sync_with_stdio(false); cin.tie(0); // freopen(\"test.in\", \"r\", stdin); int n = 0; while(cin \u003e\u003e n) { ffor(i, 1, n + 1, i++) { cin \u003e\u003e a[i].p \u003e\u003e a[i].d; } sort(a + 1, a + n + 1); debug(vector\u003cgoods\u003e(a + 1, a + n + 1)); priority_queue\u003cgoods, vector\u003cgoods\u003e, greater\u003cgoods\u003e \u003e q; ffor(i, 1, n + 1, i++) { if(a[i].d \u003e (int)q.size()) { q.push(a[i]); } else if(a[i].d == (int)q.size()) { if(a[i].p \u003e q.top().p) { q.pop(); q.push(a[i]); } } else { while(true); } } vector\u003cgoods\u003e v; ll ans = 0; while(!q.empty()) { v.push_back(q.top()); ans += q.top().p; q.pop(); } debug(v); cout \u003c\u003c ans \u003c\u003c endl; } return 0; } 方法 #2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 /*************************************************************/ #if __cplusplus \u003c 201103L // For jury which unsupports C++11 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003ccmath\u003e #include \u003ccassert\u003e #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003cset\u003e #include \u003cmap\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cqueue\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(__typeof__(_end) _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(__typeof__(_rbegin) _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #define cfor(_var, _cbegin, _cend, ...) \\ for(__typeof__(_cend) _var = _cbegin; _var != _cend; __VA_ARGS__) #else #include \u003cbits/stdc++.h\u003e using namespace std; #define ffor(_var, _begin, _end, ...) \\ for(decay\u003cdecltype(_end)\u003e::type _var = _begin; _var \u003c _end; __VA_ARGS__) #define rfor(_var, _rbegin, _rend, ...) \\ for(decay\u003cdecltype(_rbegin)\u003e::type _var = _rbegin; _var \u003e _rend; __VA_ARGS__) #endif typedef long long ll; typedef long double ld; #define ABS(x) ((x) \u003e 0 ? (x) : -(x)) // #if defined _WIN32 // #define _WINDEBUG // #include \u003cwindows.h\u003e // inline std::ostream\u0026 yellow(std::ostream \u0026s) { // HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); // SetConsoleTextAttribute(hStdout, // FOREGROUND_GREEN|FOREGROUND_RED|FOREGROUND_INTENSITY); // return s; // } // inline std::ostream\u0026 white(std::ostream \u0026s) { // HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); // SetConsoleTextAttribute(hStdout, // FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); // return s; // } // #elif defined __linux__ // #define _LINUXDEBUG // #define yellow \"\\033[33;1m\" // #define white \"\\033[0m\" // #endif #if defined _WINDEBUG || defined _LINUXDEBUG #define ar2vec(_begin, _end) \\ vector\u003cdecay\u003citerator_traits\u003cdecltype(_begin)\u003e::value_type\u003e::type\u003e(_begin, _end) #define debug(x...) \\ do { cout \u003c\u003c yellow \u003c\u003c #x \u003c\u003c \" -\u003e \"; err(x); } while(0) void err() { cout \u003c\u003c white \u003c\u003c endl; } template\u003ctypename T, typename... A\u003e void err(T a, A... x) { cout \u003c\u003c a \u003c\u003c ' '; err(x...); } template\u003ctemplate\u003ctypename...\u003e class T, typename t, typename... A\u003e void err(T\u003ct\u003e a, A... x) { for(auto\u0026 v : a) cout \u003c\u003c v \u003c\u003c ' '; err(x...); } #else #define ar2vec(...) #define debug(...) #endif /*************************************************************/ const int MAXN = 10010; struct dsu { int fa[MAXN]; void init(int n) { ffor(i, 1, n + 1, i++) fa[i] = i; } int get(int x) { return (x == fa[x] ? x : (fa[x] = get(fa[x]))); } void merge(int x, int y) { fa[get(x)] = get(y); } }; struct goods { int p, d; bool operator \u003c (const goods\u0026 g) const { return (p == g.p ? d \u003c g.d : p \u003c g.p); } friend ostream\u0026 operator \u003c\u003c (ostream\u0026 co, const goods\u0026 g); }; ostream\u0026 operator \u003c\u003c (ostream\u0026 co, const goods\u0026 g) { co \u003c\u003c \"(\" \u003c\u003c g.p \u003c\u003c \", \" \u003c\u003c g.d \u003c\u003c \") \"; return co; } dsu d; goods a[MAXN]; int main() { ios::sync_with_stdio(false); cin.tie(0); // freopen(\"test.in\", \"r\", stdin); int n = 0; while(cin \u003e\u003e n) { ffor(i, 1, n + 1, i++) cin \u003e\u003e a[i].p \u003e\u003e a[i].d; sort(a + 1, a + n + 1); debug(ar2vec(a + 1, a + n + 1)); map\u003cint, bool\u003e m; vector\u003cgoods\u003e v; d.init(10005); rfor(i, n, 0, i--) { int id = d.get(a[i].d); debug(i, a[i], id); if(m.find(id) == m.end() \u0026\u0026 id \u003e= 1) { debug(\"test\", i, a[i], id); m.insert(make_pair(id, true)); d.merge(id, id - 1); v.push_back(a[i]); } } debug(v); ll ans = 0; int sz = (int)v.size(); ffor(i, 0, sz, i++) ans += v[i].p; cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","description":"","tags":null,"title":"POJ 1456. Supermarket (优先队列/并查集 + 贪心)","uri":"/posts/poj_1456._supermarket_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97_%E5%B9%B6%E6%9F%A5%E9%9B%86_+_%E8%B4%AA%E5%BF%83/"},{"categories":["Essay"],"content":"重点 End-to-end representation learning for Correlation Filter based tracking (CFnet)\nContext-Aware Correlation Filter Tracking (CACF)\n后者要参考前者的工作 Handcrafted and Deep Trackers: Recent Visual Object Tracking Approaches and Trends\n要赶紧加速看完这篇overview，不能再拖 卷积神经网络从入门到精通\n暑假要讲，再不看就凉了。。。 拓展 Remove Cosine Window from Correlation Filter-based Visual Trackers: When and How\n5月新投到arXiv的论文 关注 Visual Tracking via Dynamic Graph Learning\nLi的第一篇TPAMI，挂了Ming-Hsuan Yang的名字，或许可以关注下？ object locating依赖最大化一个structured svm的classification score，要抓紧看下svm 跟Li的这篇AAAI 17看起来差不多 Learning Patch-Based Dynamic Graph for Visual Tracking，或许是一个文章？（雾 跟之前做representation那篇 Correlation Tracking via Joint Discrimination and Reliability Learning 看起来关系是比较近的 ","description":"","tags":null,"title":"6月下半月暂定计划(完不成的)","uri":"/posts/6%E6%9C%88%E4%B8%8B%E5%8D%8A%E6%9C%88%E6%9A%82%E5%AE%9A%E8%AE%A1%E5%88%92%E5%AE%8C%E4%B8%8D%E6%88%90%E7%9A%84/"},{"categories":["Programming Contest","ACM","POJ"],"content":"题面 Description Mr. Young wishes to take a picture of his class. The students will stand in rows with each row no longer than the row behind it and the left ends of the rows aligned. For instance, 12 students could be arranged in rows (from back to front) of 5, 3, 3 and 1 students.\nX X X X X X X X X X X X ​\nIn addition, Mr. Young wants the students in each row arranged so that heights decrease from left to right. Also, student heights should decrease from the back to the front. Thinking about it, Mr. Young sees that for the 12-student example, there are at least two ways to arrange the students (with 1 as the tallest etc.):\n​\n1 2 3 4 5 1 5 8 11 12 6 7 8 2 6 9 9 10 11 3 7 10 12 4 ​\nMr. Young wonders how many different arrangements of the students there might be for a given arrangement of rows. He tries counting by hand starting with rows of 3, 2 and 1 and counts 16 arrangements:\n​\n123 123 124 124 125 125 126 126 134 134 135 135 136 136 145 146 45 46 35 36 34 36 34 35 25 26 24 26 24 25 26 25 6 5 6 5 6 4 5 4 6 5 6 4 5 4 3 3 ​\nMr. Young sees that counting by hand is not going to be very effective for any reasonable number of students so he asks you to help out by writing a computer program to determine the number of different arrangements of students for a given set of rows.\nInput The input for each problem instance will consist of two lines. The first line gives the number of rows, k, as a decimal integer. The second line contains the lengths of the rows from back to front (n1, n2,…, nk) as decimal integers separated by a single space. The problem set ends with a line with a row count of 0. There will never be more than 5 rows and the total number of students, N, (sum of the row lengths) will be at most 30.\nOutput The output for each problem instance shall be the number of arrangements of the N students into the given rows so that the heights decrease along each row from left to right and along each column from back to front as a decimal integer. (Assume all heights are distinct.) The result of each problem instance should be on a separate line. The input data will be chosen so that the result will always fit in an unsigned 32 bit integer.\nSample Input 1 30 5 1 1 1 1 1 3 3 2 1 4 5 3 3 1 5 6 5 4 3 2 2 15 15 0 Sample Output 1 1 16 4158 141892608 9694845 题目大意 有 $N$个学生（ 身高为 $1$~ $N$ ）排成$k$ 行拍照，从后到前每行分别有$N_{1}, N_{2}, \\cdots, N_{k}$ 个学生。现在要求每行学生从左到右的身高和每列学生从后到前的身高必须按降序排列，求排列这些学生站位的方法总数。\n题解 分析 首先考虑到每行的人数 $N_{i}$是给定的，且在转移过程中需要维护当前学生的站位状态，又注意到本题的数据范围很小（$N \\leq 30$，$k \\leq 5$），因此可以将状态表示为 $f(x_1,x_2,x_3,x_4,x_5)$， 其中 $x_{i}$ 表示第$i$ 行当前的学生数目。\n再注意到安排学生一定是按照 $1$~ $N$的顺序进行的，且当第 $N-1$名学生的站位安排好后，第 $N$ 名学生的站位就随之确定。但第$i$ ($1 \\leq i \u003c N$) 名学生的站位确定时，第$i+1$ 名学生要站在哪一行与前$i$ 名学生的站位有关（因为位置没有填满）；同时注意到，显然这种情况不能出现：\n1 4 2 3 这是因为在第1行尚未填满时，第2行已被率先填满，故 $4$只能被填在第1行剩下的空位中。这要求我们必须尽可能先填满后面的行，再去填充前面的行；即要求对第 $i$行和第$i+1$ 行，任何状态中一定有$x_{i}\u003ex_{i+1}$。此时，行和列的降序关系皆可以得到满足。\n因此设计状态转移方程为 $$ f(x_1,x_2,x_3,x_4,x_5)=f(x_1-1,x_2,x_3,x_4,x_5)+\\ [x_1\u003ex_2] \\cdot f(x_1,x_2-1,x_3,x_4,x_5)+\\ [x_2\u003ex_3] \\cdot f(x_1,x_2,x_3-1,x_4,x_5)+\\ [x_3\u003ex_4] \\cdot f(x_1,x_2,x_3,x_4-1,x_5)+\\ [x_4\u003ex_5] \\cdot f(x_1,x_2,x_3,x_4,x_5-1) $$ 其中记号 $[]$ 是艾弗森约定。\n最终目标为 $f(N_1,N_2,N_3,N_4,N_5)$。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u003calgorithm\u003e #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003ciostream\u003e using namespace std; typedef unsigned int uint; typedef long long ll; int a[6]; uint dp[31][16][11][9][7]; int main() { ios::sync_with_stdio(false); cin.tie(0); // freopen(\"test.in\", \"r\", stdin); // freopen(\"test.out\", \"w\", stdout); int k = 0; while (cin \u003e\u003e k \u0026\u0026 k) { memset(a, 0, sizeof(a)); memset(dp, 0, sizeof(dp)); for (int i = 1; i \u003c= k; i++) cin \u003e\u003e a[i]; dp[1][0][0][0][0] = 1; for (int x1 = 1; x1 \u003c= a[1]; x1++) { for (int x2 = 0; (a[2] == 0) || (x2 \u003c= a[2]); x2++) { for (int x3 = 0; (a[3] == 0) || (x3 \u003c= a[3]); x3++) { for (int x4 = 0; (a[4] == 0) || (x4 \u003c= a[4]); x4++) { for (int x5 = 0; (a[5] == 0) || (x5 \u003c= a[5]); x5++) { dp[x1][x2][x3][x4][x5] += dp[x1 - 1][x2][x3][x4][x5]; if (a[2] \u0026\u0026 x2 \u003e 0 \u0026\u0026 x1 \u003e= x2) { dp[x1][x2][x3][x4][x5] += dp[x1][x2 - 1][x3][x4][x5]; if (a[3] \u0026\u0026 x3 \u003e 0 \u0026\u0026 x2 \u003e= x3) { dp[x1][x2][x3][x4][x5] += dp[x1][x2][x3 - 1][x4][x5]; if (a[4] \u0026\u0026 x4 \u003e 0 \u0026\u0026 x3 \u003e= x4) { dp[x1][x2][x3][x4][x5] += dp[x1][x2][x3][x4 - 1][x5]; if (a[5] \u0026\u0026 x5 \u003e 0 \u0026\u0026 x4 \u003e= x5) { dp[x1][x2][x3][x4][x5] += dp[x1][x2][x3][x4][x5 - 1]; } } } } if (a[5] == 0) break; } if (a[4] == 0) break; } if (a[3] == 0) break; } if (a[2] == 0) break; } } cout \u003c\u003c dp[a[1]][a[2]][a[3]][a[4]][a[5]] \u003c\u003c endl; } return 0; } Bonus Time 这是lyd大佬当年的代码，我佛了，%%%\nvar f:array[1..30,0..30,0..15,0..10,0..9,0..6]of dword; a:array[1..5]of integer; i,j,k,l,m,n,o,p:longint; begin repeat readln(n); if n=0 then break; m:=0; fillchar(a,sizeof(a),0); for i:=1 to n do begin read(a[i]); inc(m,a[i]); end; for i:=1 to m do for j:=0 to a[1] do for k:=0 to a[2] do for l:=0 to a[3] do for o:=0 to a[4] do for p:=0 to a[5] do f[i,j,k,l,o,p]:=0; f[1,1,0,0,0,0]:=1; for i:=1 to m-1 do for j:=1 to a[1] do for k:=0 to a[2] do for l:=0 to a[3] do for o:=0 to a[4] do for p:=0 to a[5] do begin if j\u003c\u003ea[1] then f[i+1,j+1,k,l,o,p]:=f[i+1,j+1,k,l,o,p]+f[i,j,k,l,o,p]; if (k\u003c\u003ea[2])and(k\u003cj) then f[i+1,j,k+1,l,o,p]:=f[i+1,j,k+1,l,o,p]+f[i,j,k,l,o,p]; if (l\u003c\u003ea[3])and(l\u003ck) then f[i+1,j,k,l+1,o,p]:=f[i+1,j,k,l+1,o,p]+f[i,j,k,l,o,p]; if (o\u003c\u003ea[4])and(o\u003cl) then f[i+1,j,k,l,o+1,p]:=f[i+1,j,k,l,o+1,p]+f[i,j,k,l,o,p]; if (p\u003c\u003ea[5])and(p\u003co) then f[i+1,j,k,l,o,p+1]:=f[i+1,j,k,l,o,p+1]+f[i,j,k,l,o,p]; end; writeln(f[m,a[1],a[2],a[3],a[4],a[5]]); until false; end. ","description":"","tags":["ACM题解"],"title":"POJ 2279. Mr. Young’s Picture Permutations (线性DP)","uri":"/posts/poj_2279._mr._youngs_picture_permutations_%E7%BA%BF%E6%80%A7dp/"},{"categories":["Programming Contest","ACM"],"content":"题面 Description 小象同学在初等教育时期遇到了一个复杂的数学题，题目是这样的：给定自然数 $n$，确定关于$x,y,z$ 的不定方程\n$\\sqrt{x-\\sqrt{n}} + \\sqrt{y} - \\sqrt{z}=0$ 的解。\n当时的小象同学并不会做这道题。多年后，经过高等教育的洗礼，小象同学发现这道题其实很简单。小象同学认为你一定也会做这道题，所以把这道题留给了你。为了便于输出，你不需要输出每一组解 $(x,y,z)$，你只需要给出解的数量和所有解的 $xyz$之和对$(10^{9}+7)$ 取模的值即可。注意，解的数量不对$10^{9}+7$ 取模。\nInput 输入包含多组测试数据。输入的第一行包含一个正整数 $T;(1 \\leq T \\leq 10^{4})$ ，表示测试数据的组数。接下来依次描述每组测试数据，对于每组测试数据：\n仅一行，包含一个非负整数 $n;(0\\leq n \\leq 2 \\times 10^{9})$ ，含义如题面所示。\nOutput 对于每组数据，输出一行。若方程有无穷多组自然数解，则在这一行输出 $\\text{‘‘infty’’}$（不含引号），否则在这一行输出两个整数，其中第一个整数表示方程的解数，第二个整数 表示所有解的 $xyz$之和对$(10^{9}+7)$ 取模的值，这两个整数之间用恰好一个空格隔开，行末不要有多余的空格。\nSample Input 3 6 12 24 Sample Output 0 0 1 12 2 72 Hint 当 $n=12$时，方程唯一的解为$x=4,y=1,z=3$ 。\n当 $n=24$时，方程的两组解为 $x=5,y=2,z=3$ 和$x=7,y=1,z=6$ 。\n题解 首先注意到显然当且仅当 $n=0$或 $n$为完全平方数时，给定方程有无穷多组解，通解为$(\\sqrt{n},c,c)$ ，其中$c$ 是任意自然数。\n现在，考察何时方程有有限多组解。将所给方程做如下变换 $$ \\sqrt{x-\\sqrt{n}}=\\sqrt{z}-\\sqrt{y} $$ 两边平方得 $$ x-\\sqrt{n}=y+z-2\\sqrt{yz} $$ 移项得 $$ x-(y+z)=\\sqrt{n}-2\\sqrt{yz} $$ 此时，考虑两种情况：\n方程左右两边均为 $0$ 此时，显然有 $$ \\left { \\begin{matrix} x=y+z \\ n = 4yz \\end{matrix} \\right. $$\n方程左右两边均不为 $0$ 因为 $x,y,z\\in \\mathbb{N} $，故 $x-(y+z) \\in \\mathbb{Z}$，故应当也有 $\\sqrt{n}-2\\sqrt{yz} \\in \\mathbb{Z}$。若 $n \\neq 4yz$，则当且仅当 $n$与 $yz$均为 $0$或完全平方数（但不同时为$0$）时，满足该条件；这是不可能的。因为，若$n$或$yz$ 为$0$ 时，必有$n=yz=0$；若$n$ 或$yz$ 均不为$0$ ，则$n$ 必须为完全平方数，此时方程有无穷多组解。\n综上，当且仅当 $\\left { \\begin{matrix} x=y+z \\ n=4yz \\end{matrix} \\right.$ 成立时，方程有有限多组解。\n此时注意到当且仅当 $n$是 $4$的倍数时，方程有解；又注意到 $n \\leq 2 \\times 10^{9}$，因此遍历$[1, \\sqrt{n}]$ 寻找$n$ 的因子即可。时间复杂度$O(\\sqrt{n})$ 。\n注意此题long long会超时\n代码 #include \u003cbits/stdc++.h\u003e using namespace std; const int MODULO = 1e9 + 7; int main() { ios::sync_with_stdio(false); cin.tie(0); int t = 0; cin \u003e\u003e t; while (t--) { int n = 0; cin \u003e\u003e n; if (n == 0 || (int)sqrt((double)n) * (int)sqrt((double)n) == n) { cout \u003c\u003c \"infty\" \u003c\u003c endl; continue; } if (n % 4) { cout \u003c\u003c 0 \u003c\u003c \" \" \u003c\u003c 0 \u003c\u003c endl; continue; } n /= 4; int m = (int)sqrt((double)n + 0.5); int ans = 0, num = 0; for (int i = 1; i \u003c= m; i++) { if (n % i) continue; num++; int z = n / i; int x = ((long long)i + z) % MODULO; ans = ((long long)ans + (long long)x * n % MODULO) % MODULO; } cout \u003c\u003c num \u003c\u003c \" \" \u003c\u003c ans \u003c\u003c endl; } return 0; } ","description":"","tags":["ACM题解"],"title":"A. 解方程 (暴力) [Comet OJ Contest #0]","uri":"/posts/comet_oj_contest_0_a_%E8%A7%A3%E6%96%B9%E7%A8%8B/"},{"categories":["Programming Contest","ACM","HDU"],"content":"题面 Description Function $F_{x,y}$ satisfies: $$ F_{1, 1} = F_{1, 2} = 1 \\ F_{1, i} = F_{1, i - 1} + 2 * F_{1, i - 2} ; (i \\geq 3) \\ F_{i, j} = \\sum_{k = j}^{j + N - 1}F_{i - 1, k} ; (i \\geq 2, j \\geq 1) $$ For given integers $N$and $M$,calculate $F_{m, 1}$ modulo$10^{9} + 7$.\nInput There is one integer T in the first line.\nThe next T lines,each line includes two integers N and M .\n1\u003c=T\u003c=10000,1\u003c=N,M\u003c2^63.\nOutput For each given N and M,print the answer in a single line.\nSample Input 2 2 2 3 3 Sample Output 2 33 题解 记 $F_{1, i}$为$a_{i}$ ，则 $$ a_{i} = a_{i - 1} + 2a_{i - 2} ; (i \\geq 3) $$ 设 $p \\neq 0, q \\in \\mathbb{R}$ 使得 $$ a_{i} + ka_{i - 1} = p(a_{i - 1} + ka_{i - 2}) $$ 两式对照并解得 $\\left { \\begin{matrix} p = -1 \\ k = -2 \\end{matrix} \\right.$或$\\left { \\begin{matrix} p = 2 \\ k = 1 \\end{matrix} \\right.$ .\n$\\left { \\begin{matrix} p = -1 \\ k = -2 \\end{matrix} \\right.$ 成立 此时记 $b_{i - 1} = a_{i} - 2a_{i - 1}$ ，易得 $$ b_{i} = (-1)^{i} $$ 故 $a_{i} - 2a_{i - 1} = (-1)^{i - 1}$ . 此时有 $$ \\frac{a_{i}}{(-1)^{i}}+2\\frac{a_{i - 1}}{(-1)^{i - 1}} = -1 $$ 记 $c_{i} = \\dfrac{a_{i}}{(-1) ^ {i}}$ ，易得 $$ c_{i} = \\frac{1}{3}(-2)^{i} - \\frac{1}{3} $$ 故 $$ a_{i} = （-1)^{i}c_{i} = \\frac{2^{i}}{3} + \\frac{(-1)^{i - 1}}{3} $$\n$\\left { \\begin{matrix} p = 2 \\ k = 1 \\end{matrix} \\right.$ 成立 易知此时亦有 $a_{i} = \\dfrac{2^{i}}{3} + \\dfrac{(-1)^{i - 1}}{3}$ 成立。\n综上，此时有 $$ F_{1, i} = \\frac{1}{3} \\cdot (-1)^{i - 1} + \\frac{1}{3} \\cdot 2^{i} \\tag{1} $$ 此时考虑 $$ F_{2, i} = \\sum_{k=i}^{i+N-1}F_{1,k}=\\sum_{k=1}^{i+N-1}F_{1,k}-\\sum_{k=1}^{i-1}F_{1,k} \\tag{2} $$ 又，此时有 $$ \\sum_{i=1}^{n}F_{1,i} = \\frac{1}{3}\\sum_{i=1}^{n}(-1)^{i-1}+\\frac{1}{3}\\sum_{i=1}^{n}2^{i} \\ =\\frac{1}{6}\\cdot(1+(-1)^{n+1})+\\frac{2}{3}\\cdot(2^{n}-1) $$ 代入 $(2)$ 式可得 $$ F_{2, i} = \\frac{1}{3}\\cdot\\frac{(-1)^{i+N}-(-1)^{i}}{2}+\\frac{1}{3}\\cdot(2^{N}-1)\\cdot2^{i} \\tag{3} $$ 类似地，易得 $$ F_{3,i}=\\frac{1}{3}\\cdot\\frac{(-1)^{i+N}-(-1)^{i}}{2}+\\frac{1}{3}\\cdot(2^{N}-1)^{2}\\cdot2^{i} \\tag{4} $$ 此时，由归纳法易证 $$ F_{m,i}=\\frac{1}{3}\\cdot\\frac{(-1)^{i+N}-(-1)^{i}}{2}+\\frac{1}{3}\\cdot(2^{N}-1)^{m-1}\\cdot2^{i} \\tag{5} $$ 因此 $$ F_{m,1}=\\frac{1}{3}[(m;\\mathbf{mod};2)+2\\cdot(2^{N}-1)^{m-1}] \\tag{6} $$ 用快速幂计算即可。\n代码 此题 $N$和 $M$ 都是$2^{63}$ 范围，因此要用 unsigned long long\n模 $k$ 乘法千万不能忘了逆元。。。这次居然很脑抽地居然把逆元忘了导致赛中自闭orz = =\n#include \u003cbits/stdc++.h\u003e using namespace std; typedef unsigned long long ull; const ull MODULO = 1e9 + 7; ull power(ull a, ull b, ull p); int main() { ios::sync_with_stdio(false); cin.tie(0); // freopen(\"test.in\", \"r\", stdin); // freopen(\"test.out\", \"w\", stdout); int t = 0; cin \u003e\u003e t; while (t--) { ull n = 0, m = 0; cin \u003e\u003e n \u003e\u003e m; if (m == 1) { cout \u003c\u003c 1 \u003c\u003c endl; continue; } ull x1 = n \u0026 1; ull x2 = (2 * power(power(2, n, MODULO) - 1, m - 1, MODULO)) % MODULO; ull ans = (x1 + x2) * 333333336 % MODULO; cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ull power(ull a, ull b, ull p) { ull ans = 1 % p; for (; b; b \u003e\u003e= 1) { if (b \u0026 1) ans = (ull)ans * a % p; a = (ull)a * a % p; } return ans; } ","description":"","tags":["ACM题解"],"title":"HDU 6050. Funny Function (快速幂，逆元)","uri":"/posts/hdu_6050._funny_function_%E5%BF%AB%E9%80%9F%E5%B9%82%E9%80%86%E5%85%83/"},{"categories":["Programming Contest","Codeforces"],"content":"题面 Description You are given two arrays $a$and $b$, each contains$n$ integers.\nYou want to create a new array $c$as follows: choose some real (i.e. not necessarily integer) number $d$, and then for every $i \\in [1, n]$ let$c_i := d \\cdot a_i + b_i$.\nYour goal is to maximize the number of zeroes in array $c$. What is the largest possible answer, if you choose $d$ optimally?\nInput The first line contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the number of elements in both arrays.\nThe second line contains $n$integers $a_1$, $a_2$, …,$a_n$ ($-10^9 \\le a_i \\le 10^9$).\nThe third line contains $n$integers $b_1$, $b_2$, …,$b_n$ ($-10^9 \\le b_i \\le 10^9$).\nOutput Print one integer — the maximum number of zeroes in array $c$, if you choose $d$ optimally.\nExamples Input 5 1 2 3 4 5 2 4 7 11 3 Output 2 Input 3 13 37 39 1 2 3 Output 2 Input 4 0 0 0 0 1 2 3 4 Output 0 Input 3 1 2 -1 -6 -12 6 Output 3 Note In the first example, we may choose $d = -2$.\nIn the second example, we may choose $d = -\\dfrac{1}{13}$.\nIn the third example, we cannot obtain any zero in array $c$, no matter which $d$ we choose.\nIn the fourth example, we may choose $d = 6$.\n题目大意 给出两个长度为 $n$$(1 \\leq n \\leq 2 \\cdot 10^{5})$的数组 $a$和$b$ ，求实数$d$ 使得对所有$i \\in [1, n]$ 计算下式 $$ c[i] = d \\cdot a[i] + b[i] $$ 数组 $c$中$0$ 的数目尽可能多。\n题解 分析 令 $d \\cdot a[i] + b[i] = 0$，则有 $d = -\\dfrac{b[i]}{a[i]}$。但 $d$会爆 double 精度，此时用 pair 维护 \u003c-b[i] / gcd, a[i] / gcd\u003e 即可。但此时要注意处理 b[i] 与 a[i] 的正负号关系（e.g. $\\dfrac{1}{1} = \\dfrac{-1}{-1}$ ，但在直接按此存储则会导致被认作为不同的值）。也可用 long double 维护$d$ 。之后用 map 统计出现次数最多的 d 即可。\n注意特判 $a[i] = 0$的情况。此时有 $c[i] = b[i]$，若 $b[i] = 0$ ，则$c[i]$ 必为$0$。\n代码 pair 维护 #include \u003cbits/stdc++.h\u003e using namespace std; #define ABS(x) ((x) \u003e 0 ? (x) : -(x)) const int MAXN = 2e5 + 10; int a[MAXN], b[MAXN]; int main() { ios::sync_with_stdio(false); cin.tie(0); int n = 0; while (cin \u003e\u003e n) { for (int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i++) cin \u003e\u003e b[i]; int ans = 0, cnt0 = 0; map\u003cpair\u003cint, int\u003e, int\u003e m; for (int i = 1; i \u003c= n; i++) { if (a[i] == 0) { if (b[i] == 0) cnt0++; } else { pair\u003cint, int\u003e p = make_pair(-b[i], a[i]); if (p.first \u003c 0 || (p.first == 0 \u0026\u0026 p.second \u003c 0)) { p.first *= -1; p.second *= -1; } int d = __gcd(ABS(p.first), ABS(p.second)); p.first /= d; p.second /= d; if (m.find(p) == m.end()) m.insert(make_pair(p, 1)); else m[p]++; ans = max(ans, m[p]); } } cout \u003c\u003c ans + cnt0 \u003c\u003c endl; } return 0; } long double维护 #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef unsigned long long ull; typedef long double ld; const int MAXN = 2e5 + 10; int a[MAXN], b[MAXN]; int main() { ios::sync_with_stdio(false); cin.tie(0); int n = 0; while (cin \u003e\u003e n) { for (int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; for (int i = 1; i \u003c= n; i++) cin \u003e\u003e b[i]; map\u003cld, int\u003e m; int ans = 0, cnt0 = 0; for (int i = 1; i \u003c= n; i++) { if (a[i] == 0) { if (b[i] == 0) cnt0++; } else { ld d = -(ld)b[i] / a[i]; if (m.find(d) == m.end()) m.insert(make_pair(d, 1)); else m[d]++; ans = max(ans, m[d]); } } cout \u003c\u003c ans + cnt0 \u003c\u003c endl; } return 0; } ","description":"","tags":["ACM题解"],"title":"Codeforces 1133D. Zero Quantity Maximization (map, 精度)","uri":"/posts/codeforces_1133d._zero_quantity_maximization_map_%E7%B2%BE%E5%BA%A6/"},{"categories":["Programming Contest","Codeforces"],"content":"题面 Description When preparing a tournament, Codeforces coordinators try treir best to make the first problem as easy as possible. This time the coordinator had chosen some problem and asked $n$ people about their opinions. Each person answered whether this problem is easy or hard.\nIf at least one of these $n$ people has answered that the problem is hard, the coordinator decides to change the problem. For the given responses, check if the problem is easy enough.\nInput The first line contains a single integer $n$ ($1 \\le n \\le 100$) — the number of people who were asked to give their opinions.\nThe second line contains $n$integers, each integer is either $0$or $1$. If $i$-th integer is $0$, then $i$-th person thinks that the problem is easy; if it is$1$, then$i$-th person thinks that the problem is hard.\nOutput Print one word: “EASY” if the problem is easy according to all responses, or “HARD” if there is at least one person who thinks the problem is hard.\nYou may print every letter in any register: “EASY”, “easy”, “EaSY” and “eAsY” all will be processed correctly.\nSample Input 1 3 0 0 1 Sample Output 1 HARD Sample Input 2 1 0 Sample Output 2 EASY 题解 题目大意 给你一个大小为n的数组，元素只有0和1，如果数组中存在元素为1，则输出HARD，否则输出EASY，并且每个字母大小写随便\n分析 直接根据题意模拟，真·签到题\n代码 #include \u003cbits/stdc++.h\u003e using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int n = 0; while(cin \u003e\u003e n) { bool isone = false; for(int i = 1; i \u003c= n; i++) { int a = 0; cin \u003e\u003e a; if(a == 1) { isone = true; } } if(isone) cout \u003c\u003c \"HARD\" \u003c\u003c endl; else cout \u003c\u003c \"EASY\" \u003c\u003c endl; } return 0; } ","description":"","tags":["ACM题解"],"title":"Codeforces 1030A. In Search of an Easy Problem(Codebait) [Codeforces Round","uri":"/posts/codeforces_1030a._in_search_of_an_easy_problemcodebait_codeforces_round_#512_div._2/"},{"categories":["Programming Contest","Codeforces","Div. 2"],"content":"My Status A B C D E F G O O O O Ø Ø Ø Level 全场几乎都是签到，然而我还是很菜\nSolution A. In Search of an Easy Problem solution\nB. Vasya and Cornfield solution\nC. Vasya and Golden Ticket solution\nD. Vasya and Triangle solution\nE. Vasya and Good Sequences unsolved\nF. Putting Boxes Together unsolved\nG. Linear Congruential Generator unsolved\n","description":"","tags":["ACM报告"],"title":"Codeforces Round #512 (Div. 2) [Personal Summary]","uri":"/posts/codeforces-512-div2/"},{"categories":["Programming Contest","ACM"],"content":"题面 Description Jessie has a magic mirror.\nEvery morning she will ask the mirror: ‘Mirror mirror tell me, who is the most beautiful girl in the world?’ If the mirror says her name, she will praise the mirror: ‘Good guy!’, but if the mirror says the name of another person, she will assail the mirror: ‘Dare you say that again?’\nToday Jessie asks the mirror the same question above, and you are given a series of mirror’s answers. For each answer, please output Jessie’s response. You can assume that the uppercase or lowercase letters appearing anywhere in the name will have no influence on the answer. For example, ‘Jessie’ and ‘jessie’ represent the same person.\nInput The first line contains an integer $T(1 \\le T \\le 100)$, which is the number of test cases.\nEach test case contains one line with a single-word name, which contains only English letters. The length of each name is no more than $15$.\nOutput For each test case, output one line containing the answer.\nSample Input 2 Jessie Justin Sample Output Good guy! Dare you say that again? 题解 题目大意 给出 $T$个长度小于$15$ 的字符串，判断其是否与字符串Jessie相等（忽略大小写）。\n分析 完全的新生级签到题，读入字符串后将每个字符都转为小写，之后判断是否与jessie相等即可。\n代码 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003ccctype\u003e using namespace std; const int MAXN = 20; char name[MAXN]; int main() { int t = 0; scanf(\"%d\", \u0026t); while(t--) { scanf(\"%s\", name); int len = (int)strlen(name); for(int i = 0; i \u003c len; i++) name[i] = tolower(name[i]); if(!strcmp(name, \"jessie\")) printf(\"Good guy!\\n\"); else printf(\"Dare you say that again?\\n\"); } return 0; } ","description":"","tags":["ACM题解"],"title":"A. Magic Mirror(新手题，字符串处理) [2018 ACM-ICPC Jiaozuo Online Contest]","uri":"/posts/a._magic_mirror%E6%96%B0%E6%89%8B%E9%A2%98%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86_2018_acm-icpc_jiaozuo_online_contest/"},{"categories":["Programming Contest","ACM"],"content":"My Status A B C D E F G H I J K O Ø Ø Ø Ø Ø Ø Ø O Ø Ø Level 签到题： A, I 简单题：\n中等题：\n难题：\nSolution A. Magic Mirror solution: http://www.bofc.tech/index.php/archives/141/\nB. Mathematical Curse unsolved\nC. Password unsolved\nD. Sequence unsolved\nE. Jiu Yuan Wants to Eat unsolved\nF. Modular Production Line unsolved\nG. Give Candies unsolved\nH. String and Times unsolved\nI. Save the Room solution:\nJ. Participate in E-sports unsolved\nK. Transport Ship unsolved\nL. Poor God Water unsolved\n","description":"","tags":["ACM报告"],"title":"2018 ACM-ICPC Jiaozuo Online Contest [Personal Summary]","uri":"/posts/2018_acm_jiaozuo_online_contest/"},{"categories":["Programming Contest","ACM"],"content":"题面 Description Ryuji is not a good student, and he doesn’t want to study. But there are n books he should learn, each book has its knowledge $a[i]$.\nUnfortunately, the longer he learns, the fewer he gets.\nThat means, if he reads books from ll to rr, he will get $a[l] \\times L + a[l+1] \\times (L-1) + \\cdots + a[r-1] \\times 2 + a[r]$($L$is the length of [ $ l, r$ ] that equals to$r - l + 1$).\nNow Ryuji has $q$ questions, you should answer him:\nIf the question type is $1$, you should answer how much knowledge he will get after he reads books [ $l, r$ ].\nIf the question type is $2$, Ryuji will change the $i$th book’s knowledge to a new value.\nInput First line contains two integers $n$and$q$ ($n, q \\le 100000$).\nThe next line contains n integers represent $a[i]$ $(a[i]≤1e9)$ .\nThen in next $q$line each line contains three integers $a, b, c$, if $a = 1$, it means question type is $1$, and $b, c$represents [ $l , r$]. if $a = 2$, it means question type is$2$ , and$b, c$ means Ryuji changes the$b$th book’s knowledge to$c$ .\nOutput For each question, output one line with one integer represent the answer.\nSample Output 5 3 1 2 3 4 5 1 1 3 2 5 0 1 4 5 Sample Output 10 8 分析 注意到题中公式可进行如下变形：\n$a[l] \\times L + a[l+1] \\times (L-1) + \\cdots + a[r-1] \\times 2 + a[r]$\n= $\\sum\\limits_{k=l}^{r}(r-l+1-(k-l)) \\cdot a[k]$ = $\\sum\\limits_{k=l}^{r}(r-k+1) \\cdot a[k]$ = $(r+1)\\sum\\limits_{k=l}^{r}a[k]-\\sum\\limits_{k=l}^{r}k \\cdot a[k]$ 又，题中所给两种操作分别为区间查询，单点修改；因此用树状数组直接维护 $a[k]$和$k \\cdot a[k]$ 的值即可。\n代码 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; typedef long long ll; #define LOWBIT(x) ((x) \u0026 -(x)) const int MAXN = 1e5 + 10; ll a[MAXN]; ll c[MAXN], mc[MAXN]; ll ask(ll* ar, int x) { ll ans = 0; for( ; x; x -= LOWBIT(x)) ans += ar[x]; return ans; } void add(ll* ar, int x, ll y, int n) { for( ; x \u003c= n; x += LOWBIT(x)) ar[x] += y; } int main() { ios::sync_with_stdio(false); cin.tie(0); int n = 0, q = 0; while(cin \u003e\u003e n \u003e\u003e q) { for(int i = 1; i \u003c= n; i++) cin \u003e\u003e a[i]; for(int i = 1; i \u003c= n; i++) add(c, i, a[i], n); for(int i = 1; i \u003c= n; i++) add(mc, i, a[i] * (ll)i, n); for(int i = 1; i \u003c= q; i++) { int p = 0, l = 0, r = 0; cin \u003e\u003e p \u003e\u003e l \u003e\u003e r; if(p == 1) { cout \u003c\u003c (ll)(r + 1) * (ask(c, r) - ask(c, l - 1)) - (ask(mc, r) - ask(mc, l - 1)) \u003c\u003c endl; } else if(p == 2) { ll l_c = ask(c, l) - ask(c, l - 1); ll l_mc = ask(mc, l) - ask(mc, l - 1); add(c, l, (ll)r - l_c, n); add(mc, l, (ll)r * (ll)l - l_mc, n); } } } return 0; } ","description":"","tags":null,"title":"H. Ryuji doesn’t want to study (树状数组) [2018 ACM-ICPC Xuzhou Online Contest]","uri":"/posts/h._ryuji_doesnt_want_to_study_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84_2018_acm-icpc_xuzhou_online_contest/"},{"categories":["Programming Contest","ACM"],"content":"My Status A B C D E F G H I J K Ø Ø Ø Ø Ø Ø Ø O Ø Ø Ø Level 签到题： H 简单题：\n中等题：\n难题：\nSolution A. Hard to prepare unsolved\nB. BE, GE or NE unsolved\nC. Cacti Lottery unsolved\nD. Easy Math unsolved\nE. End Fantasy VIX unsolved\nF. Features Track unsolved\nG. Trace unsolved\nH. Ryuji doesn’t want to study solution: http://www.bofc.tech/index.php/archives/137/\nI. Characters with Hash unsolved\nJ. Maze Designer unsolved\nK. Morgana Net unsolved\n","description":"","tags":null,"title":"2018 ACM-ICPC Xuzhou Online Contest [Personal Summary]","uri":"/posts/2018_acm_xuzhou_online_contest/"},{"categories":["Programming Contest","ACM"],"content":"My Status A B C D E F G H I J K Ø Ø Ø Ø Ø Ø Ø Ø Ø Ø Ø Level 签到题：\n简单题：\n中等题：\n难题：\nSolution A. Gudako and Ritsuka unsolved\nB. Call of Accepted unsolved\nC. Convex Hull unsolved\nD. Made In Heaven unsolved\nE. The cake is a lie unsolved\nF. Fantastic Graph unsolved\nG. Spare Tire unsolved\nH. Hamming Weight unsolved\nI. Lattice’s basics in digital electronics unsolved\nJ. Ka Chang unsolved\nK. Supreme Number unsolved\n","description":"","tags":null,"title":"2018 ACM-ICPC Shenyang Online Contest [Personal Summary]","uri":"/posts/2018_acm_shenyang_online_contest/"},{"categories":["Programming Contest","ACM"],"content":"My Status A B C D E F G H I J K Ø Ø Ø Ø Ø O Ø Ø Ø Ø Ø Level 签到题：A\n简单题：F\n中等题：\n难题：\nSolution A. Easy $h$-index unsolved\nB. Higher $h$-index unsolved\nC. Just $h$-index unsolved\nD. Circular Coloring unsolved\nE. From Tree to Graph unsolved\nF. Sorting Solution: http://www.bofc.tech/index.php/archives/124/\nG. String Transformation unsolved\nH. Infinity unsolved\nI. Longest Increasing Subsequence unsolved\nJ. Vertex Cover unsolved\nK. 2018 unsolved\n","description":"","tags":["ACM报告"],"title":"2017 CCPC China-Hunan Invitional [Personal Summary]","uri":"/posts/2017_ccpc_hunan_invitional/"},{"categories":["Programming Contest","ACM"],"content":"Description Bobo has $n$tuples$(a_1, b_1, c_1), (a_2, b_2, c_2), \\dots, (a_n, b_n, c_n)$ . He would like to find the lexicographically smallest permutation $p_1, p_2, \\dots, p_n$of$1, 2, \\dots, n$ such that for$i \\in {2, 3, \\dots, n}$ it holds that $$ \\frac{a_{p_{i - 1}} + b_{p_{i - 1}}}{a_{p_{i - 1}} + b_{p_{i - 1}} + c_{p_{i - 1}}} \\leq \\frac{a_{p_i} + b_{p_i}}{a_{p_i} + b_{p_i} + c_{p_i}} $$\nInput The input consists of several test cases and is terminated by end-of-file.\nThe first line of each test case contains an integer $n$.\nThe $i$-th of the following $n$lines contains $3$integers $a_i$,$b_i$ and$c_i$.\nOutput For each test case, print $n$integers$p_1, p_2, \\dots, p_n$ seperated by spaces. DO NOT print trailing spaces.\nConstraint $1 \\leq n \\leq 10^3$ $1 \\leq a_i, b_i, c_i \\leq 2 \\times 10^9$ The sum of $n$does not exceed$10^4$. Sample Input 2 1 1 1 1 1 2 2 1 1 2 1 1 1 3 1 3 1 2 2 1 3 1 1 Sample Output 2 1 1 2 1 2 3 题解 题目大意 给你 $n$个三元组，要求给出这 $n$个三元组的一个排列，使得对$i \\in \\left { 2, 3, \\cdots, n \\right }$ 都满足题给关系。\n分析 题给关系中的不等式只涉及 $p_{i - 1}$和$p_{i}$ 两个元素，实际上相当于对三元组重载了小于号。因此，本题实际上是对读入的三元组序列进行排序。因此，我们用一个Node结构体存储三元组的三个变元和读入时在原序列中的位置即可。\nstruct Node { long long a, b, c; int id; } 同时，在比较三元组关系时，因为本题数据卡精度较严，因此不能用double，而应交叉相乘再比较，同时在这过程中约去一些相同的项（避免爆long long）。 $$ (a_{p_{i-1}}+b_{p_{i-1}})(a_{p_{i}}+b_{p_{i}}+c_{p_{i}}) \\leq (a_{p_{i}} + b_{p_{i}})(a_{p_{i-1}}+b_{p_{i-1}}+c_{p_{i-1}})) $$\n$$ (a_{p_{i-1}} + b_{p_{i-1}})c_{p_{i}} \\leq (a_{p_{i}} + b_{p_{i}})c_{p_{i-1}} $$\n代码 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int MAXN = 1010; typedef long long ll; struct Node { ll a, b, c; int id; bool operator \u003c (const Node\u0026 x) const { ll q1 = c * (x.a + x.b); ll q2 = x.c * (a + b); if(q2 == q1) return id \u003c x.id; else return q2 \u003c q1; } } t[MAXN]; int main() { ios::sync_with_stdio(false); cin.tie(0); int n = 0; while(cin \u003e\u003e n) { for(int i = 1; i \u003c= n; i++) { cin \u003e\u003e t[i].a \u003e\u003e t[i].b \u003e\u003e t[i].c; t[i].id = i; } sort(t + 1, t + n + 1); for(int i = 1; i \u003c= n; i++) if(i != n) cout \u003c\u003c t[i].id \u003c\u003c \" \"; else cout \u003c\u003c t[i].id \u003c\u003c endl; } return 0; } ","description":"","tags":["ACM题解"],"title":"F. Sorting (排序，浮点数精度) [2017 CCPC China-Hunan Invitional]","uri":"/posts/f._sorting_%E6%8E%92%E5%BA%8F%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6_2017_ccpc_china-hunan_invitional/"},{"categories":["Programming Contest","ACM","POJ"],"content":"题面 Description A histogram is a polygon composed of a sequence of rectangles aligned at a common base line. The rectangles have equal widths but may have different heights. For example, the figure on the left shows the histogram that consists of rectangles with the heights 2, 1, 4, 5, 1, 3, 3, measured in units where 1 is the width of the rectangles:\nUsually, histograms are used to represent discrete distributions, e.g., the frequencies of characters in texts. Note that the order of the rectangles, i.e., their heights, is important. Calculate the area of the largest rectangle in a histogram that is aligned at the common base line, too. The figure on the right shows the largest aligned rectangle for the depicted histogram.\nInput The input contains several test cases. Each test case describes a histogram and starts with an integer n, denoting the number of rectangles it is composed of. You may assume that 1\u003c=n\u003c=100000. Then follow n integers h1,…,hn, where 0\u003c=hi\u003c=1000000000. These numbers denote the heights of the rectangles of the histogram in left-to-right order. The width of each rectangle is 1. A zero follows the input for the last test case.\nOutput For each test case output on a single line the area of the largest rectangle in the specified histogram. Remember that this rectangle must be aligned at the common base line.\nSample Input 7 2 1 4 5 1 3 3 4 1000 1000 1000 1000 0 Sample Output 8 4000 Hint Huge input, scanf is recommended.\n分析 题目大意：在一水平线上方有若干个矩形，求包含于这些矩形的并集内部的最大矩形的面积，矩形个数 $\\leq 10^{5}$ 。\n我们现在面临两个问题：\n应从哪个位置开始选取所需的矩形并集？ 当确定了开始位置时，应向左/右哪个方向延伸，延伸多少？ 作为对问题的简化，我们先考虑如下情况：如果矩形高度从左到右单调递增，答案将是多少？\n很显然，答案将是以下四种情形之一：\n那么，此时如果新增加一个矩形，它的高度比其之前的三个矩形都要低；此时，如果我们想要利用这个矩形以及之前的矩形一同选取一个并集，这个并集的高度一定不会高于新矩形的高度：也就是说，下图中打叉的部分已经对于后续计算没有用处了。那么，我们就可以将新选取的并集独立出来，代替之前用到的所有矩形，放入我们已有的矩形序列之内：此时，矩形序列又重新具有了高度单调性。\n因此，我们可以采用单调栈维护矩阵序列：我们存储序列中每一个矩形的高度和宽度，之后扫描所有矩形；每当读入一个新矩形时进行如下操作：\n如果当前矩形的高度大于等于栈顶矩形，则直接将当前矩形压入栈顶，宽度为1。 如果当前矩形的高度小于栈顶矩形，则持续将栈顶矩形出栈，直至当前矩形高度大于等于栈顶矩形为止。同时，在这一过程中，累积记录所有出栈矩形的宽度；当出栈完毕后，再将以累积值为宽度、当前矩形高度为高的新矩形压入栈顶。 在扫描结束后，为了防止栈中仍有矩形未被弹出，我们可以增加一个高度为0的矩形 h[n + 1] ，以此简化计算。\n注意：此题最终答案会爆int。\n代码 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; typedef long long ll; const int MAXN = 1e5 + 10; int h[MAXN]; int s[MAXN], w[MAXN], top; void push(int hei, int wid); void pop(int* hei, int* wid); bool isEmpty(); int main() { ios::sync_with_stdio(false); cin.tie(0); int n = 0; while(cin \u003e\u003e n \u0026\u0026 n) { for(int i = 1; i \u003c= n; i++) cin \u003e\u003e h[i]; h[n + 1] = 0; top = 0; memset(s, 0, sizeof(s)); memset(w, 0, sizeof(w)); ll ans = 0; for(int i = 1; i \u003c= n + 1; i++) { if(h[i] \u003e= s[top]) s[++top] = h[i], w[top] = 1; else { int outWidth = 0; while(h[i] \u003c s[top]) { outWidth += w[top]; ans = max(ans, (long long)s[top--] * outWidth); } s[++top] = h[i], w[top] = outWidth + 1; } } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } inline void push(int hei, int wid) { s[++top] = hei; w[top] = wid; } inline void pop(int* hei, int* wid) { *hei = s[top]; *wid = w[top--]; } inline bool isEmpty() { if(top == 0) return true; else return false; } ","description":"","tags":["ACM题解"],"title":"POJ.2559 Largest Rectangle in a Histogram (单调栈)","uri":"/posts/poj.2559_largest_rectangle_in_a_histogram_%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["Programming Contest","ACM"],"content":"Description Alice, a student of grade $6$, is thinking about an Olympian Math problem, but she feels so despair that she cries. And her classmate, Bob, has no idea about the problem. Thus he wants you to help him. The problem is:\nWe denote $k!$:\n$k! = 1 \\times 2 \\times \\cdots \\times (k - 1) \\times k$\nWe denote $S$:\n$S = 1 \\times 1! + 2 \\times 2! + \\cdots +$ $(n - 1) \\times (n-1)!$\nThen $S$module$n$ is ____________\nYou are given an integer $n$.\nYou have to calculate $S$modulo$n$.\nInput The first line contains an integer $T(T \\le 1000)$, denoting the number of test cases.\nFor each test case, there is a line which has an integer $n$.\nIt is guaranteed that $2 \\le n\\le 10^{18}$.\nOutput For each test case, print an integer $S$modulo$n$.\nHint The first test is: $S = 1\\times 1!= 1$, and $1$modulo $2$ is$1$.\nThe second test is: $S = 1\\times 1!+2 \\times 2!= 5$, and $5$modulo$3$ is$2$.\nSample Input 2 2 3 Sample Output 1 2 题解 首先，显然有 $S = \\sum\\limits_{k=1}^{n-1}k \\cdot k! = \\sum\\limits_{k=1}^{n-1}((k+1)!-k!)=n!-1$.\n故 $S ; \\mathrm{mod} ; n$\n$= (n! - 1) ; \\mathrm{mod} ; n$\n$ = (n! + n - 1) ; \\mathrm{mod} ; n$\n$ = n! ; \\mathrm{mod} ; n + (n - 1) ; \\mathrm{mod} ; n$\n$ = n - 1$.\n代码 #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(0); int t = 0; cin \u003e\u003e t; while(t--) { ll n = 0; cin \u003e\u003e n; cout \u003c\u003c n - 1 \u003c\u003c endl; } return 0; } ","description":"","tags":["ACM题解","数论"],"title":"A. An Olympian Math Problem (数论) [2018 ACM-ICPC Nanjing Online Contest]","uri":"/posts/a._an_olympian_math_problem_%E6%95%B0%E8%AE%BA2018_acm-icpc_nanjing_online_contest/"},{"categories":["Programming Contest","ACM"],"content":"比赛训练个人记录 2017 CCPC China-Hunan Invitional 2018 ACM-ICPC Shenyang Online Contest 2018 ACM-ICPC Xuzhou Online Contest 2018 ACM-ICPC Jiaozuo Online Contest Codeforces Round #512 (Div. 2)\n每日训练记录 2018.9.3\n做/补题列表：\nA. An Olympian Math Problem (数论) 2018 ACM-ICPC Nanjing Online Contest\n学习内容：\n2018.9.4\n做/补题列表：\nPOJ.2559 Largest Rectangle in a Histogram (单调栈)\n学习内容：\n","description":"","tags":["ACM报告"],"title":"2018年9月ACM训练记录","uri":"/posts/2018%E5%B9%B49%E6%9C%88acm%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/"},{"categories":["Algorithm","Graph","Basic Concepts"],"content":"设有向图 $G=(V,E)$, 令 $n=|V|$, $m=|E|$，$(x,y)$表示一条从 $x$ 到$y$ 的有向边，并记该条边的边权为$w(x,y)$。\n存储 $G$时，我们一般使用两种存储结构：邻接矩阵和邻接表。如果$G$ 是无向图，我们可以把无向边看作两条方向相反的有向边，从而使用与有向图相同的方式存储。\n邻接矩阵 当 $G$是稠密图且 $n$ 不太大（当内存限制为256MB时，一般有$n \\leq 8192$ )时，一般使用邻接矩阵来存储。\n邻接矩阵是一个大小为 $n^{2}$ 的矩阵，定义为： $$ A[i,j]=\\left{\\begin{matrix}0,i=j \u0026 \\ w(i,j),(i,j)\\in E \u0026 \\ +\\infty ,(i,j)\\notin E \u0026 \\end{matrix}\\right. $$ 显然，邻接矩阵判断两点之间是否有有向边只需要 $O(1)$的时间复杂度，计算某点的出度和入度只需要分别遍历以该点为下标的行和列中介于 $0$和$+\\infty$ 之间的值的数目即可。但显然，邻接矩阵的空间复杂度为$O(n^{2})$ ，且在存储稀疏图时，大量的存储空间被浪费，所以邻接矩阵通常只适合顶点数量较少的稠密图的存储。\nconst int MAXN = 3010; int a[MAXN][MAXN], n, m; // 邻接矩阵的构建 void build() { scanf(\"%d %d\", \u0026n, \u0026m); memset(a, 0x3f, sizeof(a)); for(int i = 1; i \u003c= n; i++) a[i][i] = 0; for(int i = 1; i \u003c= m; i++) { int x = 0, y = 0, w = 0; scanf(\"%d %d %d\", \u0026x, \u0026y, \u0026w); a[x][y] = min(a[x][y], w); // 当两点间存在多重边时，只记录权值最小的一条 } } 邻接表 当 $n$ 比较大的时候，我们通常使用邻接表进行存储。\n邻接表是存储图和树、以及实现开散列Hash表的通用结构，是多个数据链表的集合。在邻接表中，存储的数据被分为若干类，每类的数据单独存储在一个数据链表中。同时，在每个数据链表中选出一个代表元素，称为对应链表的表头，并将这些表头组成一个可以随机访问的索引数组，通过访问表头数组便可以定位到任一类数据对应的链表。\n在存储图时，我们通常将每一类数据定义为每条以同一个顶点为起点的有向边之终点。此时，表头数组的成员是出度不为0的顶点，每个数据链表的成员是以对应表头元素为起点的有向边对应的终点。在向数据链表中加入新成员时，我们直接从表头处插入。因此，在我们遍历数据链表以获得以某个顶点为起点的所有有向边对应的终点集合时，我们的遍历顺序与插入顺序相反。\n显然，邻接表的空间复杂度为 $O(n + m)$ 。\n因为编写链表时涉及动态内存分配这一比较耗时的操作，所以我们通常使用以下两种方式实现邻接表：\n多维Vector Vector的push_back方法可以让我们很容易地建立邻接表，同时避免使用链表结构。\nconst int MAXE = 1e5 + 10;\t// 边的最大数目 vector\u003cint\u003e ver[MAXE], edge[MAXE];\t// 存放每条边的终点和边权 // 添加权值为w的有向边(x,y) void add(int x, int y, int w) { ver[x].push_back(y); edge[x].push_back(w); } // 遍历从x出发的所有边 int sz = ver[x].size(); for(int i = 0; i \u003c sz; i++) { int y = ver[x][i], w = edge[x][i]; // PROCEDURE... } 但多维vector速度很慢（因为也涉及内存分配问题），而且每一次内存分配后会比之前多出50%的空间，可能导致MLE，因此在数据量较大时不宜使用。\n数组模拟链表（链式前向星） 众所周知，在存储空间最大值确定时，我们可以用数组来模拟链表，且因为不涉及显式的内存分配操作，所以速度很快。我们也可以采用这一思路实现邻接表。在这种实现方法中，我们使用所谓的边集数组来显式地存储图的边，这种结构又被称作链式前向星。\n我们需要以下四个数组进行存储：大小为 $\\Omega (m)$的边集数组ver和edge分别存放编号为 $i$的边的终点ver[i]和边权edge[i]，并需要一个大小为 $\\Omega (n)$ 的表头数组head来记录从第$j$ 个节点出发的第一条边的编号head[j]。最后，我们还需要一个大小为$\\Omega (m)$ 的数组next来模拟指针，表示从相同节点出发的当前边的下一条边的编号。\nconst int MAXN = 1e5 + 10; const int MAXM = 1e6 + 10; int head[MAXN], ver[MAXM], edge[MAXM], next[MAXM]; int tot;\t// 表示已存储边的数目 // 初始化邻接表 void init() { memset(head, 0, sizeof(head)); memset(next, 0, sizeof(next)); tot = 0; } // 插入权值为w的有向边(x, y) void add(int x, int y, int w) { ver[++tot] = y; edge[tot] = z;\t// 插入一条编号为++tot的新边 // 模拟插入到链表表头操作 next[tot] = head[x]; head[x] = tot; } // 遍历起点为x的所有边 for(int i = head[x]; i; i = next[i]) { int y = ver[i], z = edge[i]; // PROCEDURE... } 成对变换 前面讲到，我们可以通过存储两条顶点相同、方向不同的边，来将带权无向图化归为有向图进行存储。假设我们将任一无向边均存储为两条编号相邻的有向边 $i$和 $i + 1$( $1 \\leq i \\leq m - 1$)，我们可能希望从 $i$ 访问$i + 1$ ，反之亦然。但我们如何得知与当前边$p$ 的反向的边编号是$p - 1$ 还是$p + 1$ 呢？\n此时，可以采用位运算的一个小技巧： $$ k: \\mathbf{xor}: 1=\\left{\\begin{matrix}k+1,, k=2p,, p\\in \\mathbf{N} \u0026 \\ k-1,, k=2p+1,, p\\in \\mathbf{N} \u0026 \\end{matrix}\\right. $$ 亦即，整数对 $(0,1)$, $(2,3)$, $\\cdots$, $(2p, 2p+1)$关于运算 $\\mathbf{xor} , 1$ 构成变换。从而，我们只需要对任一条边执行$\\mathbf{xor} , 1$ 运算，便可获知与其反向的边的编号了。显而易见地，ver[i]为第$i$ 条边的终点，而ver[i xor 1] 为第$i$ 条边的起点。\n在使用这一技巧时我们还需注意一点：变量tot应被初始化为1，因为0与1构成成对变换，而0在我们的模板中不是一个合法编号。\nconst int MAXN = 1e5 + 10; const int MAXM = 1e6 + 10; int head[MAXN], ver[MAXM], edge[MAXM], next[MAXM]; int tot = 1; void init() { memset(head, 0, sizeof(head)); memset(next, 0, sizeof(next)); tot = 1; } // 分别加入权值均为w的有向边(x, y)和(y, x) void add(int x, int y, int w) { ver[++tot] = y; edge[tot] = w; next[tot] = head[x]; head[x] = tot; ver[++tot] = x; edge[tot] = w; next[tot] = head[y]; head[y] = tot; } // 遍历起点为x的所有边（及其反向边） for(int i = head[x]; i; i = next[i]) { int y1 = ver[i], y2 = ver[i ^ 1], w = edge[i]; // PROCEDURE... } ","description":"","tags":["ACM报告"],"title":"图算法简论(2) ：图的存储结构","uri":"/posts/%E5%9B%BE%E7%AE%97%E6%B3%95%E7%AE%80%E8%AE%BA2_%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"},{"categories":["Programming Contest","ACM"],"content":"题目 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld\n题目描述 ZZT 创造了一个队列 Q。这个队列包含了 N 个元素，队列中的第 i 个元素用 Qi 表示。Q1 表示队头元素，QN 表示队尾元素。队列中的元素是 N 的一个全排列。 ZZT 需要在这个队列上执行 P 次操作，操作分两种： FIRST X: 将元素 X 移到队头。 LAST X: 将元素 X 移到队尾。 在 P 次操作之后，ZZT 想知道队列中的元素的排列方式，由于他最近很忙，因此需要请你帮他解决这个问题。\n输入描述: 第一行输入一个正整数 N，表示队列的大小。 第二行输入 N 个正整数，Q1, Q2, Q3, ... ..., QN，Qi 表示队列中的第 i 个元素。保证这 N 个数是 N 的一个全排列。 第三行输入一个正整数 P，表示接下来要进行的操作次数。 接下来 P 行，第 i 行输入一个字符串 Si 以及一个正整数 Xi，表示一次操作。 1 ≤ N ≤ 105. 1 ≤ Qi ≤ N. 1 ≤ P ≤ 105. Si { “FIRST”, “LAST” }. 1 ≤ Xi ≤ 105. 输出描述: 输出 N 个正整数，表示 P 次操作之后的队列。 示例1 输入 4 4 2 1 3 3 FIRST 4 LAST 2 LAST 1 输出 4 3 2 1 题解 这个题的数据量比较大，用类似插入排序的方法只能过65%的数据，但因为题目给出的数据是n的全排列，因此队列中不会有重复的数据，所以可以另开一个数组维护队列中每个元素的位置，之后要用到某个元素的位置时根据值反查位置。\n同时因为移动位置操作开销较大，可开一个较大的数组（大概5e5），并从数组的中部开始存入队列的数据，并维护一个start和end指针来指示数组第一个元素的前一个位置和数组最末元素的后一个位置，每当出现元素移动位置事件时，修改start和end指针的位置，并采用懒惰删除的策略标记数组中原有位置，最后遍历整个队列数组打印队列。时间复杂度O(n+q)。\n代码 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e using namespace std; #define FIRST \"FIRST\" #define LAST \"LAST\" const int MAXN = 1e5; int q[MAXN * 5]; int h[MAXN + 100]; int main(){ int n = 0; while(scanf(\"%d\", \u0026n) != EOF) { int start = 2e5 - 1; int end = start + n + 1; for(int i = 1; i \u003c= n; i++) { scanf(\"%d\", \u0026q[i + start]); h[q[i + start]] = i + start; } int p =0; scanf(\"%d\", \u0026p); char tmp[10]; int x =0; for(int i = 0; i \u003c p; i++) { scanf(\"%s %d\", tmp, \u0026x); if(strcmp(FIRST, tmp) == 0) { q[start] = q[h[x]]; q[h[x]] = -1; h[x] = start; start--; } else if(strcmp(LAST, tmp) == 0) { q[end] = q[h[x]]; q[h[x]] = -1.; h[x] = end; end++; } } int ok = 0; for(int p = start + 1; p != end; p++) { if(q[p] != -1) { ok ? putchar(' ') : 1; printf(\"%d\", q[p]); !ok ? ok = 1 : 1; } } putchar('\\n'); } return 0; } ","description":"","tags":["ACM题解"],"title":"A.队列Q - WannyFly挑战赛19","uri":"/posts/a.%E9%98%9F%E5%88%97q_-_wannyfly%E6%8C%91%E6%88%98%E8%B5%9B19/"},{"categories":["Algorithm","DP","Linear"],"content":"从斐波那契数列说起 可能你从来没有接触过动态规划，只是隐约听别人提起过DP是种特别厉害的算法；又或许你已经看过动态规划的相关定义和教程，能够做一些像LCS、数字三角形之类的简单DP题目。\n但无论你对DP了解如何，阅读本文都会使你对动态规划有更为清晰的认识。不同于你可能看过的很多资料，本文将会以一种更为崭新的视角，从更为本质而数学化的角度出发，尽力发掘出隐藏在所谓的“状态转移方程”、“最优子结构”等重重迷雾下动态规划的真实一面。\n首先要搞明白的一点是：类似递归、二分甚至深度优先搜索等，动态规划是一种策略而不是一种特定的算法；也就是说，动态规划提供一种分析问题的方式。 它通过将问题分解成一个个子问题代表的状态，通过逐渐求解这些子问题，在不同状态之间不断转移，最终计算得出问题的解。也就是说，动态规划的理论性和实践性都比较强，既要求你能够正确地对问题进行建模，又要求你在获得问题的理论分析之后，能够正确构造出解决问题的算法。可以这么说：对动态规划的掌握程度，就是你对问题分析和建模能力的直接体现。\n我们先从一个常见的例子说起：斐波那契数列的计算。在学习分治法时，你可能已经见过这个问题，并且还知道这个问题是使用递归的一个不良例子。我们再来回顾一下这个例子：\n// 使用递归计算斐波那契数列的第n项 int Fib(int n) { if(n == 0) return 0； else if(n == 1) return 1; else return Fib(n - 1) + Fib(n - 2); } 大概计算到n = 40时就要开始等几秒才会出现结果了，随着n不断增大，这个程序的计算速度会迅速降低，最后甚至引发崩溃。原因也很简单：如果我们将每次求解Fib(n)视作一个问题，那么当我们求解这个问题时，我们先要求解子问题Fib(n - 1)，在这个过程中我们已经递归求解了子问题Fib(n - 2)；而之后我们又把子问题Fib(n - 2)重复求解了一遍！因为无论是Fib(n - 1)还是Fib(n - 2)，其求解都涉及更多下属的子子问题，当n很大时这些子子问题重复求解的次数加起来就会十分可观，最终这个算法的时间复杂度将会达到惊人的$O(2^{n})$。\n因此，我们说：斐波那契数列的计算问题具有重复子问题性质。分治法面对这类问题是无效的，因为它的目的是将问题划分为互不相交的子问题，之后分别求解。因此，分治法并不考虑是不是做了重复工作；它只是简单地求解给定的子问题。因此，如果我们试图使用分治法来求解具有重复子问题性质的问题，分治法将陷入无休止地对重复子问题的反复求解中。\n但是将问题划分成子问题是一个非常有效的简化问题的途径，我们不想也不能抛弃这一方法；那么有什么方法可以改善我们的处境呢？回想上文关于动态规划的描述：我们将每个子问题视作一个状态。而我们可以将不同的状态记录下来。当我们需要知道某个状态的值时，我们先查看之前是否已经记录这一状态：如果有的话，就直接提取；否则计算这一状态的值，之后保存下来。通过这种做法我们便可避免对子问题的重复计算。下面的代码描述了这一思想的实现：\n#define MAX 1000 int f[MAX]; memset(f, -1, sizeof(f)); f[0] = 0; f[1] = 1; int Fib(int n) { if(f[n] != -1) return f[n]; else return (f[n] = Fib(n - 1) + Fib(n - 2)); } 我们称这一方式为记忆化搜索。顾名思义，它将问题中已经“搜索”过的部分记忆下来，之后每次需要时调用。\n但是我们仍觉得，这个问题可以有更符合直觉的解法：我们观察上述解法可以发现，我们在求解一个子问题前，总要先求解比其更小的子问题。在上面的解法中，我们是从最大的总问题出发去求解比其小的问题，这样我们仍避免不了对子问题的计算。如果我们将顺序反过来：从最小的子问题开始递推，逐步由小到大自底向上地解决问题，这样当我们需要求解一个新的子问题时，所用到的子子问题就总是已经解决好的。通常，这种思路更符合我们的直觉，因而也更常用；同时也可以避免记忆化搜索中仍然存在的函数调用的开销。\n#define MAX 1000 int f[MAX]; memset(f, -1, sizeof(f)); f[0] = 0; f[1] = 1; int Fib(int n) { for(int i = 2; i \u003c= n; i++) f[i] = f[i - 1] + f[i - 2]; return f[i]; } 从这个问题中我们可以看出：动态规划利用问题的可划分性以及子问题之间的相似性来进行归纳，从而降低求解的复杂度。动态规划将一个问题视作若干个重复子问题的逐层递进，并且将每个子问题的求解过程视作一个阶段；只有完成前一个阶段的计算后，才会开始后一个阶段的计算。\n但是这里还没有展现出动态规划的重要用途：给出问题的一个最优解（因为问题的最优解通常不止一个）。通常情况下，问题的某个状态可能并不来源于固定的子问题，而是由很多子问题中的一个或一些导出，而这些子问题的解包含足够的信息来决定何种选择可使这个状态达到最优。并且，我们还没有系统地阐明如何使用动态规划方法来对一个问题进行分析。因此，我们来看下一个例子：\n初探状态设计：数塔 (HDU.2084) Problem Description 在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的：\n有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？\n已经告诉你了，这是个DP的题目，你能AC吗?\nInput 输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 \u003c= N \u003c= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。\nOutput 对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。\nSample Input 1 5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 Sample Output 30 分析 初看这道题时，dfs是很容易想到的方法，但是使用dfs遍历整个数塔，其时间复杂度则又会是指数级的；我们需要进行动态决策来缩小此题的状态空间。因此，我们仍然尝试使用动态规划来解决此题。\n回想上文关于动态规划的描述：我们首先需要将原问题分解为很多逐层递进的子问题，每个子问题代表了问题的一个状态，而每个子问题的求解过程则构成求解过程的一个阶段。很显然，一个问题的状态表示和阶段划分直接相关。\n那么，我们又如何定义数塔问题的状态呢？我们首先要从精确地定义问题，也即明确目标入手。当问题被精确地定义时，子问题的划分也就变得显然，从而问题中状态的定义也就自然显现。\n我们还需要从之前的dfs的想法中获取思路。我们目前需要获知的信息有以下三点：\n问题的开始条件（也即边界）在何处？ 问题的结束条件是什么？也即，何时我们停止一次搜寻，获得问题的一个解？ 我们怎样从问题的解空间中获取一个最优解？ 在数塔问题中，这三个问题的答案十分显然。我们要从顶层走到底层，因此搜索肯定从顶层开始——这意味着问题的边界是顶层。同样，搜索在底层结束，这意味着一次搜寻也在到达底层时结束，因此问题的结束条件是到达底层。而每次问题的求解都是在一条特定的路径上进行的，这意味着问题求解的每个阶段是一条开始于顶层、结束于底层的路径。最后，我们将遍历这些路径获得的解收集起来，从中取出最优的一个作为最优解。\n但是这样的想法仍然并没有良好地定义这个问题。如果将不同的路径做为问题求解的阶段，则这样定义的子问题显然无助于问题的最终解决——我们无法从已经求解完的子问题中获得任何信息来指导下一阶段的计算，也必须逐个遍历完全部的子问题后才能获知问题最终的最优解。但是我们仍然获得了重要信息——问题的边界和结束条件。我们给出这个问题的良好定义时需要用到它们。\n现在，我们试图从更为抽象的角度来定义这个问题：我们是否可以摒弃对遍历数塔的具体过程的关注，转而直接记录经过数塔底层某个点的路径集合在这个点上的最优解？**也即，我们模仿前面处理斐波那契数列时的方式，采用一个一维数组F[n]来记录从数塔顶部走到数塔底层的第i个点所经过路径的最大和。**现在，我们暂且将此作为关于数塔问题状态的表示。\n相应地，根据重复子问题的原则，我们可以很容易地想到与原问题相似并且大量重复的子问题形式——从数塔顶部走到数塔内第(i, j)点时所经过路径的最大和。显然此时我们需要拓展状态的维度，将存储状态的数组由一维扩展到二维。这样我们就可以给出数塔问题的最终状态表示： $f(i, j)$表示从数塔顶部走到第$i$行第$j$列，所经过路径的最大和。\n现在我们需要考虑问题的求解具体如何进行：我们已经从考虑遍历数塔的具体细节转为考虑数塔中不同的点代表的（子）问题最优解，但我们仍然需要逐个求解这些子问题。我们怎样才能从求解某些子问题，转移到求解其下一阶段的子问题呢？在获得了数塔问题的状态表示后，这个问题不难考虑：$(i, j)$ 点只能从 $(i-1, j)$ 或 $(i-1, j-1)$ 两个点到达，因此 $f(i,j)$也只能由 $f(i-1, j)$ 和 $f(i-1, j-1)$ 两个状态转移而来。更直接地，假设存放数塔三角形的矩阵为 $A$，我们可以列出状态转移方程： $$ f(i,j) = A(i,j)+max[f(i-1, j-1), f(i-1, j)] $$ 凭借这个方程，结合递推我们便可以在问题的不同状态中逐次推进，最终得出我们需要的最优解。\n但是我们此时又面临一个问题：为什么我们在之前定义数塔问题时，通过定义原问题是求“最大和”，直接就能定义其子问题也是求“最大和”？也即：为什么我们能够保证，子问题取到最优，即可以保证其下一阶段的子问题、乃至原问题都取得最优解？\n我们可以通过反证法证明这一点：在上述状态转移方程中，如果我们不取$max[f(i-1,j-1), f(i-1,j)]$ 而是取两者中最小值，所得的 $f(i,j)$ 一定小于第一种情况所得，这与 $f(i,j)$ 应取得最优解不符，因为此时存在一个更优的解。因此原命题得证。我们将这一性质称为最优子结构性质。它保证了动态规划能够对状态的抽象和子问题的重叠递进起到优化作用。\n至此，我们终于分析完了数塔问题。现在我们对上面的分析结果做一个总结：\n问题 数塔 状态表示 $f(i,j)$ 表示从数塔顶部走到第$i$行第$j$列，所经过路径的最大和 阶段划分 某条路径的结尾位置$(i,j)$ 转移方程 $f(i,j) = A(i,j)+max[f(i-1, j-1), f(i-1, j)]$ 边界 $ f(1,1)=A(1,1) $ 目标 $\\underset{1 \\leq i \\leq n}{max}[f(n,i)]$ 题解 #include \u003ciostream\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int INF = 0x3f3f3f3f; const int MAXN = 100; int map[MAXN + 10][MAXN + 10]; int dp[MAXN + 10][MAXN + 10]; int main() { ios::sync_with_stdio(false); int c = 0; cin \u003e\u003e c; while(c--) { int n = 0; cin \u003e\u003e n; for(int i = 1; i \u003c= n; i++) for(int j = 1; j \u003c= i; j++) cin \u003e\u003e map[i][j]; memset(dp, 0, sizeof(dp)); dp[1][1] = map[1][1]; for(int i = 2; i \u003c= n; i++) for(int j = 1; j \u003c= i; j++) dp[i][j] = map[i][j] + max(dp[i - 1][j], dp[i - 1][j - 1]); int ans = 0; for(int i = 1; i \u003c= n; i++) ans = max(ans, dp[n][i]); cout \u003c\u003c ans \u003c\u003c endl; } } 状态设计进阶：最长公共子序列(HDU.1159) Problem Description A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = \u003cx1, x2, …, xm\u003e another sequence Z = \u003cz1, z2, …, zk\u003e is a subsequence of X if there exists a strictly increasing sequence \u003ci1, i2, …, ik\u003e of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = \u003ca, b, f, c\u003e is a subsequence of X = \u003ca, b, c, f, b, c\u003e with index sequence \u003c1, 2, 4, 6\u003e. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y. The program input is from a text file. Each data set in the file contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct. For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line.\nSample Input abcfbc abfcab programming contest abcd mnp Sample Output 4 2 0 分析 不同于上一道数塔问题尚且具有搜索解法，如果我们仍执着于依据题意处理这道题的细节，将会变得非常困难：暴力枚举此题显然不可行，假设字符串X长度为 $n$ ，字符串Z长度为 $m$，则字符串X有子序列 $2^{n}$ 个，字符串Z有子序列 $2^{m}$ 个，此时需要处理的字串对多达 $2^{m+n}$个，显然远远超出任何我们能处理的数据范围。而若不采用暴力枚举的方式，因为最长公共子序列（LCS）逐个分布不均地排列在两个字符串中，使得我们难以找到一个确定的问题开始条件，求解仿佛无从下手。因此，我们仍需借助抽象度更高的动态规划方法来解决这道题。\n通过设计数塔问题状态的经验，我们现在试着设计这样一个状态：$f(i,j)$ 表示字符串X的 前缀子串$[1..i]$ （这里，我们令字符串下标从1开始，为了方便后期直接写出边界条件，实际编程中处理也很简单）和字符串Z的前缀子串 $[1..j]$ 内取得的LCS的长度。那么，这样设计的状态是否具有最优子结构性质呢？我们又如何在不同状态之间进行转移呢？\n我们再次考虑如何将问题缩小一阶，即考虑 $f(i,j)$ 与 $f(i-1, j-1)$ 等相邻阶段状态的关系。很显然 $X[i]$ 和 $Z[j]$ 的关系在这里成为了重点。\n如果 $X[i] = Z[j]$ ，那么状态转移方程很显然会是 $$ f(i, j) = f(i-1, j-1) + 1 $$ 因为 $X[i]$ 或 $Z[j]$ 可以直接接在原有的LCS后方形成新的LCS。\n但是，如果 $X[i] \\neq Z[j]$ 呢？这时要考虑 $f(i-2, j-2)$ 了吗？先别急。我们令 $LCS(i, j)$ 表示字符串X的 $[1..i]$ 区间和字符串Z的 $[1..j]$ 区间内取得的LCS，则 $LCS(i, j)$ 的最后一项还有可能是 $X[i]$ 或 $Z[j]$ ！这是显然的，虽然 $X[i] \\neq Z[j]$ ，但是并没有排除这两个字符仍作为 $LCS(i, j)$ 的最后一项的可能性，因此我们不能直接在状态的两个维度上都直接向后缩小一阶，而是应分别考虑两个维度。因此我们可以写出这种情况下的状态转移方程 $$ f(i,j)=max[f(i-1,j),f(i,j-1)] $$ 写出这个方程时我们实际上已经默认这个问题具有最优子结构性质，根据上面的分析过程证明这一性质也十分容易，在这里我们不再详述。\n现在，我们对LCS问题的分析结果做一个总结：\n问题描述 LCS问题 状态表示 $f(i, j)$ 表示A的前缀子串 $[1..i]$ 和B的前缀子串 $[1..j]$ 的LCS长度 阶段划分 已经处理的前缀在两个字符串中的位置（一个二维坐标） 转移方程 $\\begin{cases} \u0026 f(i,j)=f(i-1,j-1)+1,X[i]=Z[j]\\ \u0026 f(i,j)=max[f(i-1,j),f(i,j-1)],X[i] \\neq Z[j] \\end{cases}$ 边界 $f(i,0)=f(0,j)=0,1 \\leq i \\leq n, 1 \\leq j \\leq m$ 目标 $f(n,m)$ 题解 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int MAXN = 1000; char X[MAXN + 10], Z[MAXN + 10]; int f[MAXN + 10][MAXN + 10]; int main() { while(scanf(\"%s %s\", X + 1, Z + 1) != EOF) { int n = (int)strlen(X + 1); int m = (int)strlen(Z + 1); memset(f, 0, sizeof(f)); for(int i = 1; i \u003c= n; i++) { for(int j = 1; j \u003c= m; j++) { if(X[i] == Z[j]) { f[i][j] = f[i - 1][j - 1] + 1; } else { f[i][j] = max(f[i - 1][j], f[i][j - 1]); } } } printf(\"%d\\n\", f[n][m]); } return 0; } 我们还能做些什么 在前面的两道例题中，我们的目标都是输出问题的一个最优解的值而非这个最优解本身。但是如果现在要求我们输出一个LCS的具体内容，我们又该怎么做？\n输出一个LCS的内容 我们再次将目光投向LCS问题的状态转移方程： $$ \\begin{cases} \u0026 f(i,j)=f(i-1,j-1)+1,X[i]=Z[j]\\ \u0026 f(i,j)=max[f(i-1,j),f(i,j-1)],X[i] \\neq Z[j] \\end{cases} $$ 可以看到，这里的状态转移过程显得很有“方向性”：$f(i,j)$ 总是从 $f(i-1,j-1)$ , $f(i-1,j)$ , $f(i, j-1)$ 三个状态转移过来，并且当且仅当 $f(i,j)$ 从 $f(i-1,j-1)$ 转移而来时，$X[i]$ 或 $Z[j]$ 才是所求LCS中的一个元素。那么，我们如果在计算的中途将 $f(i,j)$ 具体由哪个状态转移而来记录下来，当LCS的长度计算完成时，我们便可以从 $f(n,m)$ 出发一路追踪下去，最终打印出整个LCS序列。\n如果我们将三种状态视作三种“方向”：$f(i-1,j-1)$代表从“左上方”转移而来，$f(i-1,j)$ 代表从“左侧”转移而来，$f(i, j-1)$代表从“上方”转移而来，我们便可以在已有的二维数组 $f$ 内继续维护有关方向的信息，之后输出时根据方向向后追踪并逆序输出结果。\n在原有的代码上稍加改动，我们便可以得到下面的程序：\n#include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; #define UL 1 #define L 2 #define U 3 const int MAXN = 1000; struct Node { int status, arrow; }; char X[MAXN + 10], Z[MAXN + 10]; Node f[MAXN + 10][MAXN + 10]; int LCSlength(char* X, char* Z, Node* f, int n, int m); void PrintLCS(char* X, char* Z, Node* f, int p, int q); int main() { while(scanf(\"%s %s\", X + 1, Z + 1) != EOF) { int n = (int)strlen(X + 1); int m = (int)strlen(Z + 1); printf(\"%d\\n\", LCSlength(X, Z, f, n, m)); PrintLCS(X, Z, f, n, m); putchar(); } return 0; } int LCSlength(char* X, char* Z, Node* f, int n, int m) { memset(f, 0, sizeof(f)); for(int i = 1; i \u003c= n; i++) { for(int j = 1; j \u003c= m; j++) { if(X[i] == Z[j]) { f[i][j].status = f[i - 1][j - 1] + 1; f[i][j].arrow = UL; } else { if(f[i - 1][j].status \u003e f[i][j - 1].status) { f[i][j].status = f[i - 1][j].status; f[i][j].arrow = U; } else { f[i][j].status = f[i][j - 1].status; f[i][j].arrow = L; } } } } return f[n][m].status; } void PrintLCS(char* X, char* Z, Node* f, int p, int q) { if(p == 0 || q == 0) return; if(f[p][q].arrow == UL) { PrintLCS(X, Z, f, p - 1, q - 1); printf(\"%c \", X[p]); } else if (f[p][q].arrow == U) { PrintLCS(X, Z, f, p - 1, q); } else { PrintLCS(X, Z, f, p, q - 1); } } ","description":"","tags":["ACM报告"],"title":"动态规划系列(1): 线性DP","uri":"/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%971__%E7%BA%BF%E6%80%A7dp/"},{"categories":["Algorithm","Basic","Bitwise operation"],"content":"题目 描述 你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。\n我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态\n10111\n01101\n10111\n10000\n11011\n在改变了最左上角的灯的状态后将变成：\n01111\n11101\n10111\n10000\n11011\n再改变它正中间的灯后状态将变成：\n01111\n11001\n11001\n10100\n11011\n给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。\n格式 输入格式 第一行有一个正整数n，代表数据中共有n个待解决的游戏初始状态。\n以下若干行数据分为n组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。\n对于30%的数据，n\u003c=5；\n对于100%的数据，n\u003c=500。\n输出格式 输出数据一共有n行，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。\n对于某一个游戏初始状态，若6步以内无法使所有灯变亮，请输出“-1”。\n样例1 样例输入1 3\n00111\n01011\n10001\n11010\n11100\n11101\n11101\n11110\n11111\n11111\n01111\n11111\n11111\n11111\n11111\n样例输出1 3\n2\n-1\n解法 详细思路 一开始面对此题我们可以很容易想到使用BFS或DFS来搜索从给定状态是否能够达到全亮的状态，但是对于多组数据的情况这种解法的时间复杂度会不太理想。\n我们不妨换一种思考模式：既然我们可以从给定的状态正向搜索出全亮的状态，我们也就可以从全亮的状态反向搜索出给定的状态。因此我们可以采用这样的方式：在程序开始处进行一次初始化，从全亮的状态进行一次BFS，搜索出所有6步以内可以达到的状态并记录步数。之后每读入一个状态就可以立即给出这种状态所需的步数了。显然这个题使用位运算来记录状态会非常方便。\n代码 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003cqueue\u003e #include \u003calgorithm\u003e using namespace std; int map[1 \u003c\u003c 25]; void bfs(); int press(int status, int num); int main() { memset(map, -1, sizeof(map)); bfs(); int n = 0; scanf(\"%d\", \u0026n); while(n--) { int light = 0; char line[10]; for(int i = 0; i \u003c 5; i++) { scanf(\"%s\", line); for(int j = 0; j \u003c 5; j++) { light \u003c\u003c= 1; light |= (line[j] - '0'); } } printf(\"%d\\n\", map[light]); } return 0; } int press(int status, int num) { int pre = status; status ^= (1 \u003c\u003c num); if(num % 5 != 0) status ^= (1 \u003c\u003c (num - 1)); if(num % 5 != 4) status ^= (1 \u003c\u003c (num + 1)); if(num / 5 != 0) status ^= (1 \u003c\u003c (num - 5)); if(num / 5 != 4) status ^= (1 \u003c\u003c (num + 5)); if(pre == status || map[status] != -1) return -1; else if(map[status] == -1) { map[status] = map[pre] + 1; return status; } } void bfs() { queue\u003cint\u003e q; int status = (1 \u003c\u003c 25) - 1; map[status] = 0; q.push(status); while(!q.empty()) { status = q.front(); q.pop(); if(map[status] \u003c 6) { for(int i = 0; i \u003c 25; i++) { int now = press(status, i); if(now != -1) q.push(tmp); } } } } 优化 详细思路 按照上面的做法我们需要处理的状态空间仍比较大，能不能尽量缩小？观察这个题我们可以发现两点性质：\n每个位置至多只会被点击一次 如果固定了第一行的点击方案，则整个矩阵的点击方案也都会被确定 其中性质1显然成立。下证性质2：\n我们将命题2改写为其等价命题：“如果固定了第1行的点击方案，则第$k $行$k \\geq 1$的满足题意的点击方案也被确定”。\n采用归纳法进行证明：\n当$p = 1$时，命题显然成立。\n假定当$p=1,2,\\cdots,k(k \\geq 1)$时，命题成立；\n那么当$p = k + 1 $时，因为前$k $行的点击方案均被确定，此时欲改变第$k $行内关闭的灯之状态，则必须改变其下方第$k+1 $行内对应灯之状态；同时$k+1$行内其他灯均不可改变状态，因若如此，第$k$行内已打开的灯将被关闭，此时不符题意。因此：第$k+1$行的点击方案完全由第$k$行决定，是固定的。故此时命题成立。\n由归纳假设，命题对一切正整数$p$均成立。证毕。\n因此我们只需要枚举第1行的点击方案（共32种），而第2，3，4，5行的点击方案均可由第1行的点击方案地推得到，大大缩小了我们需要处理的状态空间。\n代码 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003ccmath\u003e #include \u003calgorithm\u003e using namespace std; const int INF = 0x3f3f3f3f; int press(int status, int n); int main() { int n = 0; scanf(\"%d\", \u0026n); while(n--) { int status = 0; char tmp[10]; for(int i = 0; i \u003c 5; i++) { scanf(\"%s\", tmp); for(int j = 0; j \u003c 5; j++) { status \u003c\u003c= 1; if(tmp[j] == '1') status |= 1; } } int mintime = INF; for(int i = 0; i \u003c (1 \u003c\u003c 5); i++) { int t = i, p = status, num = 0; for(int j = 0; j \u003c 5; j++) { if(((t \u003e\u003e (4 - j)) \u0026 1) == 1) { p = press(p, 24 - j); num++; } } for(int j = 1; j \u003c 5; j++) { for(int k = 0; k \u003c 5; k++) { if(((p \u003e\u003e (24 - 5 * j + 5 - k)) \u0026 1) == 0) { p = press(p, 24 - 5 * j - k); num++; } } } bool flag = true; for(int j = 0; j \u003c 5; j++) { if((p \u0026 1) == 0) { flag = false; break; } p \u003e\u003e= 1; } if(flag) { mintime = min(mintime, num); } } printf(\"%d\\n\", mintime \u003e 6 ? -1 : mintime); } return 0; } int press(int status, int n) { status ^= (1 \u003c\u003c n); if(n / 5 != 4) status ^= (1 \u003c\u003c (n + 5)); if(n / 5 != 0) status ^= (1 \u003c\u003c (n - 5)); if(n % 5 != 4) status ^= (1 \u003c\u003c (n + 1)); if(n % 5 != 0) status ^= (1 \u003c\u003c (n - 1)); return status; } ","description":"","tags":["ACM题解"],"title":"Vijos.1197 费解的开关","uri":"/posts/vijos.1197_%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/"},{"categories":["Programming Contest"],"content":"函数 memset 赋值 我们在设计程序时经常会使用memset(array, val, sizeof(array))来初始化一个int数组array，因为memset是string.h中的函数所以其填充对象也是字节，会将数值val（或者是字符val）填充到array的每个字节上，因此用memset只能赋值出每字节都相同的int。\n因此，我们如果想要将某个数组初始化为INF，则能赋值出的最大数值为0x7fffffff。但是为了避免加法算术溢出或其他判断，我们通常选择将数组的每个int初始化为0x3f3f3f3f。这个数值满足以下两个条件：\n整数的两倍不超过0x7fffffff（即INT_MAX）。 整数的每8位都相同（恰好可以用memset填充）。 因此我们通常使用memset(array, 0x3f, sizeof(array))来初始化int数组。\nscanf 读取数组元素 输入括号需要来回切换光标，十分麻烦…如果不想输入类似\u0026a[i]的符号，可以使用指针形式来简化输入: scanf(\"%d\", a + i);\n这个方法也适合在读入字符串时将其存储在并非数组开头的位置。\n数学 余式定理 对多项式$P(x) $，有$\\frac{P(x)}{x-a}$之余式为$ P(a)$。\n更一般地，假设对于多项式除法$\\frac{P(x)}{M(x)}=Q(x)+R(x) $，其中商是$Q(x) $，余式是$R(x) $，若$ M(x)$是n次式$ (n \\geq 1)$，则可将其$ n$个根列出联立方程\n$$\\P(a)=R(a) \\P(b)=R(b) \\P(c)=R(c) \\ \\cdots$$\n证明 考虑$\\frac{P(x)}{x-a}=Q(x)+R(x)$。\n由除法定理有$P(x)=(x-a)Q(x)+R(x) $。且因为$x-a $是1次式，故$ R(x)$为常数，记为$ r$。\n此时代入$x=a $，可得$ P(a)=r$。证毕。\nAttention Points 运算符优先级 一些运算符的优先级由高到低如下表所示，最需要注意的点是：大小关系比较运算符的优先级高于“位与”“位或”“位非”运算符。\n加减 移位 比较大小 位与 异或 位或 +, - «, » \u003e, \u003c, ==, != \u0026 ^ 位或 vector 的 push_back 相关 在没有显式为某个vector分配空间时，绝不能用下标访问其元素而应使用push_back。\n阴险的出数据方式 POJ 3263 一条关系$ (A_{i}, B_{i})$ 可能会输入多次（即输入重边），刻意影响区间操作。\n","description":"","tags":["ACM解题总结"],"title":"ACM Trick Points (持续更新)","uri":"/posts/acm_trick_points_%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":["Algorithm","Graph","Shortest Path"],"content":"题目 As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.\n输入描述\nEach input file contains one test case. For each test case, the first line contains 4 positive integers: N (\u003c= 500) - the number of cities (and the cities are numbered from 0 to N-1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2.\n输出描述\nFor each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.\nInput\n1 2 3 4 5 6 7 8 5 6 0 2 1 2 1 5 3 0 1 1 0 2 2 0 3 1 1 2 1 2 4 1 3 4 1 Output\n1 2 4 题目翻译 作为一个城市紧急援救队的指挥者，你得到了一个国家的特殊地图。地图上分散着几座城市，城市间用道路连接着。每个城市援救队的数量以及两座城市之间每条道路的长度已经在地图上标出。当某些城市发生了突发事件，需要你的帮助时，你的工作是带领你的队伍尽快的赶到事发现场，与此同时，召集尽可能多的在路上的队伍。\n输入\n每个输入文件包含一个测试实例。每个实例的第一行有四个正整数：N(\u003c= 500)是城市的个数（城市的编号从0到N-1），M是道路的个数，C1和C2分别是你现在所在的城市以及你必须去救援的城市。下一行有N个整数，第i个整数是第i个城市中救援队的数量。然后下面有M行，每行表示一条道路。每一行有三个整数c1,c2和L，分别表示道路连接的两个城市以及道路的长度。保证C1到C2之间存在至少一条路径。\n输出\n对于每个测试实例，在一行中输出两个数字：C1和C2之间不同的最短路径的个数，你能聚集起来的最多的救援队数量。\n一行中的所有数字必须被一个空格分隔开，在每行的结尾不允许出现空格。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003cqueue\u003e #include \u003calgorithm\u003e using namespace std; #define MEM(x, v) memset((x), (v), sizeof((x))) const int MAXN = 510; const int INF = 0x3f3f3f3f; class Node { public: int l, v; Node() {} Node(int a, int b) { l = a; v = b; } bool operator \u003c (const Node \u0026 p) const { return l \u003e p.l; } }; int vis[MAXN]; int minLen[MAXN]; int nvalue[MAXN]; int minRoad[MAXN]; int maxSave[MAXN]; int map[MAXN][MAXN]; int n, m, c1, c2; void init(); void dijkstra(Node\u0026 start); int main() { while(scanf(\"%d %d %d %d\", \u0026n, \u0026m, \u0026c1, \u0026c2) != EOF) { init(); for(int i = 0; i \u003c n; i++) scanf(\"%d\", \u0026nvalue[i]); int tmp1 = 0, tmp2 = 0, tmpL = 0; for(int i = 0; i \u003c m; i++) { scanf(\"%d %d %d\", \u0026tmp1, \u0026tmp2, \u0026tmpL); map[tmp1][tmp2] = map[tmp2][tmp1] = tmpL; } Node p = Node(0, c1); dijkstra(p); printf(\"%d %d\\n\", minRoad[c2], maxSave[c2]); } return 0; } inline void init() { MEM(vis, 0); MEM(minLen, INF); MEM(nvalue, 0); MEM(map, INF); MEM(minRoad, 0); MEM(maxSave, 0); } void dijkstra(Node\u0026 start) { priority_queue \u003cNode\u003e q; q.push(start); minRoad[c1] = 1; maxSave[c1] = nvalue[c1]; Node now; while(!q.empty()) { now = q.top(); q.pop(); vis[now.v] = true; for(int i = 0; i \u003c n; i++) { if(!vis[i] \u0026\u0026 map[now.v][i] != INF) { if(minLen[i] \u003e now.l + map[now.v][i]) { minLen[i] = now.l + map[now.v][i]; maxSave[i] = maxSave[now.v] + nvalue[i]; minRoad[i] = minRoad[now.v]; q.push(Node(minLen[i], i)); } else if (minLen[i] == now.l + map[now.v][i]) { minRoad[i] += minRoad[now.v]; maxSave[i] = max(maxSave[i], maxSave[now.v] + nvalue[i]); } } } } } ","description":"","tags":["ACM题解"],"title":"PAT.1003 Emergency","uri":"/posts/pat.1003_emergency/"},{"categories":["Algorithm","Combinatorics"],"content":"**默慈金数 (Motzkin Number)**是特殊计数序列中的一种。在中文互联网上比较难查到有关默慈金数的资料，能获得的信息基本局限于默慈金数的定义和（一种）应用，并且这两者之间没有什么比较明显的联系。事实上，作为一种特殊计数序列，想研究默慈金数就逃不开大名鼎鼎的卡特兰数。下面就让我们通过引入卡特兰数，逐步认识默慈金数，以及阐释51Nod 1556利用默慈金数的思路。\n什么是默慈金数 网上能查到的有关默慈金数的资料一般局限于两点：默慈金数的定义和默慈金数在格路径（也就是网格中的路径）中的应用。\n默慈金数是这样定义的：在数学中，一个给定的数n的默慈金数（下文记作Mn)是在一个圆上的n个点间，画出彼此不相交的弦的全部方法的总数。\n比如n = 4时，M4 = 9：\n且n = 5时，M5 = 21：\n但显然这种定义很难直接利用（毕竟让你在圆上画弦的机会不多）。相应地，我们可以见到默慈金数的这种应用：在一个网格上，若限定每步只能向右移动一格（可以向右上、右下和水平向右），并禁止移动到y=0以下的地方”，则以这种走法用n步从（0,0）移动至（n,0）的可能形成的路径的总数为n的默慈金数。\n比如从(0, 0)运动到(4, 0)，同样有9种方式：\n但是很明显，默慈金数的定义和这种应用形式之间的关系十分不显然。但是好在默慈金数有这样一个计算公式： $$ M_{n} = \\sum_{k=0}^{\\left \\lfloor n/2 \\right \\rfloor}C^{2k}{n}Catalan(k) $$ 其中Catalan(k)是第k个卡特兰数（下文记作C{k}）。这个公式将默慈金数与卡特兰数联系起来，这就为我们提供了理解默慈金数的方向。\n什么是卡特兰数 如果我们要写一个计算中缀表达式的程序，很显然我们会遇到括号的处理。正常情况下，表达式中的括号应该是成对出现的，像这样： $$ ((a+b)((c+d)*e)) $$ 但是有时我们可能会遇到这样不合法的表达式：出现了不成对的左括号或右括号，比如： $$ (a+b)(a+b $$ 或者是 $$ (a+b)*c)(a+b) $$ 我们忽略括号中具体表达式的值，将第一种情况中正确使用的括号序列称作好括号列，而将下面两种情况中错误使用的括号序列称作坏括号列。显然一个括号列是好是坏一读便知。\n易证，一个括号序列是好括号列的充分必要条件为：\n该括号序列由偶数个括号组成，其中半数是 ‘(’，半数是 ‘)’。 从左向右阅读括号序列时，读出的右括号 ‘)’ 的数目不会比左括号 ‘(’ 的数目多。（因为括号是成对出现的） 我们考虑这样一个问题：由2n个括号（半数为左括号，半数为右括号）可以组成多少个好括号列？\n为了计算这个值，我们先考虑一个坏括号列：设 $$ p_{1}p_{2}p_{3} \\cdots p_{2n-1}p_{2n} $$ 是一个由n个左括号和n个右括号组成的坏括号列。则根据好括号列充要条件中的第二条，这个坏括号列中必然存在一个前缀，其中的右括号 ‘)’ 数目比左括号 ‘(’ 多。\n那么，我们设 $$ p_{1}p_{2}p_{3} \\cdots p_{j-1}p_{j} $$ 是该括号列中最短的一个“坏”前缀。显然这个“坏”前缀中右括号’)‘只比左括号’(‘多一个（否则就一定能通过缩小长度把第二个右括号删掉）。之后，如果我们把p_{j}之后的部分翻转过来（把原本的左括号 ‘(’ 换成右括号 ‘)’ ，右括号亦然），这个坏括号列就变成了一个由(n - 1)个左括号和(n + 1)个右括号组成的括号序列，也就是说，**n个左括号和n个右括号组成的坏括号列同由(n - 1)个左括号和(n + 1)个右括号组成的括号序列是一一对应的。**那么，我们就可以得到由n个左括号和n个右括号组成的好括号列的个数为 $$ C_{2n}^{n}-C_{2n}^{n+1} $$ 采用二项式系数的记法，也即 $$ \\begin{pmatrix} 2n\\n\n\\end{pmatrix}- \\begin{pmatrix} 2n\\n+1\n\\end{pmatrix} $$ 简化后得 $$ \\frac{1}{n+1}\\begin{pmatrix} 2n\\n\n\\end{pmatrix} $$ 我们把这个表达式称作卡特兰数。\n但是现在卡特兰数和默慈金数仍然看起来没有一点关系！别急，如果我们把左括号记成“向右移动”，将右括号记作”向上移动“，则一个好括号列可以转化为一条**在n × n格点中不越过对角线的单调路径 **:\n这样卡特兰数就变成所有在n × n格点中不越过对角线的单调路径的个数 。（这样就给出了 51Nod 1120 机器人走方格 V3 这道题的解法。）如果把这张图旋转45°，把”向右移动“变成”向右上移动“，把”向上移动“变成”向右下移动“，这样获得的“卡特兰路径”是不是跟上面默慈金数格路径的图很相似了？\n下面是重头戏：默慈金数是用圆上绘制不相交弦的个数定义的，那么卡特兰数有没有相似的展现方式呢？我们考虑这样一个问题：在圆上均匀地取2n个点，用n条彼此不相交的弦**（但允许在端点处相交）**将这些点两两连接成n对，求全部方法的总数。\n如果我们将这2n个点按照顺时针顺序排成一行，当且仅当这个序列中两点是一条弦的两个端点，就把它们用括号括起来。这样，**每种弦的连接方式都会生成一个好括号列。**同时，对于任给的好括号列，也都可以画出对应的弦的连接方式。这就证明了弦图与好括号列之间构成双射关系，因此，这个问题的答案也是卡特兰数。\n下面我们给出C5（第5个卡特兰数）对应的42种连接方式，以及10种错误的连接方式。相应地，我们上文中提到过，M5=21，这揭示了总有 $$ M_{n} \\leq C_{n} $$ 同时这个问题的等价说法是：卡特兰数代表集合{1, 2, …, n}的不交叉划分的个数。意义很明显。\n对默慈金数的分析 通过上文我们对卡特兰数相似的分析，现在我们可以肯定默慈金数的格路径应用和默慈金数的定义是有关系的了。现在我们要先通过我们已经获得的卡特兰数的计算公式，来构造默慈金数的计算公式。\n我们发现：默慈金数的定义不允许弦在端点处相交，而卡特兰数的性质允许。为了防止这种局面，我们必须将整个圆大致分成两部分，每一次各从每部分中取相同数目的点，之后再将这两部分中的点连接成弦。而我们已经取出的点因为是分处于两个部分中，可以保证不会有弦在端点处相交，**所以这时我们可以用卡特兰数来计算取出的点构成的“子集圆“中弦不相交连接的数目！**又，因为允许有不连接弦的点存在，所以我们要逐个取出0, 2, 4, … , n/2个点来分别计算。因此我们可以得到公式 $$ M_{n} = \\sum_{k=0}^{\\left \\lfloor n/2 \\right \\rfloor}\\begin{pmatrix} n\\2k\n\\end{pmatrix} C_{k} $$ 这也正与上文我们提到的公式相符。\n上文分析卡特兰数时我们提到了好括号列。如果用左括号 ‘(‘表示 ”向右上前进“， 用右括号 ‘)‘表示”向右下前进“，我们就能获得一条上面提到的”卡特兰路径“。现在的问题是，用这两个字符描述一条”默慈金路径“显然不够，因为”默慈金路径“中有水平向右移动的部分。因此，我们还需要一个字符 ‘=’ 来表示”水平向右移动。这样，对于图3中的第4张图，我们就可以写出一个对应的默慈金括号列： $$ ()== $$ 现在的问题是把默慈金括号列和默慈金数的定义联系起来。我们再次在圆上均匀地取n个点，并将它们按照顺时针排成一行。如果有两个点连接成一条弦，我们就把左侧的端点用左括号 ‘(‘代替，将右侧的端点用右括号 ‘)‘代替，将没有弦连接的端点用 ‘=’ 代替。这样，我们就把一个圆上的定点序列替换成了一个默慈金括号列。我们将上面提到的默慈金括号列还原成圆上的弦图，它正是图一中的第2张图。\n这样，51Nod 1556的思路就很明显了：要求相邻数的差不能超过1，也就是说第n个数和第n-1个数之间的差可以是1, 0, -1，如果这三个数分别代表向右上移动、水平移动、向右下移动，那么这道题几乎就是描述了一个裸的默慈金数的计算。\n51Nod 1556的具体思路 但是这道题的要求又与默慈金数不一样：默慈金数计算从 (0, 0) 开始，到 (n, 0) 处结束的路径总数，而这道题要求计算从 (0, 0) 开始，到 (n, x) 处 (x \u003e= 0) 结束的路径总数。\n此时，我们可以换一种思路来考虑：默慈金数是从(0, 0)运动到(n, 0)的总数，但是在(n, 0)处就不能再向右下走了，因为再向右下走就越过了y \u003e= 0的限制，之后的路径都是非法的。也就是说，如果我们令x = n + 1（错误的位置），至少在x = n - 1处我们就不能选择向右下走。又因为我们在每一个点可以向三个方向走，所以我们最后可以给出公式 $$ ans[x] = 3 * ans[x - 1] - M[x-2] $$ 而默慈金数的计算可以参照 $$ M_{n+1} = \\frac{(2n+3)M_{n}+3nM_{n-1}}{n+3} $$ 推导过程详见Motzkin Number，在此不再多谈。\n","description":"","tags":["ACM报告","数学"],"title":"卡特兰数与默慈金数","uri":"/posts/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E4%B8%8E%E9%BB%98%E6%85%88%E9%87%91%E6%95%B0/"},{"categories":["Notes"],"content":"hexo部署到github上的文件是你本地的文件（.md）编译成的静态网页（.html），因此当你想要在不同设备间修改博客，或者是重装系统导致博客配置丢失后修改博客就变成了比较麻烦的事情。\n其实，hexo生成的网站文件中有.gitignore文件，所以它的本意也是让你把博客的源文件上传到github上进行管理。今天我们就介绍一种方法，这种方法通过在博客挂在的github仓库中设立一个新的分支hexo，然后将博客源文件以及环境配置和主题配置文件上传到hexo分支（设置为默认主分支），将master分支用作进行博文的deploy工作，这样每次需要重新配置时只需要重新clone一下，之后安装相关环境就可以了。\n建立master和hexo两个分支 安装相关环境和本地配置 git clone 备份更新./themes主题配置文件 安装hexo 博客的日常更新 建立master和hexo两个分支 master分支已经是默认建好的，我们只需修改_config.yml中的deploy分支为master，之后用hexo d命令就会自动将我们的文件编译成静态网页后部署到github。\n之后我们再新建一个hexo分支，并设置为默认主分支，之后将所有的博客源文件都copy到选定目录中。同时，由于hexo中.gitignore文件设置了忽略，因此我们需要再新建一个settings文件夹，将./themes中对应的主题配置文件copy到其中进行备份更新。之后手动git push即可。\n安装相关环境和本地配置 git clone 先从网上下载Node.js和git，之后使用\ngit clone git@github.com:\u003cyourname\u003e/\u003cyourname\u003e.github.io\n拷贝仓库。\n备份更新./themes主题文件 执行如下命令：\ncp -rf ./settings/next ./themes\n安装hexo 执行如下命令：\nnpm install hexo\nnpm install\nnpm install hexo-deployer-git\n并且千万不要执行hexo init，这样会使已经配置好的文件丢失。\n博客的日常更新 依次执行\ngit add .\ngit commit -m \"...\"\ngit push origin hexo\n将改动推送到github上。之后再执行hexo g -d来发布网站。\n","description":"","tags":["hexo"],"title":"hexo在不同电脑间迁移","uri":"/posts/hexo%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E9%97%B4%E8%BF%81%E7%A7%BB/"},{"categories":["Programming Contest","ACM"],"content":"题目 题目描述\n集合要满足互异性，即一个集合不能包含相同的元素。但是有的时候，我们需要集合中包含相同的元素，这种集合叫做多重集合（multiset）。\n现在有一个多重集合，其中有n个整数。现在需要你从其中选出k个整数，使得k个数中任意两个的差都可以被m整除。\n问题来了，能否从多重集合中找到k个数，若果可以的话，输出Yes，否则输出No。\n程序输入说明\n第一行，整数n,k,m，含义如题目所描述。\n第二行，n个整数。\n2\u003c=k\u003c=100000，1\u003c=m\u003c=100000\n程序输出说明\n如果能找到，则输出Yes，否则输出No\n程序输入样例\n3 2 3\n1 8 4\n3 3 3\n1 8 4\n程序输出样例\nYes\nNo\n提示\n对于第一组数据，可以找到两个数1、4，使得他们的差被3整除。输出Yes。\n对于第二组数据，找不到3个数，使得两两之间差被3整除，输出No。\n分析 这个题不能直接上子集树（最后两组数据量比较大），必须对\\(O(N^{2})\\)算法进一步优化。\n考虑k个数中任意两个的差都能被m整除这一点：这代表这两个数mod m的值相同（若\\(A\\equiv B(MOD \\: N)\\)，则\\(A-B\\equiv B-B(MOD \\: N)\\)）。因此，只需要记录每个数mod m的值，如果从0~m-1的范围内有某项的值超过了k，即可以认定存在k个数两两之差均可被m整除。\n代码 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int MAXM = 100010; int ar[MAXM]; int main() { int n = 0, k = 0, m = 0; while(scanf(\"%d %d %d\", \u0026n, \u0026k, \u0026m) != EOF){ memset(ar, 0, sizeof(ar)); int tmp = 0; for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026tmp); ar[tmp % m]++; } bool flag = false; for(int i = 0; i \u003c m; i++){ if(ar[i] \u003e= k){ flag = true; break; } } printf(flag ? \"Yes\\n\" : \"No\\n\"); } return 0; } ","description":"","tags":["ACM题解"],"title":"AOJ.1301 差除","uri":"/posts/aoj.1301_%E5%B7%AE%E9%99%A4/"},{"categories":["Programming Contest","ACM"],"content":"总的来说，这场比赛的题还是比较水的，至少难度什么的甚至没法和热身赛相比。然而这场比赛中不乏需要注意的细节问题，比如unsigned long long出现了好几次什么的。。。在这上面栽了一把。C、H题的分析仍存在问题（还是我菜）。。。暂时不列出。\nA. a*b problem A. a*b problem\n时间：1000ms 空间：256mb\n【题目描述】\n给你两个非负整数a和b，你需要输出a*b的值。\n【程序输入说明】\n第一行输入一个数字T(T\u003c=10)，表示数据组数。\n接下来T行，每行两个非负整数a和b。(0\u003c=a,b\u003c2^32)\n【程序输出说明】\n你需要输出T行，每行表示a*b的结果。\n【输入样例】\n3\n4 3\n11 2\n1 100\n【输出样例】\n12\n22\n100\n【提示】\n无\n分析 看起来这题是道水题，1min写完提交。。。于是您就WA了一发。\n仔细看题面：a, b的最大值可以到\\(2^{32}\\)！这意味着a * b的上限是\\(2^{64}\\)，这个数远远超出了int甚至long long的上限(int的上限是\\(2^{31}-1\\)，long long的上限是\\(2^{63}-1\\))，从而只能用unsigned long long存。用unsigned long long修正后AC。\n注意：这道题比较适合用C++做，因为涉及到unsigned long long类型输入输出的问题，用C++的输入输出流会比较方便，另外就是根据已知情况来看用C语言做这道题即使没有任何问题也可能玄学WA。。。\n代码 #include \u003ciostream\u003e using namespace std; int main() { ios :: sync_with_stdio(false); int T = 0; cin \u003e\u003e T; while(T--){ unsigned long long a, b; cin \u003e\u003e a \u003e\u003e b; cout \u003c\u003c a * b \u003c\u003c endl; } return 0; } B. 白学北楼 B. 白学北楼\n时间：1000ms 空间：256mb\n在安微大学有一个教学楼，叫白学北楼，它的侧面图如下：\n白学北楼由5栋楼宇拼接构成，每栋楼宇都是5层楼，每层楼有一些教室，教室的编号由一个大写字母和三个阿拉伯数字构成，第一个大写字母是A、B、C、D中一个，表示该教室在哪栋楼，第一个阿拉伯数字表示该教室所在的楼层，第二个和第三个阿拉伯数字表示该教室在该楼层的方位。如A202表示A栋2楼的一间教室，D511表示D栋5楼的一间教室。\n比较特殊的是白学北楼有两个B栋，其中数字编号为奇数的教室在B单栋，数字编号为偶数的教室在B双栋，如B207，B511，B101在B单，B100，B502，B312在B双。\n有五条走廊连接着这些建筑(如图中红色所示)：在一楼有四个走廊分别串起了五栋建筑，特殊的是，在B单和B双三楼的中间也有一条走廊，这意味着如果从B311教室走到B308教室，就不需要下楼下到B单一楼，再走到B双一楼再上楼了，可以直\u003e接顺着走廊走过去。\nChelly是一个不喜欢上下楼梯的阿宅，所以如果从一个教室走到另一个教室，他\u003e会选择上下楼梯次数最少的路径。如从B401走到B300，他会选择先下一层楼梯，再走B单B双中间的走廊走过去，于是最少的上下楼梯次数就是1次。如从A505走到D311，那别无他法，Chelly只能下到A的一楼，穿过四条走廊，再从D的一楼走楼梯上到三楼，总共需要上下楼梯6次。\n今天Chelly要在白学北楼上n节课，按顺序给出Chelly的课的所在教室，你需要回答Chelly总共最少需要上下多少次楼梯？\n注意：因为Chelly是一个被宇宙射线射中的人，所以他如果上一节课在B单且下一节课在B双，或者上一节课在B双且下一节课在B单，他一定会走三楼之间的走廊去打水喝。即如果从上一节课教室B100走到下一节课教室B201，他会先上到B双的三楼走走廊过去B单三楼，再下一层楼。所以一共走的次数是3次。但如果上一节课教室是D101，下一节课教室是A101，那么他就不会去打水，直接走一楼走廊走过去，上下楼梯的次数是0.\n【程序输入说明】\n第一行输入一个数字T(T\u003c=10)，表示数据组数。\n每组数据第一行一个数字n(1\u003c=n\u003c=1000)表示Chelly课的数目。\n接下来n行每行一个字符串表示教室编号。（保证教室编号合法）。\n【程序输出说明】\n你需要输出T行，每行表示最少需要走楼梯的数目。\n【输入样例】\n1 4 D222 B201 B442 A111\n【输出样例】\n7\n【提示】\nD222 ——\u003e B201 走两次楼梯\nB201 ——\u003e B442 走两次楼梯\nB442 ——\u003e A111 走三次楼梯\n总共需要走7次楼梯\n分析 没什么好说的，直接翻译题意便可。\n代码 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003ccstdlib\u003e // 将数字字符转化为对应的数字 #define NUM(x) ((x) - '0') // 求某位数模2的余数（用来比较是奇数还是偶数） #define OE(x) ((x) % 2) using namespace std; const int MAXN = 1010; char building[MAXN][10]; int main() { int T = 0; scanf(\"%d\", \u0026T); while(T--){ int n = 0; scanf(\"%d\", \u0026n); for(int i = 0; i \u003c n; i++) scanf(\"%s\", building[i]); int time = 0; for(int i = 0; i \u003c n - 1; i++){ if(building[i][0] != building[i + 1][0]){ time += NUM(building[i][1] - 1) + NUM(building[i + 1][1] - 1); } else { if(building[i][0] != 'B'){ time += abs(NUM(building[i][1]) - NUM(building[i + 1][1])); } else { // 如果两间教室都在B单或都在B双 if(OE(NUM(building[i][3])) == OE(NUM(building[i + 1][3]))){ time += abs(NUM(building[i][1]) - NUM(building[i + 1][1])); } else { time += abs(NUM(building[i][1]) - 3) + abs(NUM(building[i + 1][1]) - 3); } } } } printf(\"%d\\n\", time); } return 0; } D. 瓶子数列 D. 瓶子数列\n时间：1000ms 空间：256mb\n【题目描述】\n瓶子数列是这样的数列:\n若a[1..n]满足存在一个i使得a1\u003e=a[2]\u003e=a[3]\u003e=……\u003e=a[i]\u003c=a[i+1]\u003c=a[i+2]\u003c=……\u003c=a[n]\n那么就称这个数列a[1..n]是一个瓶子数列。如数列{6,4,3,1,1,1,10,11}就是一个瓶子数列，{1,4,3,2,1,1,3}就不是一个瓶子数列。\n现在Alice和Bob在玩一个游戏，Alice偷偷生成一个长度为n的数列a[1..n]，起初Bob对Alice生成的数列一无所知。然后Bob每次可以询问Alice某个位置上的a的值，很明显，Bob询问的次数越多，获得的信息也就越多，当Bob的询问足够多的时候，聪明的Bob就能正确判断出Alice生成的数列a[1..n]是否是瓶子数列了。\n现在给出n和Alice生成的数列a[1..n]，你需要回答在最坏的情况下，聪明的Bob需要询问多少次才能判断出a[1..n]是否是瓶子数列。\nBob是很聪明的，如果他获得的信息足以让他判断出是否是瓶子数列，那么他就能准确地判断出来，并且他不会重复询问之前已经询问过的位置。\n【程序输入说明】\n第一行输入一个数字T(T\u003c=10)，表示数据组数。\n接下来T组数据，每组数据第一行一个整数n(1\u003c=n\u003c=1000)\n第二行n个整数表示Alice生成的数列。(0\u003c=ai\u003c=1000000000)\n【程序输出说明】\n对于每组数据，输出一行，表示Bob最多需要询问的次数。\n【输入样例】\n2\n4\n1 1 1 1\n7\n2 4 1 1 8 1 1\n【输出样例】\n4\n6\n【提示】\n对于第一组数据，Bob在把所有位置的数知晓之前，无法判断出是否为瓶子序列。\n对于第二组数据，Bob询问6次，在7个位置里选6个位置询问，方案数是C(7,6)=7，即一共有7种询问方法，这7种询问方法都能让Bob可以判定是否是瓶子序列；若询问次数小于6，那么容易发现一定存在一种询问方式使得Bob无法判断，所以在最坏情况下，Bob需要询问6次。\n分析 本题是一道动态规划入门题，然而第一次见时确实要花一番功夫思考。下面给出本题详解。\n为什么Bob大多数情况下不需要遍历整个数组 很多人刚看到这道题的时候，肯定都会想：Bob难道不需要每一次都把数组里的所有数询问一遍吗？！如果不这么做，要是漏下数怎么办？\n且慢，Bob毕竟潜心研究密码学30年，每天都在与Alice洪水般的加密消息作斗争，他岂会让您在知乎上水一篇“我比Bob聪明”系列？Bob拿着 (对您而言) 不完整的信息，就敢断定给定的是不是一个瓶子数列，一定有他的道理。\n我们先来看“瓶子数列”指什么：显然瓶子数列指先减后增的单峰数列。如果一个数列不是瓶子数列，就一定有一个峰顶。只要Bob能确认数列中的某个元素是峰顶，立即就能断定这个数列不是瓶子数列。而确定峰顶显然并不需要遍历整个数列。\n以题目中的样例二为例：如果Bob直接询问了第五个元素8，那么他只要接着再询问第1个元素即可：第1个元素是2，现在有8 \u003e 2，不符合瓶子数列的定义。于是此时Bob只询问了两次就能判断给定的数列不是瓶子数列。\n然而令Bob无可奈何的情况还是有的，请见下文。\nBob什么时候需要询问的次数最多 Bob询问每个数列的位置毕竟是随机选择的，他不能依据已知的信息推断出其他的元素按什么规律分布，从而就不能猜测他下一次询问的元素值的大概范围。因此，如果Bob的运气非常不好，他可能会面临这样一种情况：仍以样例二中数列为例，如果Bob事先声明要询问5次，然后他先后询问了位于7，6，4，3，2号上的元素，即4，1，1，1，1，他已知的元素此时构成一个瓶子数列；然而，除非在询问过程中就找到一个峰顶，否则根据已知的子序列构成瓶子数列来推断原数列就是瓶子数列是不可能的！换句话说，Bob现在确实漏数了。他必须要再访问一个元素，才能为他提供足够的信息：剩下的元素2和8都能让他各确认一个峰顶。\n因此，我们可以推断出：\n如果给定数列是瓶子数列，那么Bob不得不遍历数列的每一个元素。 如果给定数列不是瓶子数列，那么Bob最多需要遍历{数列中最长的构成瓶子数列的子数列的长度 + 1}个元素。 怎样帮Bob找到这个子数列 上述推断为我们构造出了状态转移方程的雏形。但是在试图列方程时会面临一个问题：瓶子数列不仅有前半部分，还有第i个元素之后的后半部分，而只列计算前半部分的方程必将忽略后半部分，反之亦然。所以这时我们需要正向和反向各遍历一次。这样列出本题所需的方程就很简单了。\n设\\(m_{r}(i)\\)和\\(m_{l}(i)\\)分别是以第i个元素为结尾的构成瓶子数列的正向和反向最长子数列的长度，给定数列总长设为n，其第i个元素记作a(i)。显然可以分别列出状态转移方程：\n正向情况：\n\\(m_{r}(1)=1\\)\n\\(m_{r}(i)=max(m_{r}(i),m_{r}(j) + 1) || j=1,2,\\cdots,n-1\\)且\\(a(j)\\geq a(i)\\)\n反向情况：\n\\(m_{l}(n)=1\\)\n\\(m_{l}(i)=max(m_{l}(i),m_{l}(j) + 1) || j=n,n-1,\\cdots,2\\)且 \\(a(j)\\geq a(i)\\)\n设Bob最多需要询问time次，则有\n\\(time=m_{r}(i)+m_{l}(i)-1\\)\n此时找出了Bob最坏情况下将会发现的整个最长子数列的长度。依照上文，如果该长度与给定数列长度相等，则直接输出time，否则输出time + 1。\n代码 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int MAXN = 1010; int a[MAXN], mr[MAXN], ml[MAXN]; int main() { int T = 0; scanf(\"%d\", \u0026T); while(T--){ int n = 0; scanf(\"%d\", \u0026n); for(int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); memset(mr, 0, sizeof(mr)); memset(ml, 0, sizeof(ml)); mr[1] = 1; for(int i = 2; i \u003c= n; i++){ mr[i] = 1; for(int j = 1; j \u003c i; j++) if(a[j] \u003e= a[i]) mr[i] = max(mr[i], mr[j] + 1); } ml[n] = 1; for(int i = n - 1; i \u003e= 1; i--){ ml[i] = 1; for(int j = n; j \u003e i; j--) if(a[j] \u003e= a[i]) ml[i] = max(ml[i], ml[j] + 1); } int time = 0; for(int i = 1; i \u003c= n; i++) time = max(time, mr[i] + ml[i] - 1); printf(\"%d\\n\", time == n ? time : time + 1); } return 0; } E. 分组 E. 分组\n时间：1000ms 空间：256mb\n【题目描述】\n翔老师开了一门抽象代数课程，有n名同学选了这门课。现在翔老师要给这n名同学分组，两人一组，三人一组，四人一组，五人一组，六人一组等等都可以。一个组是good group的当且仅当该组人数\u003e=3人。现在翔老师想知道他要把n名同学分成若干组，最多能有多少个good group。\n【程序输入说明】\n第一行输入一个数字T(T\u003c=10)，表示数据组数。\n接下来T组数据，每组数据一行一个整数n(1\u003c=n\u003c=1000)\n对于每组数据，输出一行，表示最多能分出多少个good group。\n【输入样例】\n1\n8\n【输出样例】\n2 【提示】\n翔老师可以把四个人分成一组，另外四个人分成一组，这样一共有2个good group。\n分析 要获取最多的good group，只需要将n名同学尽量分成3人小组便可，即最后good group的数目为n / 3。\n(不要受提示的误导)\n代码 #include \u003ciostream\u003e using namespace std; int main() { int T = 0; cin \u003e\u003e T; while(T--){ int num = 0; cin \u003e\u003e num; cout \u003c\u003c num / 3 \u003c\u003c endl; } return 0; } F. Operation II F. Operation II\n时间：1000ms 空间：256mb\n【题目描述】\n现在有4个整数n,k,A,B。对于一个数字x，我们可以有以下两种操作：\n1、x=x-1\n2、x=x/k，要求x是k的倍数\n其中第一种操作花费A元，第二种操作花费B元。\n现在我们需要把数字n通过若干次的操作变成1，最少需要花多少元呢？\n【程序输入说明】\n第一行输入一个数字T(T\u003c=10)，表示数据组数。\n接下来T组数据，每组数据四个整数n,k,A,B(1\u003c=n,k,A,B\u003c=1000000000)\n【程序输出说明】\n对于每组数据，输出一行，表示最少需要花多少元。\n【输入样例】\n2\n9 2 3 1\n19 3 4 2\n5 5 2 20\n【输出样例】\n6\n12\n8\n【提示】\n对于第一组数据n=9\n首先进行第一种操作：n=n-1=8\n再进行第二种操作：n=n/k=4\n再进行第二种操作：n=n/k=2\n再进行第二种操作：n=n/k=1\n花费是3*1+1*3=6\n分析 这个题数据量比较大，传统的O(N)均会TLE，应从逐渐除k入手，考虑使用以下的O(logN)算法。\n代码 #include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e using namespace std; const int MAXN = 1000; int rem[MAXN]; long long n = 0, k = 0, A = 0, B = 0; int main() { ios :: sync_with_stdio(false); int T = 0; cin \u003e\u003e T; while(T--){ cin \u003e\u003e n \u003e\u003e k \u003e\u003e A \u003e\u003e B; memset(rem, 0, sizeof(rem)); if(k == 1) cout \u003c\u003c (n - 1) * A \u003c\u003c endl; else { int len = 0; long long money = 0; while(n \u003e 0){ rem[len++] = n % k; n /= k; } money += len * B; for(int i = 0; i \u003c= len; i++) money += rem[i] * A; for(int i = len; i \u003e= 1; i--){ long long tmp = money; tmp -= B; tmp -= rem[i] * A; tmp += k * rem[i] * A; if(tmp \u003c money){ money = tmp; rem[i - 1] += k * rem[i]; } else break; } cout \u003c\u003c money - A \u003c\u003c endl; } } return 0; } G. 演唱会 G. 演唱会\n时间：1000ms 空间：256mb\n【题目描述】\nChelly要开演唱会了，大家争先恐后地想组成应援团。一共有n个人报名参加，要从中选出6个人作为应援团，选择的这6个人要满足以下规则：一个名字首字母是C的人、一个名字首字母是H的人，一个名字首字母是E的人、两个名字首字母是L的人，一个名字首字母是Y的人(组成“CHELLY”的形状)。那么一共有多少种组团方法呢？\n每个人的名字都是不含空格的字符串，其中首字母是大写的。\n【程序输入说明】\n第一行输入一个数字T(T\u003c=10)，表示数据组数。\n接下来T组数据，每组数据第一行输入一个n(1\u003c=n\u003c=1000)表示人数。\n以下n行每行一个字符串表示每个人的名字。（每个人名字长度不超过20）\n【程序输出说明】\n对于每组数据，输出一行，表示有多少种组团方法。\n【输入样例】\n1\n8\nChristina\nUtaha\nHarada\nEmt\nLilly\nLoli\nYuuyi\nHasaki\n【输出样例】\n2 【提示】\n两种组团方法：\n{Christina,Harada,Emt,Lilly,Loli,Yuuyi}\n{Christina,Hasaki,Emt,Lilly,Loli,Yuuyi}\n分析 该题乍看像是一道单独统计字母个数的水题，而且人数上限1000看起来并不大。但本题的关注点在于：最后输出的结果是相乘而不是相减！\n我们假设这样一种情况：在给出的1000个人中，名字为五个首字母之一的人分别各占100人。这样的话结果就是(100 ^ 5) * 99 * (1 / 2)，接近10^12的数量级，超出了int的存储范围！因此long long类型又出现了。将最后输出结果的类型改为long long本题才能AC。\n代码 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; char name[30]; int main() { ios :: sync_with_stdio(false); int T = 0; cin \u003e\u003e T; while(T--){ int n = 0; cin \u003e\u003e n; unsigned long long c = 0, h = 0, e = 0, l = 0, y = 0; for(int i = 0; i \u003c n; i++){ cin \u003e\u003e name; switch(name[0]){ case 'C': c++; break; case 'H': h++; break; case 'E': e++; break; case 'L': l++; break; case 'Y': y++; break; } } cout \u003c\u003c c * h * e * (l * (l - 1) / 2) * y \u003c\u003c endl; } return 0; } ","description":"","tags":["ACM解题总结"],"title":"2018-安徽大学第十届大学生程序设计竞赛网络赛题解","uri":"/posts/2018-%E5%AE%89%E5%BE%BD%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%B1%8A%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E7%BD%91%E7%BB%9C%E8%B5%9B%E9%A2%98%E8%A7%A3/"},{"categories":["Algorithm","Basic","Thoughts"],"content":"回溯策略的基本思想 回溯策略是暴力搜索法中的一种。对于某些约束满足问题，要求给出问题全部或最优解时，尤其适合使用回溯策略。\n回溯策略的基本思想是试错法，它尝试分步地去解决一个问题。在解决问题的过程中，当回溯策略发现现有的分步答案不能给出有效的解答时，它将向上回溯，取消前一步甚至是前几步的计算结果，然后再通过其他可能的分步解答再次尝试寻找问题的答案。通俗地说，就是选定一条路往前走，直到“撞了南墙”再回头换一条别的路。\n在反复重复上述步骤后，可能产生两种情况：回溯策略找到了一个有效的解答，或者是在检查了所有的分步情况后宣告该问题在所给约束条件下无解。\n我们现在采用更为形式化的语言来描述回溯策略：我们将解决一个问题的分步过程抽象出来，将每一个可能产生的分步答案都视作一个节点，而两个分步答案之间的相互关系则用一条连接两个节点的边表示。现在我们获得了一棵树，这棵树中包含问题在给定约束条件下的全部解，我们将这棵树称作解空间树。现在我们从根节点开始搜索整棵解空间树，当算法遍历至任意一个节点时，先判断该节点是否包含了问题的解；如果不包含，则跳过对以该节点为根节点的子树的搜索，逐层向其祖先节点回溯，否则进入该子树继续依照此规则进行搜索。按照上面描述的检查这些分步答案的方法来遍历解空间树的过程称作深度优先遍历。算法正在检查的节点通常也正在产生子节点，此时该节点称作扩展节点。如果该节点的所有子节点尚未全部生成，则该节点称作活节点，否则称作死节点。深度优先遍历的过程即是扩展节点不断转移的过程。\n回溯策略产生一个或多个元组(\\(x_{1}, x_{2}, \\cdots, x_{n-1}, x_{n}\\))作为问题的解，称为解向量。问题的所有解向量构成了解空间。在对某个节点进行判断时，我们可能会涉及到两个判断条件：问题中给定的约束条件，也是对每个分量的取值限制（称作显约束）和为产生问题的有效解而在不同分量间施加的约束（称为隐约束）。\n当我们使用回溯策略解决现有问题时，应遵循以下几个步骤：\n定义解空间。 利用适于搜索的方法组织解空间（有些问题的表示方法可能有多种，采用合适的方法可以减少所需空间或是简化搜索过程）。 利用深度优先遍历解空间树。 利用约束函数和限界函数来避免移动到不可能产生解的子空间（剪枝）。 可以通过判断某个子树无法产生有效解的方式来避免对该子树的搜索，进而减少总搜索量；这一过程称作剪枝。在回溯策略中，剪枝函数分为两种：约束函数与限界函数。两者都在现有的扩展节点处进行判断。其中，约束函数减去不满足约束条件的子树，而限界函数减去不能得到最优解的子树（因此限界函数是可选的）。\n用回溯策略解决现有问题的一个显著特征是问题的解空间在搜索过程中动态生成。在任何情况下，算法只保存从根节点到当前扩展节点的路径。最坏情况下，回溯策略通常面临指数或阶乘级别的时间复杂度。\n回溯策略的基本结构 在使用回溯策略解决现有问题时，考虑到问题的实际要求不同，我们通常使用两种树形结构来构造算法：子集树和排列树。其中，子集树是指从含有n个元素的集合S中找出符合某种性质的子集所对应的解空间树，而排列树则是指确定n个元素满足某种性质的排列时所对应的解空间树。\n子集树 设集合\\(S={a_{1},a_{2},\\cdots,a_{n-1},a_{n}}\\)，且元素\\(a_{i}\\)对应状态集合\\(J_{i}={j_{1},j_{2},\\cdots,j_{k-1},j_{k}}\\)，则将第\\(i\\)层节点\\(E_{i}\\)均代表元素\\(a_{i}\\)，且每个节点均向下一层延伸出\\(|J_{i}|\\)条边的解空间树称为子集树。\n子集树实际上是从含有n个元素的集合S中选取符合某种性质的子集所构成的解空间树。\n一般地，如果元素\\(a_{i}\\)对应状态集合中元素数目之最大值为\\(K\\)，则遍历子集树的时间复杂度为\\(O(K^{N})\\)。\n遍历子集树的一般算法为：\nvoid SubsetTree (int level) { if(level \u003e n){ // 已经搜索完子集树的最底层 --STATEMENT--; } else { // 遍历该层元素的所有状态 for(int status = 1; status \u003c= k; status++){ // 数组statusList存储第level号元素的所处状态 statusList[level] = status; // 如果约束函数和限界函数给出结果为真，向下一层继续遍历 if(Constraint(level) \u0026\u0026 Bound(level)) SubsetTree(level + 1); // 当向上回溯时，将该层元素所处状态重置为0 statusList[level] = 0; } } } 下面我们将给出三个使用子集树的例子，其中前两个例子只使用约束函数进行剪枝，而最后一个例子同时用到了约束函数和限界函数。\n举例：八皇后问题 我们将用一个著名的数学问题作为介绍子集树的例子：八皇后问题。\n八皇后问题是一个以国际象棋为背景的问题：在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后，并要求任两个皇后都不能处于同一条行、列、对角线上。\n八皇后问题需要考虑皇后所在位置的四个因素：行、列、主对角线、副对角线。但我们可以先人为处理一个：将八个皇后事先就摆在不同的行上。现在我们要考虑皇后所处的列、主对角线、副对角线。\n如果我们不要求皇后处于不同的对角线上，则我们只需要枚举皇后所处的列。此时我们只需要用一个大小为8的int数组来存储某一列上是否有皇后的信息。对每一行的皇后，枚举该数组的8个元素（代表8个列），如果枚举到的某个元素为0，则置其值为1，代表该列已经放上了一个皇后；反之则继续向后枚举。保证皇后处于不同的对角线上似乎有点麻烦，因为我们没有一个很好的办法来直接对对角线进行枚举。但是如果我们考虑将8×8的棋盘中每个格填充上该格所在的行和列的和，则我们可以得到这样一张图：\n我们可以看到，图中的每条副对角线上的元素都被赋予了相同的值。这意味着我们可以用行+列的值来区分副对角线了。运用类似的方法，当我们将每个格子填充上行-列的值时，我们可以得到这样一张图：\n现在我们可以用与处理列相似的方法来处理对角线了。副对角线有15条，我们可以用一个0~14的int数组来存储副对角线的信息。主对角线也有15条，但是它的标识数中出现了负数。因此我们需要做一个变换：代表每条主对角线的下标为行-列+7。这样我们就把下标由-7~7转换成了0~14。现在主对角线可以用与副对角线相同的方式存储了。\n下面给出解决八皇后问题的C语言代码：\n#include \u003cstdio.h\u003e #define LEN 15 #define QUEEN_NUM 8 int queen[3][LEN]; // 存储八个皇后所在的列、副对角线、主对角线 int num; // 保存已经找到解的个数 void QueenSearch(int row); int main(void) { QueenSearch(0); printf(\"The number of different solutions is %d\\n\", num); return 0; } void QueenSearch(int row) { if(row == QUEEN_NUM) // 已经找到八皇后问题的一个解 num++; else { // 每行代表一个皇后，皇后可能处于的8列代表每个皇后可能处于的8种状态 for(int col = 0; col \u003c 8; col++){ // 判断是否在对应的列和对角线上都没有发现别的皇后 if( !queen[0][col] \u0026\u0026 !queen[1][row + col] \u0026\u0026 !queen[2][row - col + 7] ){ // 将皇后放置在这个位置 queen[0][col] = queen[1][row + col] = queen[2][row - col + 7] = 1; QueenSearch(row + 1); // 恢复到原有状态 queen[0][col] = queen[1][row + col] = queen[2][row - col + 7] = 0; } } } } 最终将给出八皇后问题的解是92个。\n举例：图的\\(m\\)着色问题 给定无向连通图\\(G=(V,E)\\)和m种颜色，对每个顶点用这m种颜色之一着色，且相连顶点不可着同色。求着色方案总数。\n输入数据：v, e \u003c 100, m \u003c 10, 分别代表图的顶点数目、图的边数目、图的颜色数目。之后输入e行数据，每行数据含两个整数，代表某条边连接的两个顶点。输出着色方案的总数。\n#include \u003cstdio.h\u003e #define EDGENUM 110 int graph[EDGENUM][EDGENUM]; // 邻接矩阵，存储图信息 int vertex[EDGENUM * 2]; // 存储每个顶点所着颜色 int v, e, m; // 图的顶点数、边数、颜色数 int num; // 存储方案总数 void ColorUp(int n); // 判断某个顶点是否与其相邻顶点存在同色情况 int check(int n); int main(void) { scanf(\"%d %d %d\", \u0026v, \u0026e, \u0026m); int v1 = 0, v2 = 0; for(int i = 0; i \u003c e; i++){ scanf(\"%d %d\", \u0026v1, \u0026v2); graph[v1][v2] = graph[v2][v1] = 1; } ColorUp(1); printf(\"The way of coloring the graph is %d\\n\", num); return 0; } void ColorUp(int n) { if(n \u003e v) num++; else { for(int i = 1; i \u003c= m; i++){ vertex[n] = i; if(check(n)) ColorUp(n + 1); vertex[n] = 0; } } } int check(int n) { for(int i = 1; i \u003c= v; i++){ if(i == n) continue; else { if(graph[i][n] == 1 \u0026\u0026 vertex[i] == vertex[n]) return 0; } } return 1; } 举例：最优装载问题 有\\(n\\)个集装箱要装上两艘轮船\\(s_{0},s_{1}\\)，\\(n\\)个集装箱的重量分别为\\(w_{0},w_{1},w_{2},\\cdots,w_{n-2},w_{n-1}\\)，两艘轮船的载重量则分别为\\(c_{0},c_{1}\\)，且满足\\(\\sum_{i=0}^{n-1}w_{i} \\leq c_{0}+c_{1}\\)。两艘船都被希望尽可能装满，但两艘船不能并行装载货物，只能两艘船轮流进行。请你设计一个合适的装载方案。\n既然两艘船装载货物有先后顺序，那么必定只有先装载货物的船能够尽量将自己的船装满，而第二艘船只能装载剩余的集装箱。不妨设\\(s_{0}\\)总能先到先得，即现在问题转化为：从给定的\\(n\\)个集装箱内挑选某些集装箱装在\\(s_{0}\\)上并将它尽量装满。即：选取全体集装箱集合的一个子集，使子集中集装箱的总重最接近\\(c_{0}\\)。\n我们可以很容易地给出这个问题的约束剪枝方案：如果\\(s_{0}\\)上已经装载的集装箱重量与即将装载的集装箱的重量和超过了\\(c_{0}\\)，那么这个方案就将被剪掉。但此问题的剪枝方案还可以进一步优化：本问题的解空间树是一棵二叉树，而上面的约束剪枝只剪去了这个节点的右子树（状态为被选中）。我们现在尝试对左子树（状态为未被选中）进行处理：如果\\(s_{0}\\)上现有的集装箱总重与所有尚未被装入的集装箱重量之和小于等于已知最优方案，则现有方案一定不是最优方案（或与已知最优方案重复），因此予以剪去。\n下面给出装载问题的代码：\n#include \u003cstdio.h\u003e #define CONT_MAX_NUM 1000 // 存储每个集装箱的重量，存储剩余集装箱总重 int contWeight[CONT_MAX_NUM], allContNum; // 存储目前s0上的放置方案，存储目前s0上集装箱总重， // 存储目前s0上集装箱数目 int nowPlan[CONT_MAX_NUM], nowWeight, nowContNum; // 存储目前最优方案，存储目前最优方案中s0上集装箱总重， // 存储目前最优方案中s0上集装箱数目 int bestPlan[CONT_MAX_NUM], bestWeight, bestContNum; int c0, c1, n; void ContainerLoading(int index); int main(void) { printf(\"Please enter the value of c0, c1, and n.\\n\"); scanf(\"%d %d %d\", \u0026c0, \u0026c1, \u0026n); printf(\"Please enter the weight of each container \" \"(separated by space): \\n\"); for(int i = 0; i \u003c n; i++){ scanf(\"%d\", \u0026contWeight[i]); allContNum += contWeight[i]; } ContainerLoading(0); printf(\"The best plan is: \\n\"); printf(\"Load the container(s) with weight \"); for(int i = 0; i \u003c bestContNum; i++) printf(\"%d \", contWeight[bestPlan[i]]); printf(\"on ship s0.\\n\"); printf(\"The rest part will be loaded on ship s1.\\n\"); return 0; } void ContainerLoading(int index) { if(index == n){ if(nowWeight \u003e bestWeight){ for(int i = 0; i \u003c nowContNum; i++) bestPlan[i] = nowPlan[i]; bestWeight = nowWeight; bestContNum = nowContNum; } } else { // 取出第index个集装箱 allContNum -= contWeight[index]; // 判断该集装箱能否装上s0 if(nowWeight + contWeight[index] \u003c= c0){ nowPlan[nowContNum++] = index; nowWeight += contWeight[index]; ContainerLoading(index + 1); nowPlan[--nowContNum] = 0; nowWeight -= contWeight[index]; } // 将该集装箱装上s1，同时判断目前方案能否产生比当前更优方案 if(nowWeight + allContNum \u003e bestWeight) ContainerLoading(index + 1); allContNum += contWeight[index]; } } 排列树 设集合\\(U={a_{1},a_{2},\\cdots,a_{n-1},a_{n}}\\)，则从一个代表\\(U\\)的根节点发出，除根节点外的每个节点代表\\(U\\)的一个子集\\(N\\)，且从每个节点向下一层延伸出的每条边都代表\\(U-N\\)中的一个元素，这样的解空间树称为排列树。\n排列树实际上是选取含有n个元素的集合S符合某种性质的排列。\n一般地，遍历排列树的时间复杂度为O(N!)。\n遍历排列树的一般算法为：\nvoid PermutationTree (int level) { if(level \u003e n){ // 已经搜索完排列树的最底层 --STATEMENTS--; } else { // 枚举可能与第level个元素交换位置的所有元素 //初始条件不要改为level + 1，会导致最后一个level无法进入循环 for(int status = level; status \u003c= n; status++){ swap(list[status], list[level]); if(Constraint(t) \u0026\u0026 Bound(t)) PermutationTree(level + 1); // 恢复原有状态 swap(list[status], list[level]); } } } 由此可见排列树是子集树的衍生产物，且已经经过剪枝（循环从index而不是从1开始）。\n下面将给出2个使用排列树的例子。\n举例：求1~N的全排列 #include \u003cstdio.h\u003e #define LEN 1000 int numList[LEN]; // 存放1~N的某个排列 int N, perNum; // 存放N和已知的不同排列数目 void permulation(int index); // 打印1~N的某个排列 void printPer(void); void swap(int *num1, int *num2); int main(void) { scanf(\"%d\", \u0026N); for(int i = 1; i \u003c= N; i++) numList[i] = i; permulation(1); printf(\"The number of all permulations is %d.\\n\", perNum); return 0; } void permulation(int index) { if(index \u003e N){ printPer(); perNum++; } else { for(int i = index; i \u003c= N; i++){ swap(\u0026numList[i], \u0026numList[index]); permulation(index + 1); swap(\u0026numList[i], \u0026numList[index]); } } } void printPer(void) { for(int i = 1; i \u003c= N; i++) printf(i == N ? \"%d\\n\" : \"%d \", numList[i]); } void swap(int *num1, int *num2) { int tmp = *num1; *num1 = *num2; *num2 = tmp; } 举例：批处理作业调度问题 给定作业集合\\(J_{n},n=1,2,\\cdots,n-1,n\\)，每项作业需要先后经机器0和机器1处理，第i项作业在机器j上的处理时间记作\\(t_{ji}\\)。你可以任意安排处理作业的调度顺序。试分别给出两个安排方案，解决以下两个需求：\n给出一个作业安排方案使得处理完所有作业的耗时最小。 令\\(F_{ji}\\)为从0时刻开始到作业\\(i\\)在机器\\(j\\)上处理完毕后的总时间。给出一个作业安排方案使得\\(F_{21}+F_{22}+\\cdots+F_{2(n-1)}+F_{2n}\\)最小。 样例输入 3 2 1 3 1 2 3 样例输出 (1) The best permulation of works is: 1 3 2 Which costs 8 time unit(s) in total. (2) The best permulation of works is: 1 3 2 Which costs 18 time unit(s) in total.\n我们考虑样例：样例给出了三个作业，在机器0和机器1上的耗时分别为{2, 3, 2}和{1, 1, 3}。我们以实际输出的最优调度来说明两台机器的工作方式：\n下面给出批处理调度问题的C语言代码：\n需求1：\n#include \u003cstdio.h\u003e #define LEN 1000 // 作业总数，每项作业需要的机器0和机器1的处理时间 int workNum, time[2][LEN]; // 作业的某个调度方案 int workList[LEN]; // 机器0安排的作业顺序 int m0List[LEN]; // 机器1安排的作业顺序 int m1List[LEN]; int bestList[LEN], bestAllTime = 999999; void swap(int *a, int *b); int max(int *a, int *b); void BatchJob(int index); int main(void) { printf(\"Please enter the number of works. \\n\"); scanf(\"%d\", \u0026workNum); for(int i = 1; i \u003c= workNum; i++) workList[i] = i; printf(\"Please enter time which each work costs\" \"(time needed by two machines separated by space). \\n\"); for(int i = 1; i \u003c= workNum; i++) scanf(\"%d %d\", \u0026time[0][i], \u0026time[1][i]); BatchJob(1); printf(\"The best permulation of works is: \\n\"); for(int i = 1; i \u003c= workNum; i++) printf(workNum == i ? \"%d\\n\" :\"%d \", bestList[i]); printf(\"Which costs %d time unit(s) in total. \\n\", bestAllTime); return 0; } inline void swap(int *a, int *b) { int tmp = *a; *a = *b; *b = tmp; } inline int max(int *a, int *b) { return *a \u003e *b ? *a : *b; } void BatchJob(int index) { if(index \u003e workNum){ if(m1List[index - 1] \u003c bestAllTime){ for(int i = 1; i \u003c= workNum; i++) bestList[i] = workList[i]; bestAllTime = m1List[index - 1]; } } else { for(int i = index; i \u003c= workNum; i++){ swap(\u0026workList[index], \u0026workList[i]); m0List[index] = m0List[index - 1] + time[0][workList[index]]; // 结合实际过程理解此处的max m1List[index] = max(\u0026m0List[index], \u0026m1List[index - 1]) + time[1][workList[index]]; if(m1List[index] \u003c bestAllTime) BatchJob(index + 1); swap(\u0026workList[index], \u0026workList[i]); m0List[index] = 0; m1List[index] = 0; } } } 需求2：\n#include \u003cstdio.h\u003e #define LEN 1000 // 作业总数，每项作业需要的机器0和机器1的处理时间 int workNum, time[2][LEN]; // 作业的某个调度方案 int workList[LEN]; // 机器0安排的作业顺序 int m0List[LEN]; // 机器1安排的作业顺序及当前的所有F_{2i}之和 int m1List[LEN], m1AllTime; int bestList[LEN], bestAllTime = 999999; void swap(int *a, int *b); int max(int *a, int *b); void BatchJob(int index); int main(void) { printf(\"Please enter the number of works. \\n\"); scanf(\"%d\", \u0026workNum); for(int i = 1; i \u003c= workNum; i++) workList[i] = i; printf(\"Please enter time which each work costs\" \"(time needed by two machines separated by space). \\n\"); for(int i = 1; i \u003c= workNum; i++) scanf(\"%d %d\", \u0026time[0][i], \u0026time[1][i]); BatchJob(0); printf(\"The best permulation of works is: \\n\"); for(int i = 1; i \u003c= workNum; i++) printf(workNum == i ? \"%d\\n\" :\"%d \", bestList[i]); printf(\"Which costs %d time unit(s) in total. \\n\", bestAllTime); return 0; } inline void swap(int *a, int *b) { int tmp = *a; *a = *b; *b = tmp; } inline int max(int *a, int *b) { return *a \u003e *b ? *a : *b; } void BatchJob(int index) { if(index \u003e workNum){ if(m1AllTime \u003c bestAllTime){ for(int i = 1; i \u003c= workNum; i++) bestList[i] = workList[i]; bestAllTime = m1AllTime; } } else { for(int i = index; i \u003c= workNum; i++){ swap(\u0026workList[index], \u0026workList[i]); m0List[index] = m0List[index - 1] + time[0][workList[index]]; m1List[index] = max(\u0026m0List[index], \u0026m1List[index - 1]) + time[1][workList[index]]; m1AllTime += m1List[index]; if(m1AllTime \u003c bestAllTime) BatchJob(index + 1); swap(\u0026workList[index], \u0026workList[i]); m0List[index] = 0; m1AllTime -= m1List[index]; m1List[index] = 0; } } } ","description":"","tags":["ACM报告"],"title":"基本算法(3)：回溯策略","uri":"/posts/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%953%E5%9B%9E%E6%BA%AF%E7%AD%96%E7%95%A5/"},{"categories":["Programming Contest","ACM","HDU"],"content":"题目 Problem Description\nGiven a sequence a[1],a[2],a[3]……a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14.\nInput\nThe first line of the input contains an integer T(1\u003c=T\u003c=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1\u003c=N\u003c=100000), then N integers followed(all the integers are between -1000 and 1000).\nOutput\nFor each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases.\nSample Input\n2\n5 6 -1 5 4 -7\n7 0 6 -1 1 -6 7 -5\nSample Output\nCase 1:\n14 1 4\nCase 2:\n7 1 6\n题目大意即是：给定一个序列\\(a_{1},a_{2},a_{3},\\cdots,a_{n}\\)，对\\(i,j\\in [1,\\cdots,n]\\)，求\\(\\sum_{k = i}^{j} a_{k}\\)的最大值，并给出\\(i\\)和\\(j\\)的值。\n题解 通过对本题逐渐深入的分析，下面我们将给出三个时间复杂度逐渐降低的算法。\n朴素算法：时间复杂度O(N ^ 3) 我们先忽略时间复杂度的要求而只考虑算法的正确性。由题意，我们所求的对象是题中给出序列的某个连续子序列，也即我们只需要枚举序列元素的下标i和j，求出\\(a_{i}\\)到\\(a_{j}\\)间所有元素的和，再同当前最大值进行比较即可得出正确答案。\n#include \u003cstdio.h\u003e #define LEN 100010 #define MAXNUM 1001 int array[LEN]; int main(void){ int T = 0; scanf(\"%d\", \u0026T); for(int kase = 1; kase \u003c= T; kase++){ int n = 0; scanf(\"%d\", \u0026n); for(int i = 0; i \u003c n; i++) scanf(\"%d\", \u0026array[i]); int maxSum = -MAXNUM, start = 0, end = 0; for(int i = 0; i \u003c n; i++) for(int j = i; j \u003c n; j++){ int thisSum = 0; for(int k = i; k \u003c= j; k++) thisSum += array[k]; if(thisSum \u003e maxSum){ maxSum = thisSum; start = i; end = j; } } printf(\"Case %d:\\n\", kase); printf(\"%d %d %d\\n\", maxSum, start + 1, end + 1); printf(kase == T ? \"\" : \"\\n\"); } return 0; } 进阶算法：时间复杂度O(N ^ 2) 上一个算法的时间复杂度为O(N ^ 3)，虽然算法是正确的，但显然还需要进一步优化才能够提交。我们先从最清晰的方向入手：减少嵌套for循环的数目。\n经过稍加思索就可以发现第一个算法的主要缺点：累加子序列和的过程与枚举\\(i\\)和\\(j\\)的过程是分离的，用了一个单独的for循环来进行处理。这个问题可以被很轻易地解决：学习选择排序的思路，在枚举\\(j\\)的过程中一同累加子序列和并进行判断。\n#include \u003cstdio.h\u003e #define LEN 100010 #define MAXNUM 1001 int array[LEN]; int main(void){ int T = 0; scanf(\"%d\", \u0026T); for(int kase = 1; kase \u003c= T; kase++){ int n = 0; scanf(\"%d\", \u0026n); for(int i = 0; i \u003c n; i++) scanf(\"%d\", \u0026array[i]); int maxSum = -MAXNUM, start = 0, end = 0; for(int i = 0; i \u003c n; i++){ int thisSum = 0; for(int j = i; j \u003c n; j++){ thisSum += array[j]; if(thisSum \u003e maxSum){ maxSum = thisSum; start = i; end = j; } } } printf(\"Case %d:\\n\", kase); printf(\"%d %d %d\\n\", maxSum, start + 1, end + 1); printf(kase == T ? \"\" : \"\\n\"); } return 0; } 最终算法：时间复杂度O(N) 还能不能再进一步优化？我们仍然从减少嵌套for循环的数目入手。我们想将核心循环部分减少至只需要一个for循环。这就要求我们不能再接着采用枚举i和j的思路，而是需要随着数据的读入实时判断。\n我们来考察一个特殊的序列：3, 5, 6, -5, -1, -5, -4, 2, 5, 6。这个序列有10个元素。我们来模拟逐个读入该序列中元素并实时判断的过程：\n读入第1个元素：3。此时maxSum = thisSum = 3, start = end = 1。\n读入第2个元素：5。此时maxSum = thisSum = 8, start = 1, end = 2。\n读入第3个元素：6。此时maxSum = thisSum = 14, start = 1, end = 3。\n这一阶段maxSum和thisSum一直是同步增长的。\n读入第4个元素：-5。此时maxSum = 14, thisSum = 9，start = 1, end = 3。\n此时，thisSum已经小于maxSum, 但是我们还不能认为我们所寻找的最大连续子序列就在此处结束：下一个元素可能是6，这样又会使thisSum \u003e maxSum而更新最大连续子序列的范围。我们继续模拟过程：\n读入第5个元素：-1。此时maxSum = 14, thisSum = 8, start = 1, end = 3。\n读入第6个元素：-5。此时maxSum = 14, thisSum = 3, start = 1, end = 3。\n读入第7个元素：-4。此时maxSum = 14, thisSum = -1, start = 1, end = 3。\n此时thisSum \u003c 0。第一个连续子序列的查找过程停止了。也就是说，现在我们已经能够确定：现阶段找到的最大连续子序列是第1~3个元素，和为14。继续读入接下来的元素将开始第二个连续子序列的查找。\n为什么第一个连续子序列的查找在thisSum \u003c 0时停止? 容易知道，thisSum现在是前7个元素构成的连续子序列的和，我们记为S1。我们又把后3个元素构成的连续子序列的和记作S2。因为S1 \u003c 0，这就将导致S1 + S2 \u003c S2。也就是说，此时S2一定比加上了前7个元素的序列全体元素之和要大，所以第8个元素之后的查找也就与前7个元素构成的连续子序列无关了。\n这一现象阐述了下述的重要事实：最大连续子序列不可能以一个和为负数的连续子序列作为前缀。\n我们继续模拟过程：\n读入第8个元素：2. 此时maxSum = 14, thisSum = 2, start = 8, end = 8.\n读入第9个元素：5. 此时maxSum = 14, thisSum = 7, start = 8, end = 9.\n读入第10个元素：6. 此时maxSum = 14, thisSum = 13, start = 8, end = 10.\n数据读入到此结束。因为thisSum \u003c maxSum，所以该序列中的最大连续子序列是第1~3个元素，和为14。\n根据以上过程，我们可以写出最终优化后的算法：\n#include \u003cstdio.h\u003e #define MAXNUM -1001 int main(void){ int T = 0; scanf(\"%d\", \u0026T); for(int kase = 1; kase \u003c= T; kase++){ int n = 0; scanf(\"%d\", \u0026n); int thisSum = 0, maxSum = MAXNUM; int start = 1, end = 1, startPosition = 1; for(int i = 1; i \u003c= n; i++){ int num = 0; scanf(\"%d\", \u0026num); thisSum += num; if(thisSum \u003e maxSum){ maxSum = thisSum; start = startPosition; end = i; } if(thisSum \u003c 0){ thisSum = 0; // 重置thisSum以开始下一个连续子序列的查找 startPosition = i + 1; // 存储下一个连续子序列的开始位置 } } printf(\"Case %d:\\n\", kase); printf(\"%d %d %d\\n\", maxSum, start, end); printf(kase == T ? \"\" : \"\\n\"); } return 0; } 这个算法中有两点值得注意的地方：\n!\u003e MAXNUM的值很重要。只有大于MAXNUM的值会在判断过程中参与判断。因为maxSum在算法运行过程中只会更大而不会更小，从而若序列中有小于MAXNUM的元素，则该元素根本无法进入判断流程。当MAXNUM的值被设为0时问题会尤为显著：一切负数元素都会被忽略，则若序列如同-1, -2, -3, -4, -3, -5一般全由负数元素构成，则算法最后会给出最大子序列和为0。\nx\u003e startPosition变量的作用。为什么不能这样改写程序：\nif(thisSum \u003e maxSum){ maxSum = thisSum; end = i; } if(thisSum \u003c 0){ thisSum = 0; start = i + 1; } 我们仍以之前举例使用的序列作为例子：3, 5, 6, -5, -1, -5, -4, 2, 5, 6。当算法运行到第7个元素时，thisSum \u003c 0成立，从而start被修改为8。但是因为第8~10个元素并没有成为更大的连续子序列，因此end的值仍是3，这样造成算法的输出中start \u003e end。关键在于start不应该随着算法运行到一个新序列的开始而立即改变值，而是应当在确定找到了新的最大连续子序列后再改变值。\n","description":"","tags":["ACM题解"],"title":"HDU.1003 Max Sum","uri":"/posts/hdu.1003_max_sum/"},{"categories":["Algorithm","Basic","Thoughts"],"content":"枚举策略的基本思想 在问题所有可能解之集合中一一枚举所有可能元素。 以问题所给检验条件判断每个元素的状态（符合或不符合检验条件），符合条件的元素构成问题的解集。 枚举策略的条件 可判断状态的元素之数目为有限个。 可判断状态的元素可构成一序列集。（即，可依据某一要素（如序列下标），对这些元素进行遍历） 这两点条件也使得枚举策略虽然本质上属于搜索策略，但与同属于搜索策略的回溯策略相异。\n枚举策略的框架结构 设在问题的搜索空间中有a1, a2, a3, … ,ak共k个变量，对i ∈ [1…k]有ai_min \u003c= ai \u003c= ai_max，则可依照以下方式对这k个变量进行枚举：\nfor(int a1 = a1_min; a1 \u003c= a1_max; a1++) for(int a2 = a2_min; a2 \u003c= a2_max; a2++) for(int a3 = a3_min; a3 \u003c= a3_max; a3++) ... for(int ak = ak_min; ak \u003c= ak_max; ak++){ STATEMENTS; } 举例 砝码称重 【问题描述】设有1g、2g、3g、5g、10g、20g的砝码各若干枚（其总重\u003c=1000），求用这些砝码能称出不同的重量个数。\n【文件输入】输入1g、2g、3g、5g、10g、20g的砝码个数。\n【文件输出】输出能称出不同重量的个数。\n【样例输入】1 1 0 0 0 0\n【样例输出】3\n分析 由题意，该题目中只有有限种重量的砝码（符合条件1），且每种砝码的数量最大值都确定，且取值范围是连续的，可由0逐个取到最大值（符合条件2），因此只需对6种砝码逐个从0到数目最大值进行枚举。确定可称出的不同数量时，因题目所涉及数据量不大（砝码的总重最多是1000）可采用类似基数排序的思想，来避免每获得一个重量就要对所有重量遍历查找一次的情况。\n代码 #include \u003cstdio.h\u003e #define LEN 1010 int r[LEN]; int w[6] = {1, 2, 3, 5, 10, 20}; int main(void){ int a, b, c, d, e, f; //6种砝码的个数 int num = 0; while(scanf(\"%d %d %d %d %d %d\", \u0026a, \u0026b, \u0026c, \u0026d, \u0026e, \u0026f) != EOF){ for(int a0 = 0; a0 \u003c= a; a0++) for(int a1 = 0; a1 \u003c= b; a1++) for(int a2 = 0; a2 \u003c= c; a2++) for(int a3 = 0; a3 \u003c= d; a3++) for(int a4 = 0; a4 \u003c= e; a4++) for(int a5 = 0; a5 \u003c= f; a5++) r[ a0 * w[0] + a1 * w[1] + a2 * w[2] + a3 * w[3] + a4 * w[4] + a5 * w[5] ] = 1; for(int i = 0; i \u003c LEN; i++) if(r[i] == 1) num++; printf(\"%d\\n\", num - 1); // 减去砝码总重为0的情况 } return 0; } 枚举策略的优化 枚举策略的优缺点 枚举策略的优点:\n代码直观，易于理解 算法的正确性易于证明 某些时候在算法局部应用该策略效果很好 枚举策略的缺点:\n枚举策略的开销直接取决于状态元素之个数及单个状态枚举之开销。\n而枚举策略的缺点也直接导致枚举策略的效率通常很低。因为上述两处开销对于枚举策略的总开销影响过大。例如，假设对k个状态元素应用枚举策略，则此处枚举策略的时间复杂度就至少是O(N ^ k)。而如果在判断每一个状态元素是否符合条件时开销都较大（例如，需要遍历某个数组），则即使状态元素较少，也会导致算法总的时间复杂度较高。据此，我们应避免直接“翻译”题意来使用枚举策略的情况，使用时应对枚举策略做出适当优化，可以有效降低算法开销。\n优化准则 保证每个状态元素均是独立变量。 尽量缩小每个状态元素的取值范围。 采用合适的搜索顺序来逐步缩小搜索空间。 例：百钱买百鸡问题 【问题描述】有一个人有一百块钱，打算买一百只鸡。到市场一看，公鸡一只3元,母鸡一只5元,小鸡3只1元,试求用100元买100只鸡,各为多少才合适?\n设公鸡，母鸡，小鸡个数分别为\\(x\\), \\(y\\), \\(z\\)，则可列出方程组$3x+5y+\\frac{z}{3}=100 x+y+z=100$\n据此可初步写出程序对\\(x\\), \\(y\\), \\(z\\)进行枚举：\n#include \u003cstdio.h\u003e int main(void){ for(int x = 0; x \u003c= 100; x++) for(int y = 0; y \u003c= 100; y++) for(int z = 0; z \u003c= 100; z += 3) if(3 * x + 5 * y + z / 3 == 100 \u0026\u0026 x + y + z == 100) printf(\"%d %d %d\\n\", x, y, z); return 0; } 这个程序的复杂度是O(N ^ 3)。接下来我们可以从两个角度优化程序：\n首先，我们需要减少状态变量的个数。通过第二个方程，我们可以得到\\(z=100-x-y\\)。这说明\\(z\\)不是独立变量。再将此方程代入第一个方程，可得\\(4x+7y=100\\)，这说明y也可以用x表示，即此题中只有一个独立变量x。接下来，我们缩小状态元素的取值范围。由方程\\(4x+7y=100\\)可以看出\\(x\\)的取值范围是0到25，这远小于上一份代码中的0到100。由此，我们可写出经过优化的程序：\n#include \u003cstdio.h\u003e int main(void){ for(int x = 0; x \u003c= 25; x++){ int y = 100 - 4 * x; if(y \u003e= 0 \u0026\u0026 y % 7 == 0){ y /= 7; int z = 100 - x - y; printf(\"%d %d %d\\n\", x, y, z); } } return 0; } 此时，程序的复杂度为O(N)。这个程序甚至省去了代入方程组（中的任一个方程）判断的过程，因为经由上述分析已经知道了\\(x\\), \\(y\\), \\(z\\)为整数的判断条件，从而只要\\(y\\)为整数，就可获得方程组的一组整数解（因\\(x\\)必为整数，\\(z\\)由\\(x\\)和\\(y\\)唯一确定）。\n例：POJ.1006 Biorhythms Description\nSome people believe that there are three cycles in a person’s life that start the day he or she is born. These three cycles are the physical, emotional, and intellectual cycles, and they have periods of lengths 23, 28, and 33 days, respectively. There is one peak in each period of a cycle. At the peak of a cycle, a person performs at his or her best in the corresponding field (physical, emotional or mental). For example, if it is the mental curve, thought processes will be sharper and concentration will be easier.\nSince the three cycles have different periods, the peaks of the three cycles generally occur at different times. We would like to determine when a triple peak occurs (the peaks of all three cycles occur in the same day) for any person. For each cycle, you will be given the number of days from the beginning of the current year at which one of its peaks (not necessarily the first) occurs. You will also be given a date expressed as the number of days from the beginning of the current year. You task is to determine the number of days from the given date to the next triple peak. The given date is not counted. For example, if the given date is 10 and the next triple peak occurs on day 12, the answer is 2, not 3. If a triple peak occurs on the given date, you should give the number of days to the next occurrence of a triple peak.\nInput\nYou will be given a number of cases. The input for each case consists of one line of four integers p, e, i, and d. The values p, e, and i are the number of days from the beginning of the current year at which the physical, emotional, and intellectual cycles peak, respectively. The value d is the given date and may be smaller than any of p, e, or i. All values are non-negative and at most 365, and you may assume that a triple peak will occur within 21252 days of the given date. The end of input is indicated by a line in which p = e = i = d = -1.\nOutput\nFor each test case, print the case number followed by a message indicating the number of days to the next triple peak, in the form:\nCase 1: the next triple peak occurs in 1234 days.\nUse the plural form ``days’’ even if the answer is 1.\nSample Input\n0 0 0 0\n0 0 0 100\n5 20 34 325\n4 5 6 7\n283 102 23 320\n203 301 203 40\n-1 -1 -1 -1\nSample Output\nCase 1: the next triple peak occurs in 21252 days.\nCase 2: the next triple peak occurs in 21152 days.\nCase 3: the next triple peak occurs in 19575 days.\nCase 4: the next triple peak occurs in 16994 days.\nCase 5: the next triple peak occurs in 8910 days.\nCase 6: the next triple peak occurs in 10789 days.\n问题的大意即是:\n人生来就有三个生理周期，分别为体力、感情和智力周期，它们的周期长度为23天、28天和33天。每一个周期中有一天是高峰。在高峰这天，人会在相应的方面表现出色。例如，智力周期的高峰，人会思维敏捷，精力容易高度集中。因为三个周期的周长不同，所以通常三个周期的高峰不会落在同一天。对于每个人，我们想知道何时三个高峰落在同一天。对于每个周期，我们会给出从当前年份的第一天开始，到出现高峰的天数（不一定是第一次高峰出现的时间）。你的任务是给定一个从当年第一天开始数的天数，输出从给定时间开始（不包括给定时间）下一次三个高峰落在同一天的时间（距给定时间的天数）。例如：给定时间为10，下次出现三个高峰同天的时间是12，则输出2（注意这里不是3）。\nInput\n输入四个整数：p, e, i和d。 p, e, i分别表示体力、情感和智力高峰出现的时间（时间从当年的第一天开始计算）。d 是给定的时间，可能小于p, e, 或 i。 所有给定时间是非负的并且小于365, 所求的时间小于21252。 当p = e = i = d = -1时，输入数据结束。\nOutput\n从给定时间起，下一次三个高峰同天的时间（距离给定时间的天数）。\n我们可以先初步写出未经优化的代码：\n#include \u003cstdio.h\u003e int main(void){ int p = 0, e = 0, i = 0, d = 0; int kase = 1; while(scanf(\"%d %d %d %d\", \u0026p, \u0026e, \u0026i, \u0026d) != EOF){ if(p == -1 \u0026\u0026 e == -1 \u0026\u0026 i == -1 \u0026\u0026 d == -1) break; for(int x = d + 1; x \u003c= 21252; x++) if( (x - p) % 23 == 0 \u0026\u0026 (x - e) % 28 == 0 \u0026\u0026 (x - i) % 33 == 0) printf(\"Case %d: the next triple peak occurs in %d days.\\n\", kase++, x - d); } return 0; } 这个程序的搜索空间较大（从不大于365到21252），我们应想办法缩小其搜索空间。考虑到题目中有三个条件需要判断，我们可以用类似于百钱买白鸡题的策略，对三个条件逐个判断来缩小搜索空间。\n下面给出优化后的代码：\n#include \u003cstdio.h\u003e int main(void){ int p = 0, e = 0, i = 0, d = 0; int kase = 0; while(scanf(\"%d %d %d %d\", \u0026p, \u0026e, \u0026i, \u0026d) != EOF){ if(p == -1 \u0026\u0026 e == -1 \u0026\u0026 i == -1 \u0026\u0026 d == -1) break; int x = 0; for(x = d + 1; x \u003c= 21252; x++) if((x - p) % 23 == 0) break; for( ; x \u003c= 21252; x += 23) if((x - e) % 28 == 0) break; for( ; x \u003c= 21252; x += 23 * 28) if((x - i) % 33 == 0) break; printf(\"Case %d: the next triple peak occurs in %d days.\\n\", ++kase, x - d); } return 0; } 可以看到调整搜索顺序使得程序的搜索空间显著减小，而程序的效率也显著提升。\nCODEVS.1168 火柴棒等式 (2008年NOIP全国联赛提高组) 题目描述 Description\n给你n根火柴棍，你可以拼出多少个形如“A+B=C”的等式？等式中的A、B、C是用火柴棍拼出的整数（若该数非零，则最高位不能是0）。用火柴棍拼数字0-9的拼法如图所示：\n注意：\n加号与等号各自需要两根火柴棍 如果A≠B，则A+B=C与B+A=C视为不同的等式（A、B、C\u003e=0） n根火柴棍必须全部用上 输入描述 Input Description\n输入文件共一行，有一个整数n（n\u003c=24）。\n输出描述 Output Description\n输出文件共一行，表示能拼成的不同等式的数目。\n样例输入 Sample Input\n样例1：\n14\n样例2：\n18\n样例输出 Sample Output\n样例1： 2\n样例2： 9\n数据范围及提示 Data Size \u0026 Hint\n【输入输出样例1解释】\n2个等式为0+1=1和1+0=1。\n【输入输出样例2解释】\n9个等式为:\n0+4=4\n0+11=11\n1+10=11\n2+2=4\n2+7=9\n4+0=4\n7+2=9\n10+1=11\n11+0=11\n我们先来计算状态元素的取值范围。由题意，本题中最多有24根火柴，除去4根作为运算符后，还可有20根火柴用来摆A, B, C。考虑A和B的取值范围：A和B的最小值显然为0。又，当A或B达到最大值时，其应具有最多的数字位数，而0~9所需的火柴棒数目分别为6, 2, 5, 5, 4, 5, 6, 3, 7, 6, 其中数字1所用的火柴棒数目最少。则假设B = 1，此时可用18根火柴用来摆A和C。又由B \u003e 0知C \u003e A，故A \u003c 9，即A最多为8，恰好可摆出1111，由对称性，这也是B可摆出的位数最多的数字，即1111是A和B的最大值。则C的最大值的上界是2222。\n又，考虑到每一个火柴棍表达式中数字的火柴棍个数计算开销是O(N)，当输入数据组数很多时会严重影响效率，故可以在读入数据之前预先计算0~2222所需的火柴棍个数。\n下面给出代码：\n#include \u003cstdio.h\u003e #define LEN 2223 // 存放从0到2222所需的火柴棍个数 int num[LEN] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6}; // 计算自然数n所需的火柴棍数目 int matchNum(int n){ int perNum = 0; if(n == 0) return 6; while(n \u003e 0){ perNum += num[n % 10]; n /= 10; } return perNum; } int main(void){ // 预处理 for(int i = 10; i \u003c LEN; i++) num[i] = matchNum(i); int n = 0; while(scanf(\"%d\", \u0026n) != EOF){ int kase = 0; for(int i = 0; i \u003c= 1111; i++) for(int j = 0; j \u003c= 1111; j++){ int a = num[i], b = num[j], c = n - 4 - a - b, d = num[i + j]; if(c == d) ++kase; } printf(\"%d\\n\", kase); } return 0; } 数字之和 【题目描述】 给你n(n\u003c=105)个整数，然后要有m(m\u003c=105)个询问。每个询问给出两个整数i和j，问第i个数字到第j个数字所有数字之和。\n下面给出未经优化的代码：\n#include \u003cstdio.h\u003e #define LEN 110 int ar[LEN]; int main(void){ int n = 0, m = 0; scanf(\"%d %d\", \u0026n, \u0026m); for(int x = 0; x \u003c n; x++) scanf(\"%d\", \u0026ar[x]); for(int x = 0; x \u003c m; x++){ int i = 0, j = 0, sum = 0; scanf(\"%d %d\", \u0026i, \u0026j); for(int k = i; k \u003c= j; k++) sum += ar[k - 1]; printf(\"%d\\n\", sum); } return 0; } 对于每个询问，计算第i个到第j个数字之和的开销都是O(N)。在询问数目较多时，这一开销十分巨大。为此，我们可以在将n个数字均读入到ar[]中后，对i ∈ [0…n)使ar[i] += ar[i - 1], 这样数组元素ar[i]中存储的就是第1个数到第i + 1个数之和，从而第i个数到第j个数之和就是ar[j - 1] - ar[i - 1]。\n优化后的代码如下：\n#include \u003cstdio.h\u003e #define LEN 110 int ar[LEN]; int main(void){ int n = 0, m = 0; scanf(\"%d %d\", \u0026n, \u0026m); for(int x = 0; x \u003c n; x++){ scanf(\"%d\", \u0026ar[x]); ar[x] += ar[x - 1]; } for(int x = 0; x \u003c m; x++){ int i = 0, j = 0; scanf(\"%d %d\", \u0026i, \u0026j); printf(\"%d\\n\", ar[j - 1] - ar[i - 1]); } return 0; } 最大子矩阵和问题 * 【问题描述】 给定一个二维正方形矩阵（含正数或负数，规模为n ^ 2, n \u003c= 1000），请从中找出最大的子矩阵之和。例如：\n我们先给出最直观的算法：枚举子矩阵左上角的点(x1, y1)和右下角的点(x2, y2)。\n#include \u003cstdio.h\u003e #include \u003climits.h\u003e #define NMAX 1010 int matrix[NMAX][NMAX]; int main(void){ int n = 0, maxSum = -INT_MAX; scanf(\"%d\", \u0026n); for(int i = 0; i \u003c n; i++) for(int j = 0; j \u003c n; j++) scanf(\"%d\", \u0026matrix[i][j]); for(int x1 = 0; x1 \u003c n; x1++) for(int y1 = 0; y1 \u003c n; y1++) for(int x2 = 0; x2 \u003c n; x2++) for(int y2 = 0; y2 \u003c n; y2++){ int sum = 0; for(int i = x1; i \u003c= x2; i++) for(int j = y1; j \u003c= y2; j++) sum += matrix[i][j]; if(sum \u003e maxSum) maxSum = sum; } printf(\"%d\\n\", maxSum); return 0; } 直观算法的复杂度是O(N ^ 6)。我们可以参照上一题的思路对程序进行优化：令matrix[x][y]为从(0, 0)到(x, y)的和。这样(x1, y1)和(x2, y2)之间的和就是matrix[x2][y2] - matrix[x2][y1] - matrix[x1][y2] + matrix[x1][y1]。\n下面给出优化之后的代码：\n#include \u003cstdio.h\u003e #include \u003climits.h\u003e #define NMAX 1010 int matrix[NMAX][NMAX]; int main(void){ int n = 0, maxSum = -INT_MAX; scanf(\"%d\", \u0026n); for(int i = 0; i \u003c n; i++) for(int j = 0; j \u003c n; j++){ scanf(\"%d\", \u0026matrix[i][j]); matrix[i][j] = matrix[i][j] + matrix[i - 1][j] + matrix[i][j - 1] - matrix[i - 1][j - 1]; } for(int x1 = 0; x1 \u003c n; x1++) for(int y1 = 0; y1 \u003c n; y1++) for(int x2 = 0; x2 \u003c n; x2++) for(int y2 = 0; y2 \u003c n; y2++){ int sum = matrix[x2][y2] - matrix[x2][y1] - matrix[x1][y2] + matrix[x1][y1]; if(sum \u003e maxSum) maxSum = sum; } printf(\"%d\\n\", maxSum); return 0; } 优化之后的算法复杂度降到了O(N ^ 4)。但我们还想再进一步优化。由刚刚的经验，最大子矩阵和问题是最大子序列和问题的一个扩展，因此我们可以用解决最大子序列和问题的方法来解决最大子矩阵和问题。\n同时，我们观察到这样的事实：最大子矩阵和问题计算的是一列列的数累加获得的最大值。这就给了我们存储矩阵的另一个思路: $$\\begin{bmatrix} a_{11} \u0026 a_{12} \u0026 a_{13} \u0026 \\cdots \u0026 a_{1k}\\\\ a_{11} + a_{21} \u0026 a_{12} + a_{22} \u0026 a_{13} + a_{23} \u0026 \\cdots \u0026 a_{1k} + a_{2k}\\\\ a_{11} + a_{21} + a_{31} \u0026 a_{12} + a_{22} + a_{32} \u0026 a_{13} + a_{23} + a_{33} \u0026 \\cdots \u0026 a_{1k} + a_{2k} + a_{3k}\\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots\\\\ a_{11} + a_{21} + a_{31} + \\cdots + a_{k1} \u0026 a_{12} + a_{22} + a_{32} + \\cdots +a_{k2} \u0026 a_{13} + a_{23} + a_{33} + \\cdots + a_{k3} \u0026 \\cdots \u0026 a_{1k} + a_{2k} + a_{3k} + \\cdots + a_{kk} \\end{bmatrix}$$ 这样在计算子矩阵和时就只需要枚举子矩阵的起始行和结束行，两行之间的部分可视作一个一维的最大子序列和问题，只需枚举列数，从而将算法优化到O(N ^ 3)。\n下面给出最终优化后的代码：\n#include \u003cstdio.h\u003e #include \u003climits.h\u003e #define NMAX 1010 int matrix[NMAX][NMAX]; int max(int a, int b){ return a \u003e b ? a : b; } int main(void){ int n = 0, maxSum = -INT_MAX; scanf(\"%d\", \u0026n); for(int i = 0; i \u003c n; i++) for(int j = 0; j \u003c n; j++){ scanf(\"%d\", \u0026matrix[i][j]); matrix[i][j] += matrix[i - 1][j]; } for(int i = 0; i \u003c n; i++) for(int j = 0; j \u003c n; j++){ int sum = 0; for(int k = 0; k \u003c n; k++){ sum = max(sum, 0) + matrix[j][k] - matrix[i - 1][k]; if(sum \u003e maxSum) maxSum = sum; } } printf(\"%d\\n\", maxSum); return 0; } ","description":"","tags":["ACM报告"],"title":"基本算法(1)：枚举策略","uri":"/posts/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%951%E6%9E%9A%E4%B8%BE%E7%AD%96%E7%95%A5/"},{"categories":["Programming Contest","ACM"],"content":"《算法竞赛入门经典》3.3节中例举的竞赛题目中多有一些巧妙的程序编写思想的体现或小技巧，在此予以总结。\n例题3-1 Tex中的引号 (Tex Quotes, UVa 272) 边读入边操作 本题的测试数据是以行为单位，因此在编写程序时很容易想到先将每行内容作为字符串读入，再遍历字符串寻找引号进行操作。这种做法耗费的时间与空间开销至少有以下三个方面：\n需要建立一个缓冲区字符数组用以存放读入的字符串（且题中没有给出这个字符数组的大小上限） 读入字符串耗费的时间 遍历字符串查找引号耗费的时间、 此外还有一个问题不易解决：\n要替换的左双引号 ``和右双引号''均是两个字符，而要被替换的引号\"却是一个字符，不能直接在找到引号后将要替换的左（右）双引号直接插入字符串对应位置\n此时考虑另外一种思路：以字符为单位进行读入，在读入的同时立即进行判断，即可避免缓冲区的空间开销，亦可省去读入字符串的时间。\n小技巧 条件运算符在此处的使用printf(\"%s\", q ? \"``\" : \"''\");可使程序变得更简洁。 q = !q 例题3-2 WERTYU (WERTYU, UVa 10082) 使用常量数组 将键盘字符序列存储于一个常量数组中来将错误按键——正确按键的转换变为对数组下标的操作（因为错误按键与正确按键在键盘字符序列中相邻）。文中指出的另一种使用常量数组的方法亦是一种值得注意的打表思路。\n例题3-3 回文词 (Palindromes, UVa 401) 在同一循环中并行处理多个条件的判断 以此避免多个条件需要循环多次的时间开销。\n字符串数组msg[]的巧妙设计 巧妙地利用回文串和镜像串判断变量p和m的取值范围(\\({0, 1}\\))来计算msg[]的下标，进而输出想要的字符串，从而避免使用条件语句，使程序更简洁。\n例题3-4 猜数字游戏的提示 (Master-Mind Hints, UVa 340) 更换思路，避免直接判断 在计算B的值时，文中解法避免了对两个字符串进行搜索、统计，转而利用易于统计的直观条件，直接对数字1-9的出现次数进行判断，再减去易于统计的的A的部分，从而避免了繁杂的搜索、统计过程，曲线救国。\n例题3-5 生成元 (Digit Generator, UVa 1583) 打表 本题算法的时间复杂度是O(N),如果连续给出接近n上限的测试数据则可能导致TLE。为解决这一问题，直接对1~100000的n值进行打表，之后再使用查表法输出数据。\n例题3-6 环状序列 (Circular Sequence, UVa 1584) 善用模运算 由于本题操作对象的特性（环形），因此不必每次都实际进行将环状串“旋转”的操作，而是可以通过记录环状串的某种表示法在环状串中的开始位置来表示单种情况，又由于环状串的连续性（不会有插入和删除操作），因此只需用普通的字符数组存储输入串，对于需要越过输入串的结尾，重新从开头开始的情况，使用模运算计算下标，如s[(p + i) % n] 。\n","description":"","tags":["ACM解题总结"],"title":"《算法竞赛入门经典》3.3节例题总结","uri":"/posts/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B83.3%E8%8A%82%E4%BE%8B%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["Algorithm","Number Theory"],"content":"本文通过数学分析给出了输出n!末尾0的个数之函数的递归形式，并同时给出了两种本问题的枚举解法。\n问题描述 给定正整数n, 计算n!末尾0的个数。例：\n5! = 120, 故 5! 结尾0的个数为1.\n10! = 3628800, 故 10! 结尾0的个数为2.\n25! = 15511210043330985984000000, 故 25! 结尾0的个数为6.\n分析 导致末尾0出现的原因 众所周知，当一个正整数n与10相乘时会产生进位，即10n的末尾会比n多1个0。类似地，当一个正整数n与\\(10^{k}\\)相乘时，所得结果的末尾会比n多k个0. 又，由算术基本定理：\n每个大于1的自然数均可写为质数的积，而且这些素因子按大小排列之后，写法仅有一种方式。\n可知欲计算n!末尾0的个数，只需查找其分解中10的个数，也即查找n!的素因子分解中相乘等于10的两个质数组合的个数。\n命题1：10的素因子分解是2 * 5.\n证明：因为10是合数，所以10可记作多个质数之积。又因为10是偶数，所以10的素因子分解不能全为奇数。而偶素数只有2，故10的素因子分解中必有2，又10 / 2 = 5, 故10的素因子分解为2 * 5. 证毕。\n由此可见，欲计算n!末尾0的个数，只需统计n!的素因子分解中因子(2 * 5)的个数。又，因为奇数与偶数交替出现，所以每2个连续数字就会出现一个因子2，而每5个连续数字才会出现一个因子5，故因子(2 * 5)的个数即因子5的个数。此时，原问题转化为：计算n!的素因子分解中5的个数。\n计算n!的素因子分解中5的个数 为了计算正整数n的素因子分解中5的个数，我们可以计算n的某个分解中5的倍数的个数。\n由除法定理，任一正整数\\(n\\)可记作\\(n=5k+r\\), 其中\\(k=\\left \\lfloor \\frac{n}{5} \\right \\rfloor\\), \\(0\\leq r\\leq 4\\)。则\\(n!\\)的一个分解为$$n!=5k \\cdot 5(k - 1) \\cdot 5(k - 2) \\cdots 5 \\cdot A $$,即$$ n!=5^{k} \\cdot k! \\cdot A$$,其中\\(A\\)为不含因子5的因子。\n此时定义函数\\(f(n)\\)输出正整数\\(n\\)末尾0的个数，\\(g(n)\\)输出正整数\\(n\\)素因子分解中因子5的个数。由前述易知\\(f(n) = g(n)\\). 此时由g(n)的性质可导出以下命题：\n命题2：\\(g(\\prod_{i = 1}^{k} a_{i}) = \\sum_{i = 1}^{k} g(a_{i})\\), \\(a_{i}\\in \\mathbb{Z}\\)且\\(a_{i}\\neq 0\\).\n证明：\\(\\prod_{i = 1}^{k} a_{i}\\)的素因子分解为\\(a_{1}, a_{2}, \\cdots, a_{u}, \\cdots, a_{i}\\)的素因子分解之积，而后者中因子5出现的次数为数列\\(a_{i}\\)中每个元素之素因子分解中因子5出现的次数之和，故知前者的素因子分解中因子5的个数也等于上述和。证毕。\n故知\\(f(n) = g(n) = g(5^{k} \\cdot k! \\cdot A) = k + g(k!) = k + f(k!)\\), 其中\\(k = \\left \\lfloor n / 5 \\right \\rfloor\\). 又易知\\(f(n!) = 0\\ (0 \\leq n \\leq 4)\\), 此时即获得\\(f(n!)\\)的递归关系，这就是所求问题的解。例：\nf(5!) = 1 + f(1!) = 1\nf(10!) = 2 + f(2!) = 2\nf(25!) = 5 + f(5!) = 5 + 1 + f(1!) = 6\n代码实现 int FactZero(int n){ return n \u003c= 4 ? 0 : (n / 5) + FactZero(n / 5); } 枚举法 如果直接试图编程计算该问题，很容易导致溢出。但在进行了以上分析之后，即使未能得出最后的递归关系，只要知道求解本题只需统计n的素因子分解中5出现的次数，此问题亦可以用枚举法求解。\n统计5的倍数(5，10，15，20，25(= 5 ^ 2))出现次数 int FactZero(int n){ if(n \u003c= 4) return 0; else{ int i = 0, j = 0, count = 0; for(i = 5; i \u003c= n; i += 5){ j = i; while(j % 5 == 0){ count++; j /= 5; } } return count; } } 递归关系式的迭代形式 由上文分析的递归关系式，可知$$f(n!) = \\left \\lfloor n / 5 \\right \\rfloor + f(\\left \\lfloor n / 5 \\right \\rfloor!)$$$$=\\left \\lfloor n / 5 \\right \\rfloor + \\left \\lfloor n / 5^{2} \\right \\rfloor + f(\\left \\lfloor n / 5^{2} \\right \\rfloor!)$$$$=\\left \\lfloor n / 5 \\right \\rfloor + \\left \\lfloor n / 5^{2} \\right \\rfloor + \\left \\lfloor n / 5^{3} \\right \\rfloor + \\cdots$$\n故依次计算n / 5,直至n / 5 == 0输出结果。\nint FactZero(int n){ int count = 0; while(n \u003e 0){ count += n / 5; n /= 5; } return count; } ","description":"","tags":["ACM报告","数学"],"title":"n!末尾0的个数之计算","uri":"/posts/pow_n_tail_0_num_count/"},{"categories":["Programming Contest","ACM","HDU"],"content":"题目 Problem Description\n对于输入的每个字符串，查找其中的最大字母，在该字母后面插入字符串“(max)”。\nInput\n输入数据包括多个测试实例，每个实例由一行长度不超过100的字符串组成，字符串仅由大小写字母构成。\nOutput\n对于每个测试实例输出一行字符串，输出的结果是插入字符串“(max)”后的结果，如果存在多个最大的字母，就在每一个最大字母后面都插入\"(max)\"。\nSample Input\nabcdefgfedcba xxxxx Sample Output\nabcdefg(max)fedcba x(max)x(max)x(max)x(max)x(max) 题解 #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #define FOR_TEST 0 #define STRING \"(max)\" #define SIZE 110 char array[SIZE]; char FindMaxLetter(char* array); void ArrayTrans(char* array, int startIndex, int length); void StringInsert(char* array, int insertIndex, char* string); int main(void){ int i = 0; #if FOR_TEST sprintf(array, \"%s\", \"Donald Trump you strange man\"); printf(\"%s\\n\", array); printf(\"%c\\n\", FindMaxLetter(array)); for(i = 0; i \u003c strlen(array); i++) if(array[i] == FindMaxLetter(array)){ break; } ArrayTrans(array, i, strlen(\"SSY\")); printf(\"%s\\n\", array); StringInsert(array, i, \"SSY\"); printf(\"%s\\n\", array); #endif // FOR_TEST while(scanf(\"%s\", array) != EOF){ char maxLetter = FindMaxLetter(array); for(i = 0; i \u003c strlen(array); i++){ if(array[i] == maxLetter){ ArrayTrans(array, i + 1, strlen(STRING)); StringInsert(array, i + 1, STRING); i += strlen(STRING) - 1; } } printf(\"%s\\n\", array); memset(array, 0, sizeof array); } return 0; } char FindMaxLetter(char* array){ int i = 0; char max = array[0]; for(i = 0; array[i] != '\\0'; i++) if(array[i] \u003e max) max = array[i]; return max; } void ArrayTrans(char* array, int startIndex, int length){ int i = 0; for(i = strlen(array) + length; i \u003e= startIndex; i--) array[i] = array[i - length]; } void StringInsert(char* array, int insertIndex, char* string){ int i = 0, j = 0; for(i = insertIndex, j = 0; i \u003c insertIndex + strlen(string); i++, j++) array[i] = string[j]; } ","description":"","tags":["ACM题解"],"title":"HDU.2025 查找最大元素","uri":"/posts/hdu.2025_%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"},{"categories":["Programming Contest","ACM"],"content":" 约瑟夫环问题：设有编号为1，2，……，n的n(n\u003e0)个人围成一个圈，从第1个人开始报数，报到m时停止报数，报m的人出圈，再从他的下一个人起重新报数，报到m时停止报数，报m的出圈，……，如此下去，直到所有人全部出圈为止。\n程序输入说明：输入两个数 n和m，1\u003c=n\u003c=100,1\u003c=m\u003c=n\n程序输出说明：每组输出一行，表示n个人出圈的顺序，相邻两个数字之间隔一个空格\n程序输入样例：6 2\n程序输出样例：2 4 6 3 1 5\n分析 因为题目中的n个成员构成一个环图，故声明一个Joseph数组，以数组下标序列作为成员序列，并将每个数组成员的值设为与其相连的下一个数组成员的下标（例：n == 3时，有Joseph[1] == 2, Joseph[2] == 3, Joseph[3] == 1)。从第一个数组成员开始计数，每当计数至m名成员时，即将第m名成员的前一名成员的指向设为第m名成员的指向（例：如果有Joseph[2] == 5, Joseph[5] == 7, 则将Joseph[2]设为7，使沿着环计数时不会再遍历至Joseph[5], 从而将Joseph[5]踢出环图）并输出第m名成员的下标。一直进行至存在Joseph[i] == i，此时环内还剩一名成员，遍历结束，输出这名成员的下标。\n题解 #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #define SIZE 110 int Joseph[SIZE]; // 递归地遍历环，判断是否要将第pepNum名成员踢出环 int kickOutOfRing(int lastPepNum, int pepNum, int m, int lifeNum); int main(void){ int n = 0, m = 0; int i = 0; // 初始化Joseph数组并将n名成员全部加入环 memset(Joseph, 0, sizeof Joseph); scanf(\"%d %d\", \u0026n, \u0026m); for(i = 1; i \u003c= n - 1; i++){ Joseph[i] = i + 1; } Joseph[n] = 1; printf(\"%d\\n\", kickOutOfRing(n, 1, m, 1)); // 开始遍历环，并输出最后一名成员的下标 return 0; } int kickOutOfRing(int lastPepNum, // 与第pepNum名成员相连的上一个成员之下标 int pepNum, // 要判断是否踢出环的成员之下标 int m, // 即输入的m int lifeNum // 计数在踢出的两名成员之间已经遇到几个成员 ){ if(Joseph[pepNum] == pepNum) return pepNum; // 如果只剩一名成员，直接返回其下标，结束递归 else{ if(lifeNum == m){ // 如果距上一次踢出某个成员起，已经遇到m名成员 Joseph[lastPepNum] = Joseph[pepNum]; // 更改指向，踢出成员 printf(\"%d \", pepNum); lifeNum = 1; // 初始化计数器 return kickOutOfRing(lastPepNum, Joseph[pepNum], m, lifeNum); } else { lifeNum++; return kickOutOfRing(pepNum, Joseph[pepNum], m, lifeNum); } } } ","description":"","tags":["ACM题解"],"title":"AOJ.645 约瑟夫环","uri":"/posts/aoj.645_%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"},{"categories":["Algorithm","Graph","Basic Concepts"],"content":"本文以尽可能简明扼要的语言介绍在研究图算法时会遇到的图的相关概念。\n什么是图 实际应用中的许多计算问题，不仅涉及到问题中的元素，也涉及到这些元素之间的关系。比如，如何表示一个生态系统中物种的竞争关系？又如，在我们握有一个城市的一份 街道地图的情况下，我们怎样才能找到从城市中一点到另一点的最短路径？这时，我们需要用一种被称作图的数学模型对这些问题进行描述。图是由顶点和连接顶点的边组成的离散结构。简单地说，图就是由若干给定的点（称为顶点）以及连接两点的线（称为线）所构成的图形。我们通常用顶点表示问题中涉及的事物，用边表示这些事物之间的关系。\n图是图论的基本研究对象，而图论是组合数学的一个重要分支。自欧拉于1735年发表柯尼斯堡七桥问题的研究成果以来，图论已经得到了数百年的研究。而在计算机科学领域中，大量的算法涉及到图及其衍生结构的使用。\n图的基本概念 简单图，多重图与一般图 我们给出图的定义：\n一个图\\(G = (V, E)\\)由顶点的非空集\\(V\\)和边的集合\\(E\\)构成，每条边 有一个或两个顶点与它相连，这样的顶点称为边的端点。边连接它的端点。 顶点的个数称为图的阶。\n容易注意到这个定义使得图具有两个特殊的性质（由集合的互异性）：\n图不允许出现多重边，也即没有两条不同的边连接一对相同的顶点。 图不允许出现自环， 也即没有任何一条边仅连接一个定点自身。 但是实际问题中很少有情况完全符合这两个条件。考虑下面的两个例子：城市中两个地点之间可能有多条路相连；知乎上某个问题的提问者可以自问自答。参考图的定义，我们将无法为上述两种情况（城市不同地点及其连接道路之间的关系、知乎上某个问题的提问者与回答者之间的关系）建立数学模型。因此，我们有必要扩展图的定义使之适合的情况更为广泛。我们给出新的定义：\n有多重边连接同一对顶点（但不存在自环）的图称为多重图。如图中的红色边。\n存在自环（也可能存在多重边）的图称为一般图（伪图）。如图中的蓝色边。\n我们将符合图的原始定义的图称作简单图。\n有向图与无向图 到现在为止，我们提到的图的边都是不带有方向的。但是有些情况下我们可能需要为边赋予方向，例如：生态系统中的食物链，以及不同数据中心之间的数据传输。为此，我们需要定义有向图的概念：\n一个有向图\\((V,E)\\)由一个非空顶点集\\(V\\)和一个有向边集\\(E\\)组成。每条有向边与一个顶点有序对相关联。与有序对\\((u, v)\\)相关联的有向边开始于\\(u\\)，结束于\\(v\\)。\n相应地，我们将边不带有方向的图称为无向图。与之前的多重图和一般图的定义类似，如果在有向图的\\((u, v)\\)之间存在\\(m\\)条方向相同的有向边（或者自环）时，称作\\((u, v)\\)间具有多重有向边，此时的有向图称为有向多重图,将\\((u, v)\\)称作一条多重度为\\(m\\)的边。\n如果在一个图中既有有向边又有无向边，则将这个图称作混合图。\n图的相关术语 顶点与边的关系 当两个顶点通过一条边相连时，我们称这两个点邻接，称连接这两个点的边关联这两个顶点。顶点\\(v\\)的度是关联于其的边的总数，记为\\(deg(v)\\)。度分为入度和出度，分别是以某个顶点作为终点的边的数目和以某个顶点作为起点的边的数目。\n容易注意到关于顶点的度有如下结论：\n自环对一个顶点的度的贡献是2。 握手定理：一个具有m条边的一般图的边的条数是其所有顶点度数之和的一半。 无向图有偶数个度为奇数的顶点。 子图与连通图 子图 一个一般图的所有边（以及其关联的所有顶点）的集合的一个子集称为这个图的一个一般子图。如果子图的顶点集关联的所有边也是原图中对应顶点集关联的所有边，则将这个子图称为原图的一般导出子图。如果子图的顶点集即为原图的顶点集，则将这个子图称作原图的一般生成子图。\n连通图 在图中，路径是由边顺序连接的一系列顶点。\n简单路径是一条没有重复顶点的路径。环是一条至少含有一条边且起点与终点相同的路径。简单环是一条不含有重复顶点（除去起点与终点）和边的环。路径或环的长度为其中所包含的边数。\n如果从任意一个顶点都存在一条路径到达另一个任意顶点，我们称这个图是连通图。\n树 树是一种特殊的图，指的是一个没有环的连通无向图。\n树是图的一种特例，但与图不尽相同，可以用来为另外许多问题建模，比如：有机化合物的结构式是一棵树，族谱中的家族树也是树的例子。树同时还是一种数据结构，在算法领域尤其有用。\n树的相关术语 树的大多数术语与图相同，除了一些树特有的概念：\n根是一个特殊选定的节点，类似于自然界中的树，树从根节点开始“分枝”。如图中的节点0。\n将树中度为1的节点称作叶。如图中以绿色标出的节点。\n在一棵树中选定了根节点之后，就可以引入层的概念。层是每个点离根的距离，将一棵树的最大层数称作树的深度。\n在树中选定一个节点，则这个节点的上一层节点称作这个节点的父节点，下一层节点称作这个节点的子节点，同一层的其他节点称作这个节点的兄弟节点。\n森林是互不相连的树组成的集合。\n","description":"","tags":["ACM报告"],"title":"图算法简论(1) ：图的基本概念","uri":"/posts/%E5%9B%BE%E7%AE%97%E6%B3%95%E7%AE%80%E8%AE%BA1_%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"}]